Question 1
interface Readable {
		
			public void readBook();
			public void setBookMark();
		}
		abstract class Book implements Readable { //line n1
			public void readBook()   {   }//line n2

		}
		class EBook extends Book {//line n3
			public void readBook() {   }// line n4

		}

Which options enables the code to compile?
A)	Replace the code fragment at line n1 with:
Class Book implements Readable {

B)	At line n2 insert:
Public abstract void setBookMark();

C)	Replace the code fragment at line n3 with:
abstract class EBook extends Book {
D)	At line n4 insert:
Public void setBookMark () {  }
Answer C D
As class Book is concrete class that extends a abstract method, which implements the Readable interface, the Book class HAS to implement all the abstract methods contained within the Readable interface, which it is currently not doing.
•	Option A is incorrect as if you have a concrete class implementing a interface you have to provide implementation for all of the abstract methods contained within that interface. If we make the class concrete we would have to provide implementation for readBook() and setBookMark() methods in the Readable interface
•	Option B is incorrect as we are still not providing implementation for the setBookMark() in the Book Class, this is only redefining the abstract method setBookMark()
•	Option C is correct as we now have an abstract class extending an abstract class so we would then NOT have to provide implementation for all the abstract methods in the Readable interface
•	Option D is correct as we now have implementation for both abstract methods readBook() and setBookMark() in the concrete class EBook
Question 2
Given the code fragment:

public static void main (String[] args)  {
	
		List<String>names = new ArrayList<>();
		names.add("Robb");
		names.add("Bran");
		names.add("Rick");
		names.add("Bran");

	if (names.remove("Bran")){
		names.remove("Jon");}
	
	System.out.println(names); 
	}
What is the result?
[Robb, Rick, Bran]
[Robb, Rick]
[Robb, Bran, Rick, Bran]
An exception is thrown at runtime.

Answer A
The method remove() does two things, first off it searches for something and returns a boolean, “true” if found, “false” if not found. Secondly, if it finds what it is looking for, it will remove the FIRST instance. So our list starts off with the following names:
Robb
Bran
Rick
Bran
Then the statement
If (names.remove(“Bran”))  
Checks the list for Bran, returns true, and removes it from position 2 in the list. As part of the If statement the statement
names.remove(“Jon”);
is carried out, but “jon” does not exist on the list so this returns false.
So our list now contains
Robb
Rick
Bran
 
Question 3
class A {
		public A() {
		System.out.print("A");}
	}

	class B extends A{
	public B() {						//line n1
	System.out.print("B");}
	}

	class C extends B{
	public C () {
	System.out.print("C");				//line n2
	}
	public static void main (String[] args) {
	C c = new C();
	}
	}

A.	CBA
B.	C
C.	ABC
D.	Compilation fails at line n1 and line n2
Answer C
Class C extends Class B which extends Class A. So the constructor in the C class calls a no arguments constructor in the B class which calls the no arguments constructor in the A class. The call to another constructor, is the FIRST thing that has to happen inside a constructor.  So the chain of command goes up to the A class constructor and prints out “A”, then goes to the B class constructor and prints “B” and then comes back down to the C constructor and prints “C”
 
Question 4
class X {
	
	static int i;
	int j;

	public static void main (String[] args) {
		X x1 = new X();
		X x2 = new X();

		x1.i = 3;
		x1.j = 4;
		x2.i = 5;
		x2.j = 6;

	System.out.println(
		x1.i  + " " +
		x1.j  + " " + 
		x2.i + " " +
		x2.j );
	}
	}
What is the result?
A.	3456
B.	3436
C.	5456
D.	3646
Answer C
The static int I, has only one copy per class. So that means that all variables SHARE the same value. So if one instance of the class changes the static variable I, it is changed for all instances. 
X1.i=3
That means the following statement
System.out.println(X1.i+” “+X2.i)
Would print out
3 3
So when in our program the static variable I is accessed and changed to 5, by this line of code.
X2.i=5
Now X1.i is also 5, this is accessing a static variable in a non static way (accessing in a static way is by class name followed by variable name, i.e X.i in this case)
So the answer is 5456
 
Question 5
Given the code fragment:
1.	Public class Test {
2.	Public static void main (String [] args) {
3.	/* insert code here */
4.	Array[0]=10;
5.	Array [1]=20;
6.	System.out.print(array[0]+”:”+array[1]);
7.	}
8.	}
Which code fragment, when inserted at line 3, enables the code to print 10:20?
A.	Int[]Array = new int[2];
B.	Int[]Array;
Array = int[2];
C.	Int array = new int[2];
D.	Int array[2];

Answer A
•	Option A is correct as this is the correct way to create an array called “Array” of length 2.
•	Option B is incorrect as you can’t give a length to an array over two lines of code, Array=int[2] is the incorrect syntax
•	Option C is incorrect as you have to use the square brackets, [] on the left hand side
•	Option D is incorrect as this is the wrong syntax
 
Question 6
Given the code fragment:
public static void main (String[] args) {
		
		String [] arr = {"A", "B", "C", "D"};
		
		for (int i =0; i<arr.length; i++) {
			System.out.print (arr[i]  + " ");
			if (arr[i] .equals("C")) {
				continue;
			}
			System.out.println ("Work done");
		}
	}
What is the result?
None of these answers
A.	ABC Work done
B.	ABCD Work done
C.	A Work done
D.	Compilation fails
E.	None of the Above
Answer is E
None of these answers are correct, the correct answer is
A Work done
B Work done
C D Work done
System.out.print will not have a different line each time it is used, system.out.println will put any other print statement after this on a new line.
 
Question 7
Which three are advantages of the java exception mechanism?
Answer A,C,E
A.	Improves the program structure because the error handling code is separated from the normal program function.
B.	Provides a set of standard exceptions that covers all the possible errors.
C.	Improves the program structure because the programmer can choose where to handle exceptions.
D.	Improves the program structure because exceptions must be handled in the method in which they occurred.
E.	Allows the creation of new exceptions that are tailored to the particular program being created
 
Question 8
Given the code from the Greeting.Java file:

Public static void main (String[] args){
System.out.println (“Hello “ + args [0]);

}


Which set of commands prints Hello Duke in the console?
A)	javac Greeting
java Greeting Duke
B)	Javac Greeting.java Duke
Java Greeting
C)	javac Greeting.java
java Greeting Duke
D)	javac Greeting.java
java Greeting.class Duke

Answer is C
Every java program has to be first compiled and then run, the two commands that accomplish this are “javac” to compile and “java” to run. 
The format for compiling is javac filename.java
The format to run is java filename stringsToPassToMainMethod
So the option C will cause the string “Duke” to be passed into the main method’s array of Strings, as the first string in the list. The line system.out.println(“hello “+args[0]); will then print out
“Hello Duke”
 

Question 9
class Alpha {
		int ns;
		static int s;
	
		Alpha(int ns) {	
		
		if (s<ns){
			s = ns;
			this.ns = ns;}
		}
	
		void doPrint() {
		System.out.println("ns = " + ns + " s = "+s);
	}
	}

	public class TestA {
	
	public static void main (String[] args) {
	
		Alpha ref1 = new Alpha(50);
		Alpha ref2 = new Alpha(125);
		Alpha ref3 = new Alpha(100);
	
		ref1.doPrint();
		ref2.doPrint();
		ref3.doPrint();
	}
	}
What is the result?
A)	ns = 50 s = 125
ns = 125 s = 125
ns = 100 s = 125

B)	ns = 50 s = 125
ns = 125 s = 125
ns = 0 s = 125

C)	ns = 50 s = 50
ns = 125 s = 125
ns = 100 s = 100

D)	ns = 50 s = 50
ns = 125 s = 125
ns = 0 s = 125

Answer is B
when statics change they change for ALL variables as there is only one static per class, so if one object changes a static it changes for all objects.
 
Question 10
Given the code fragment:

Public static void main (String[] args) {
Int ii = 0;
Int jj = 7;
For (ii = 0;  ii < jj – 1;   ii = ii + 2) {
System.out.print(ii + “ “);


}
}
What is the result?
A.	24
B.	0246
C.	024
Answer is C
This line
For (ii = 0;  ii < jj – 1;   ii = ii + 2)
Translates to 
For(ii=0;ii<6;ii+=2)
the loop starts out at 0, increments by 2 each time until it reaches 6 and then exits. Each time it prints out the value of the counter ii, so first time in the loop it prints out 0, then increments by 2, prints out 2, then increments by 2, prints 4, then increments by 2. Ii is now 6, but 6 is NOT less than 6, so the loop exits.

 
Question 11
//this question will assume that todays date is 20-06-2014
package com.test
import java.time.LocalDate;

public class Questions{
	public static void main(){
		LocalDate date1=LocalDate.now();
		LocalDate date2=LocalDate.of.(2014,6,20);
		LocalDate date3=LocalDate.parse(“2014-06-20”,DateTimeFormatter.ISO_DATE);
		system.out.println(“Date 1 =”+date1);
		system.out.println(“Date 2 =”+date2);
		system.out.println(“Date 3 =”+date3);
}
}

A: Date 1 = 2014-06-20
Date 2 = 2014-06-20
		Date 3 = 2014-06-20
B: Date 1 = 2014-06-20
Date 2 = 2014-06-20
		Date 3 = 20-06-2014
C: Date 1 = 20-06-2014
Date 2 = 20-06-2014
		Date 3 = 2014-06-20
D: Date 1 = 2014-06-20
Date 2 = 2014-06-20
		Date 3 = 2014-06-20

Answer is D
. 
	This prints out as such:
		Date 1 = 2014-06-20
Date 2 = 2014-06-20
		Date 3 = 2014-06-20
The parse method of the LocalDate class takes a string in the correct format and converts it to a date, it will take any string and compile, however if the string is not in the correct format you will get a DateTimeParseException. ISO_Date is the standard format which is in YYYY-MM-DD



 
Question 12

Public static void main(){
	StringBuilder sb1=new StringBuilder(“Duke”);
	String str1=sb1.toSTring();
// n1
System.out.println(str1==str2);
}

What option, inserted indepantly inserted at n1, enables this to compile and print true
A.	String str2=str1;
B.	String str2=new String(str1);
C.	String str2=sb1.toString();
D.	String str2=”Duke”;
 Answer A

Option A is correct because str1 and str2 now point to the same string.
Option B is incorrect because it creates a new object and the test is to find out whether they are the same object.
Option C is incorrect because the toString method creates a new string object.
Option D is incorrect because this makes a string that isn’t added to the string pool and then the test concludes that they couldn’t be pointing to the same place.






 
Question 13


Public class Test{
	Static int count=0;
	Int i=0;
	Public void changeCount(){
			While(i<5){
				i++;
				Count++;
			}
	}
	Public static void main(String[]args){
			Test check1=new Test();
			Test check2=new Test();
			Check1.changeCount();
			Check2.changeCount();
			System.out.print(check1.count+” ; “+check2.count);
	}
}
What is the result
A.	10:10
B.	5:5
C.	5:10
D.	Compilation fails
Answer is A
Check1 and check2 are created and both have initial field value for count and I set to 0. Check1.changCount() increments the value of I and count by 1 five times with a loop. This is an non static method and a non static method can access both statics and non statics, so there is no issue with this method. This is assuming that “Check1” is not a typo.
so the final values of I and count after this method is:
I=5, count=5
Then check2 calls on the changeCount()method, however remember that count is static variable, so it is a CLASS variable and this value is shared by INSTANCES of the class, so our initial starting value for count is 5. The method executes and increments I by 5, and 1 increments count by 5
So at the end of the method the values are as follows
I=5, count=10
So that means that check1.count and check2.count are the value 10, as static variables are SHARED across all insances of the class, so if you change it for member, you change it for every member.



 
Question 14
Given the code
Public static void main(String[] args){
	Double discount=0;
	Int qty=integer.parseInt(args[0]);
	//line n1;
}

And given the requirements
If the value of the qty is greater than or equal to 90, the discount 
is 0.5.If qty is between 80 and 90 the discount is 0.2.

which options, when inserted at line n1 will fufill these requirements?
A : If(qty>=90){discount=0.5}
	If(qty>=80 && qty< 90){discount=0.2;}
	System.out.println(discount);
B: discount=(qty>=90)?0.5:0;
	Discount=(qty>80)?0.2:0;
	System.out.println(discount);
 
 
 
 
 

 
Question 15


String[] array=new String[1]
Array[0]=”Hello”;
If(array[0].equals(“Hello”)?false:true){
	System.out.println(“success”);
Else{
	System.out.println(“failure”);
}
What is the answer
A.	Will print Success
B.	Will print Failure
C.	Will print nothing
D.	Will not compile
Answer is B
Array is a string array of size one, so you can only access one position on this array, so 
Array[0]=”Hello”; will compile
Our if statement then checks to see if the string contained in the first position in the array is the same as the string “Hello”. It is the same. However the line
if If(array[0].equals(“Hello”)?false:true){
sets the condiational part of the if statement to “false” as the first part of the tetnary operator is “false” is the two strings are the same.
 
Question 16
Which three statements describe the object-orientated features of the java language?
A.	Objects cannot be reused.
B.	A subclass can inherit from a superclass.
C.	Objects can share behaviour with other objects.
D.	A package must contain more than one class.
E.	Object is the root class of all other objects.
F.	A main method must be declared in every class.

Answer is B,C,E

 
Question 17


Static void main(String[]args){
	String[]planets={“Mercury”,”Venus”,”Earth”,”Mars”};
	System.out.println(planets.length);
	System.out.println(planets[1].length());
}

A.	4,4
B.	7,5
C.	4,5
D.	4,7
Answer is C
Planets.length will return the amount of Strings in the array in this case its 4 and planets[1].length() will return the amount of characters in the second element of the array (indexing starts at zero). So the answer is 4,5.
 
 
Question 18

You are developing a banking module.
You have developed a class named ccMask that has a maskcc method.
Given the code fragment:
Package com.test;

class CCMask{
Public static String maskCC(String creditCard){
String x = “XXXX-XXXX- XXXX-“
//line n1
}
Public static void main (String[] args) {
System.out.println(maskCC(“1234-5678- 9101-1121”));
}
}
You must ensure that the maskcc method returns a string that hides all digits of the credit
card number except the four last digits (and the hyphens that separate each group of four
digits).
Which two code fragments should you use at line n1, independently, to achieve this
requirement?

A) StringBuilder sb = new StringBuilder(creditCard);
Sb.substring(15,19);
Return x + sb;

B) Return x + creditCard.substring(15,19);

C) StringBuilder sbl = new StringBuilder(x);
Sbl.append(creditCard, 15,19);
Return sb.toString();

D) StringBuilder sb = new StringBuilder(creditCard);
StringBuilder s = sb.insert(0,x);
return s.toString();
Answer B, C

We are trying to replace the first 14 characters of your credit card with the string “XXXX-XXXX- XXXX-“. So we will only display the last four digits of the credit card, and how we get this string will be by using the substring command, which will be something like this, substring(15,19). 
So we can exclude option D as it does not have the substring command.
A is incorrect as sb.substring(15,19) does not change sb, sb still has all the credit car details. So the statement return X + sb will be the string
XXXX-XXXX- XXXX -1234-5678- 9101-1121
B is correct as this returns X, which is XXXX-XXXX- XXXX and a substring of the last four characters of the Credit card number, which will be 1121
C is correct, 
StringBuilder sb = new StringBuilder(x); creates a new stringBuilder object that has the string
XXXX-XXXX- XXXX
Sbl.append(creditCard, 15,19);
This command then appends the last four digits of our credit card onto the string with all the x’s.
The command sb.toString() then returns the Stringbuilder object as a string.
D is incorrect
The command
StringBuilder s = sb.insert(0,x);
Merely inserts the String 
XXXX-XXXX- XXXX
At the beginning of the credit cart  numbers, so you will end up with 
XXXX-XXXX- XXXX
 
Question 19
Public class App {
Public static void main (String [] args){
String str1 = “Java”;
String str2 = new String (“java”);
//line n1
{ 
System.out.println(“Equals”);
}
Else{
System.out.println(“Not Equals”);
}
}
}

Which code fragment, when inserted at line n1, enables the App class to print Equal?
A)	String str3 = str2;
If (str1 == str3)
B)	If (str1.equalsIgnoreCase (str2))
C)	String str3 = str2;
If (str1.equals (str3))
D)	If (str1.toLowerCase() == str2.toLowrCase())

Answer B
A)	String str3 = str2;
      If(str1==str3)
{
System.out.println(“Equals”);
}
Else{
System.out.println(“Not Equals”);
}
Incorrect: str3 now points to str2 which is a new String object so comparing str1==str3 will evaluate that they point to different objects and then print out Not Equals
B)	If(str1.equalsIgnoreCase(str2))
{
System.out.println(“Equals”);
}
Else{ 
System.out.println(“Not Equals”);

}
Correct: compares the characters and returns as the both equal java upper case and lower case doesn’t matter because it specifies ignore case.

C)	String str3 = str2;
      If(str1.equals(str3))

{
System.out.println(“Equals”);
}
Else{ 
System.out.println(“Not Equals”);
Incorrect:str3 holds the String java (all lower case) and str1 hold the String Java (capital j). unlike equalIgnoreCase this take into account the case and evaluates that they do not hold the same characters and prints out Not Equals

D)	If(str1.toLowerCase()==str2.toLowerCase())
{
System.out.println(“Equals”);
}
Else
{
System.out.println(“Not Equals”);
}
Incorrect: This converts both strings to lower case which is irrelevant in this case because it is check to see if they point to the same object

 
Question 20
Package com.test;
Public class SumTest {
	Public static void doSum(Integer x, Integer y) {
	System.out.println(“Integer sum is “ + (x+y));
}
Public static void doSum(double x, double y) {
System.out.println(“double  sum is “ + (x+y));

}
Public static void doSum(float x, float y) {
System.out.println(“float  sum is “ + (x+y));
}
Public static void doSum(int x, int y ){
System.out.println(“int  sum is “ + (x+y));
}
Public static void main(String [] args){
doSum (10, 20);
             doSum (10.0, 20.0);
}
}
What is the result?
A)	int sum is 30 
                  float sum is 30.0                                                                 

B)	int sum is 30 
                 double sum is 30                                                               

C)	Integer sum is 30 
                  double sum is 30.0                                                                 

D)	Integer sum is 30 
                  float sum is 30.0                                                                 

Answer B

 
Question 21
static void Q21(){
		String [] strs = new String[2];
		int idx = 0;
		
		for (String s : strs){
			strs[idx].concat(" element " + idx);
			idx++;
		}
		
		for (idx = 0; idx< strs.length; idx++){
			System.out.println(strs[idx]);
		}


What is the result?
A.	Element 0
Element 1
B.	Null element 0
Null element 1
C.	Null
Null
D.	A NullPointerException is thrown at runtime

Answer D
When we create a array of objects and not assist any explicit values to any position in the array, the default value of each of the postions in the array is null (in an array of numbers the default is 0, of Booleans default is false, chars is a blank character). So in this example we have an array of two null objects, which is not an exception but if we attempt to do anything with an null you will get a NullPointerException. 
The lines
strs[idx].concat(" element " + idx);
will cause a NullPointerException as we are trying to add the word “element” to the end of each string in the array and then add the string again to the end of the “element”. This Array does not contain strings, but null objects. 
		
		 

 
Question 22
package com.test;
//Question 22
public class Vehicle {
	int x;
	public Vehicle() {
		// TODO Auto-generated constructor stub
		this(10);	//Line n1
	}
	public Vehicle(int x) {
		this.x = x;
	}	
}
class Car extends Vehicle{
	int y;
	public Car() {
		// TODO Auto-generated constructor stub
		super();
//		this(20);	//Line n2
	}
	public Car(int y) {
		this.y = y;
	}
	public String toString(){
		return super.x + " : " + this.y;
	}
	
}

A 10:20
B 0:20
C Compliation fails at line n1
D Compilation fails at line n2
Answer is D

Line n1 will works fine it is just calling the other constructor in the Vehicle class that takes an int. Where the error occurs is line n2 you can only do one call to a constructor in another constructor. i.e.
Car(){ super(); this(10);} is illegal
----------------------- 
Car(int a){super();}
Car(){this(10);} is legal


 
Question 23
package com.test;
//Question 23
public class MyString {
	String msg;
	MyString(String msg){
		this.msg = msg;
	}
}
-----------------
System.out.println("Hello " + new StringBuilder("Java SE 8"));
System.out.println("Hello " + new MyString("Java SE 8"));

Answer A 
Hello Java SE 8
Hello Java SE 8

Answer B
Hello java.lang.StringBuilder@hashcode
Hello p1.MyStringBuilder@hashcode

Answer C
Hello Java SE 8
Hello p1.MyString@hashcode

Answer D
Compilation Fails at the Test Class



Answer is C
The StringBuilder prints out just like a normal String. SE 8. The MyString has not defined its toString method so it just prints out the hash code of the MyString object.


 
Question 24
 
If you are trying to assign a variable to another variable that is bigger then you need to implicitly cast it (widening), i.e. when assigning a float to an int you need to initialise it as follows int = (int) float. However, if the variable is smaller than the one you are assigning to it you do not need to cast(narrowing) i.e. when assigning an int to a float you do not need to cast float = int.
 
Question 25
MainTest.java

public class MainTest
{
	public static void main(int[] args) {
		System.out.println("int main " + args [0]);
	}
	public static void main(Object[] args) {
		System.out.println("Object main " + args [0]);
	}
	public static void main(String[] args) {
			System.out.println("String main " + args [0]);
	}
}

And commands:

javac MainTest.java
java  MainTest 1 2 3 
What is the result? 
a. int main 1
b. Object main 1
c. String main 1
d. Compilation fails
e. An exception is thrown at runtime

Answer is C

When you pass anything into main via the command line prompt, you are passing the arguments into an array of Strings. So if we are passing in the arguments, 1 2 3, we are actually passing in an array of strings, called args, with the values “1”,”2”,”3”. These are overloaded main() methods, but when running a program from the command line prompt, the compiler will ALWAYS look for the main method that takes an array of strings. So the main method
public static void test(String[] args) {
runs and prints out the line
String main 1

 
Question 26
Given the code fragment:

int num[] [] = new int[1] [3];
for (int i = 0; i < num.length; i++) {
	for (int j = 0; j < num[i].length; j++) {
		num[i] [j] = 10;
	}
}
Which option represents the state of the num array after successful completion of the outer loop?

A)	num [0] [0] = 10
num [0] [1] = 10
num [0] [2] = 10

B)	num [0] [0] = 10
num [1] [0] = 10
num [2] [0] = 10

C)	num [0] [0] = 10
num [0] [1] = 0
num [0] [2] = 0

D)	num [0] [0] = 10
num [0] [1] = 10
num [0] [2] = 10
num [0] [3] = 10
num [1] [0] = 0
num [1] [1] = 0
num [1] [2] = 0
num [1] [3] = 0

Answer is A
The line 
Int num[][]=new int[1][3] is an two dimensional array of one row and three columns, which is actually the same as a ordinary one dimensional array of length 3. 
So this line
Num[i][j]=10 will produce the following
Num[0][0]=10;
Num[0][1]
Num[0][2]


 
Question 27
Given the code fragment:
 public class Person {
	String name;
	int age = 25;

	public Person(String name) {
		this();					// line n1
		setName(name);
	}
	public Person(String name, int age) {
		Person (name);			// line n2
		setAge(age);
	}

//setter and getter methods go here

public String show () {
	return name + “ “ + age + “ “ + number;
}
public static void main(String[] args) {
	Person p1 = new Person(“Jesse”);
	Person p2 = new Person(“Walter”, 52);
	System.out.println(p1.show());
 	System.out.println(p2.show());
}
}

A)	Jesse 25
Walter 52
B)	Compilation fails at line n1
C)	Compilation fails at line n2
D)	Compilation fails at both line n1 and n2
Answer is B
The first person created is p1 and this uses the constructor in the Person class that takes a string. The constructor
Person(String name){
This()	
	Causes a compilation error as This() is looking for a constructor in the same class we are in that takes no arguments. This constructor does NOT exist in this class, so we have a compilation error on line n1. Line n2 would causle a compilation error, as this is the INCORRECT way to call a constructor from inside another constructor (you use super and this). So yes n2 does cause a compilation error, however the compiler never gets that far because of the first compilation error


 
optQuestion 28
Given the following code for a Planet object:

	public class Planet {
		public String name;
		public int moons;

		public Planet(String name, int moons) {
			this.name = name;
			this.moons =moons;
		}
	}

And the following main method:

	public static void main(String[] args) {
		Planet[] planets = {
			new Planet (“Mercury”, 0),
			new Planet (“Venus”, 0),
			new Planet (“Earth”, 1),
			new Planet (“Mars”, 2)
		};

		System.out.println(planets);
		System.out.println(planets[2]);
		System.out.println(planets[2].moons);
	}
What is the output?

A)	planets
Earth
1
B)	[LPlanets.Planet;@15db9742
Earth
1
C)	[LPlanets.Planet@15db9742
Planets.Planet@6d06d69c
1
D)	[LPlanets.Planet@15db9742
Planets.Planet@6d06d69c
[LPanets.Moon;@7852e922
E)	[LPlanets.Planet@15db9742
Venus
0

Answer is C
When you put a array into a print statement it just prints out the address of the array, unlie an ArrayList that does have a toString method that will print out the list of elemetns. 
So 
System.out(planets)
Will print out 
LPlanets.Planet@15db9742
The Planets class has NO toString method, so that means it takes it’s toString method from the object class. So again this will just print out the address of the Planet contained in the second position in the array.
The code
System.out.println(Planets[2].moons);
This is just a int instance variable of the planet class, it is the amount of moons for a planet. The planet at this position is “Earth” and the amount of moons is 1


 
Question 29
You are asked to develop a program for a shopping application and you are given the following information:
-	The application must contain the classes Toy, EduToy and consToy.
-	The Toy class is the superclass of the other two classes.
-	The int calculatePrice (Toy t) method calculates the proce of a toy.
-	The void printToy (Toy t) method prints the details of a toy.

Which definition of the Toy class adds a valid layer of abstraction to the class hierarchy?

A)	public abstract class Toy {
public abstract int calculatePrice (Toy t);
public void printToy (Toy t) {/*code goes here*/)
	}
B)	public abstract class Toy {
public int calculatePrice (Toy t);
public void printToy (Toy t);
	}
C)	public abstract class Toy {
public int calculatePrice (Toy t);
public final void printToy (Toy t) {/*code goes here*/)
	}
D)	public abstract class Toy {
public abstract int calculatePrice (Toy t) {/*code goes here*/)
public abstract coid printToy (Toy t) {/*code goes here*/)
	}

Answer is A
A is correct as this is the correct way to declare an abstract calculatePrice(Toy t) method and you can have a concrete method inside a abstract class
B is incorrect as only an abstract method can have no body, and they also must be declared abstract. The only place you do not have to explicityly declare an abstract method as abstract is in an interface
C is incorrect as again the public int calculatePrice(Toy t) has no body is not declared abstract
D is incorrect as if a method is declared abstract it CAN’T have any body, and these methods are declared abstract and have a body which you can’t have

 
Question 30

 
Answer A: NOT CORRECT - 
Answer B: NOT CORRECT -
Answer C: CORRECT  - intArr is size 5 (but indexing 0-4, not 1-5), statement intArr[2] = intArr[4];
causes that primitive value 45 (indicated by intArr[2] position) is replaced by value 75 (which is intArr[4] position), then statement intArr[4] = 90; changes the value of int (75) (position intArr[4] )to value 90, rest of values in the array (intArr[])remains the same
Answer D:NOT CORRECT 
Answer E:NOT CORRECT 
 
Question 31
  
Answer A:NOT CORRECT - this will throw ArrayIndexOutofBondsException, this is enhanced loop, where iterator is hidden, statement System.out.println(intArr[i]+" "); will assign value of i to value of index for intArray array (so it means that value of i=8 (first element of an array) gives intArr[8] - which is not available, because the size of array is 5, 8th position does not exists
Answer B: CORRECT - this is the correct answer, it iterates through loop from position 0 to last in rising order, first element of intArr - is assigned to i variable declared within brackets, each time iterates through a loop it assigns new value to this variable
Answer C:NOT CORRECT - It will not compile, you can not assign any value to a variable declared within an enhanced loop except objects you are going to iterate through (ArrayList or array) NOT int i =0 - it is not allowed here not compile
Answer D:NOT CORRECT - it will print actual value of variable i declared inside for loop expression , start at 0 then 1 2 3 4  - which is the last one does not print elements of an array  
Answer E: CORRECT - variable i initially declared i=0 is assign to index of an array (intArr[0]) and each time through iteration changes its value i=i+1; (i++;), everytime changed i value is assigned to array[index], and because indexing of an array is always equal to array.length-1, everything works 
Answer F:NOT CORRECT - declaration of for loop  - within () brackets is not correct, because i variable is not initialized - which is required - It will not compile at all, but it would compile if
int i=0;
for(;i<intArr.length;i++)
or int i;
for(i=0;i<intArr.length;i++)



 
Question 32
 
 
Answer A: CORRECT - it compiles successfully, even if the value of int a inside a() method is not initialized because a variable is not used anywhere at all in this case - so it does not do anything 
Answer B:NOT CORRECT - this class definition will not compile at all, because inside method doStuff() definition is variable int x = 0; declared with access modifier private - which is not allowed inside method body
Answer C:NOT CORRECT -  this is not correct , because package statement should be the at first line of the code (there is one exception to this rule - comments can be before package statement)
Answer D:NOT CORRECT -  because only class A compiles successfully
Answer E:NOT CORRECT - because only class A compiles successfully
Answer F:NOT CORRECT - because only class A compiles successfully

 
Question 33
  
Answer A: NOT CORRECT - enhanced loop does not allow to process elements in reverse  or custom( diffrent) order
Answer B: CORRECT - standard for loop allows to process all elements from array or ArrayList in required order (custom) - you can modify code to allow diffrent order, customize to your requirements
Answer C: NOT CORRECT - it is possible to achieve required order by modyfing standard for loop 
Answer D: CORRECT - enhanced loop allows to iterate through array or ArrayList elements in order of entry (because iterator is hidden, not available, and it can not be manipulated anyhow)
Answer E:  NOT CORRECT - Third requirement is possible to be achieved by using standard for loop but not by using  enhanced loop

 
Question 34
 
Answer A: CORRECT - calling method doCalc(200) inside another method System.in.println()
causing that value given as a method argument will be modified inside doCalc() method and new value will be returned and printed,  int var1 =200 declared in a class remains the same (value is not changed after calling method) because Java pass by value -  variables of non-primitive types are references in Java. When you pass such a value to a method, you're passing a reference by value - the reference is copied, but not the object that the reference refers to. Passing a reference by value is not the same as passing by reference. So original value remains the same.
Answer B: NOT CORRECT - calling doCalc(200) will return 400, because initial value is changed and returns changed value
Answer C: NOT CORRECT - as above , calling doCalc(200) does not change initial value of var = 200; which remains the same
Answer D: NOT CORRECT - code will compile and runs successfully

 
Question 35
Given the following class declarations:
-	public abstract class Animal
-	public interface Hunter
-	public class Cat extends Animal implements Hunter
-	public class Tiger extends Cat
Which answer fails to compile?

A.	Arraylist<Animal> myList = new ArrayList<>();
myList.add(new Tiger());
B.	Arraylist<Hunter> myList = new ArrayList<>();
myList.add(new Cat());
C.	Arraylist<Hunter> myList = new ArrayList<>();
myList.add(new Tiger());
D.	Arraylist<Tiger> myList = new ArrayList<>();
myList.add(new Cat ());
E.	Arraylist<Animal> myList = new ArrayList<>();
myList.add(new Cat ());

Answer = D


Answer A: NOT CORRECT - the code will compile, Tiger object is an Animal, because Tiger extends class Cat which extends Animal (inheritance)

Answer B: NOT CORRECT - the code will compile, Cat object is a Hunter, because class Cat implements interface Hunter(inheritance)

Answer C: NOT CORRECT - the code will compile, Tiger object is a Hunter, Tiger extends class Cat which implements interface Hunter (inheritance)

Answer D:  CORRECT - the code will not compile, Cat object is not part of Tiger class (because class Tiger is narrower to class Cat), Cat is not a Tiger, but Tiger is a Cat

Answer E: NOT CORRECT - it will compile, Cat object is an Animal, because Cat class extends Animal (inheritance)




 
Question 36:

Which statement is true about Java byte code?

A.	It can run on any platform.
B.	It can run on any platform only if it was compiled for that platform.
C.	It can run on any platform that has the Java Runtime Environment.
D.	It can run on any platform that has a Java compiler.
E.	It can run on any platform only if that platform has both the Java Runtime Environment and a Java compiler.
Answer is C

A.	Ambiguous: Java byte code is run on a Java Virtual Machine which can be installed on any platform, but there are more specific answers so this is WRONG
B.	Wrong: Java doesn’t need to be compiled for a specific platform. It is WORA – Write Once, Run Anywhere.
C.	Correct: The JVM is part of the Java Runtime Environment.
D.	Wrong: Written code is turned into Byte code by the compiler. The compiler doesn’t run the code. The Java Virtual Machine does.
E.	Wrong: A compiler need not be present for Java to run in the Java Virtual Machine which is part of the Java Runtime Environment.

 
Question 37:
public class MarkList {
int num;
public static void graceMarks (MarkList obj4) {
	obj4.num  += 10;
}
public static void main (String args[]) {
MarkList obj1 = new MarkList();
MarkList obj2 = obj1;
MarkList obj3 = null;
obj.num = 60;
graceMarks(obj2);

How many MarkList instances are created in memory at runtime?
A.	1
B.	2
C.	3
D.	4
Answer is A. 1
Easiest way to find out how many objects are created is to count how many times the “new” keyword is used, and here it is used only once. So only one object is created. Null is not an object as null DOES NOT extend the Object class.

 
Question 38:
Given:
public class Triangle {
	
	static double area;
	int b = 2, h = 3;
		
		public static void main(String [] args){
			double p, b, h;				//line n1
			if ( area == 0) {
				b = 3;
				h = 4;
				p = 0.5;
			}
			area = p * b * h;			//line n2
			System.out.println("Area is "+ area);
		}

}

What is the result?

A.	Area is 6.0
B.	Area is 3.0
C.	Compilation fails at line n1
D.	Compilation fails at line n2

Answer: D
It is true that static double area declaration will produce a value of 0, however the methods, when compiled are not aware of the value of variables outside of they’re body. So it does not KNOW the value of area when you attempt to compile the code, so area COULD be some other value than 0, and if it could, that means that b,h and p would not be given any intial value, which would lead to a compilation error in line n2.


 
Question 39:

public class Test {
	
	public static void main(String [] args){
		
		//line n1

		switch (x){
		
		case 1:
			System.out.println("One");
			break;
			
		case 2:
			System.out.println("Two");
			break;
		}
	}

}
Which three code fragments can be independently inserted at line n1 to enable the code to print one?
A.	Byte x = 1;
B.	short x = 1;
C.	String x = “1”;
D.	Long x = 1;
E.	Double x = 1;
F.	Integer x = new Integer(“1”);

Answers: A, B and F
Case statements can only take whole numbers (but not long) and they’re wrapper equal and strings. However option C would not work here as we would also have to change our case statement to 
Case “1”
 
Question 40:
public class App {
	
	public static void main(String args[]){
		
		Boolean[] bool = new Boolean[2];
		
		bool[0] = new Boolean(Boolean.parseBoolean("true"));
		bool[1] = new Boolean(null);
		
		System.out.println(bool[0] + " "+ bool[1]);
	}

}
What is the result?

A.	true false
B.	true null
C.	Compilation fails
D.	A NullPointerException is thrown at runtime.

Answer: A
This is an array of Boolean Wrapper objects. The class Boolean has a constructor that will take a string, and if it is anything other that the word “true” it will return “false”. The statement
bool[0] = new Boolean(Boolean.parseBoolean("true"));
creates a new Boolean wrapper object and uses the static parseBoolean() method to take the word “true” and converts it to a Boolean. It becomes the first element of the Array of Boolean wrapper objects called bool.
The line
bool[1] = new Boolean(null);
creates a Boolean wrapper that uses the constructor, in the Boolean class that can take an Boolean OBJECT, any method that takes an object can be sent the value NULL. when we pass a null to this constructor it will always return FALSE. It becomes the second element of the array of Boolean wrapper objects called Bool
 
Question 41
Given the following code for the classes MyException and Test
public class MyException extends RuntimeException {}
	public static void main (String [] args) {
		try {
			method1();
		}
		catch (MyException ne) {
			System.out.print(“A”);
		}
	}
	public static void method1()  // line n1
		try {
		throw Math.random() > 0.5 ?new MyException () : new RuntimeException();
	}
	catch (RuntimeException re) {
		System.out.print(“B”);
	}
      }
}

What is the result? 
A. A
B. B
C. Either A or B
D. AB
E. A compile time error occurs at line n1

Answer:    = B. B
Explanation

B. B
Because the custom exception class MyException extends RuntimeException. A RuntimeException will be thrown by method1() no matter what number is produced but will be caught by the try catch block so the output answer will be B. 
 
Question 42
Given: 

public class App {
String myStr = “7007”;
	public void doStuff(String str) {
		int myNum = 0;
		try {
			String myStr = str;
			myNum = integer.parseInt (myStr);
		}   catch (NumberFormatException ne) {
			System.err.println(“Error”);
		}
		System.out.println (
			“myStr: “ + myStr + “, myNum: “ + myNum)
	}
	public static void main(String[] args) {
		App obj = new App();
Obj.doStuff (“9009”);
	}
}

What is the result?
A. myStr: 9009, myNum 9009
B. myStr: 7007, myNum 7007
C. myStr: 7007, myNum 9009
D. Compilation fails

Answer  =   C. myStr: 7007, myNum 9009
Explanation 
C. myStr: 7007, myNum 9009 
The myStr variable “String myStr = str;” on line 8 only declares the myStr variable LOCAL to the try block to be “9009”. Once outside the try block the myStr variable still refers to the original String “7007”. The String “9009” passed to the doStuff method will be converted to an Integer value and assigned to int myNum.
So in the print statement the myStr refers to the original value “7007” and myNum has been reassigned to “9009”.
 
Question 43
What two are the benefits of polymorphism? 
A. Faster code at runtime
B. More efficient code at runtime
C. More dynamic code at runtime
D. More flexible and reusable code
E. Code that is protected from extension by other classes 

Correct Answers: = C and D

Explanations 
A. Faster code at runtime
Code is not faster at runtime with polymorphism

B. More efficient code at runtime
This option is a bit ambiguous because it is not clear which efficiency is it talking about - execution, memory, or maintenance. Our guess is that it is referring to execution efficiency. It is not true because polymorphism causes a very slight degradation due to dynamic binding at run time.

C. More dynamic code at runtime
Polymorphism allows the actual decision of which method is to be invoked to be taken at runtime based on the actual class of object. This is dynamic binding and makes the code more dynamic.

D. More flexible and reusable code
The code is more flexible and can be reused easily

E. Code that is protected from extension by other classes 
Just the reverse is true. Extension is how polymorphism is achieved.

 
Question 44
Given the code fragment

int nums1[] = new int [3];
int nums2[] = {1, 2, 3, 4, 5};
nums1 = nums2;
for (int x : nums1) {
	System.out.print(x + “:”);
}


What is the result?
A. 1:2:3:4:5:
B. 1:2:3
C. COMPILATION FAILS
D. An ArrayOutOfBoundsException is thrown at runtime

Answer =  A
Explanation
A. 1:2:3:4:5:
Line 3 assigns the nums2 array to the nums1 reference to the enhanced for loop iterates though the nums2 array and prints out each element with a “:” after each one. So option A is the output.

 
Question 45
Given:

public class Product {
	int id;
	String name;
	public Product (int id, String name) {
		this.id = id;
		this.name = name;
	}
}

And given the code fragment:
	4. Product p1 = new Product (101, “pen”);
5. Product p2 = new Product (101, “pen”);  
6. Product p3 = p1;
7. boolean ans1 = p1 == p2; 
8. boolean ans2 = p1.name.equals(p2.name);
9. system.out.ptrint(ans1 + “:” + ans2);

What is the result?
A. true:true:
B. true:false
C. false:true
D. false:false

Answer = C false:true
Explanation

C. false:true
As p1 and p2 are two different objects p1 == p2 is false, as they are separate objects. So when ans1 is assigned to (p1==p2), ans1=false.
As ans2 value uses the .equals method to see if the object variables stored in p1 and p2 are the same. As both have the value of “Pen” the answer is true. So ans2 = true.  This means the output is false:true
 
Question 46
Given the following classes:
public class Employee {
	public  int salary;
}
public class Manager extends Employee {
	public int budget;
}
public class Director extends Manager {
	public int stockOptions;


And given the following method
public static void main (String[] args) {
	Employee employee = new Employee ();
Manager manager = new Manager();
Director director = new Director();
// line 1
}
}//Director class ends here, this class contains the main() method which is fine
Which two options fail to compile when placed at line 1 on the main method?
A. employee.salary = 50_000;
B. director.salary = 80_000;
C. employee.budget = 200_000;
D. manager.budget = 1_000_000;
E. manager.stockOption = 500;
F. director.stockOption = 1_000;

Answer = C and E
Explanations 
A. employee.salary = 50_000;
Salary is a variable of class Employee so there is no problem
B. director.salary = 80_000;
Director is a subclass of Manager which is a subclass of Employee so it can access the salary field.
C. employee.budget = 200_000;
The employee object cannot access the budget field as it is declared in the class Manager. Compilation error.
D. manager.budget = 1_000_000;
Budget is a variable of class Manager so this compiles without problem.
E. manager.stockOption = 500;
The manager object has no stockOption variable and cannot access it from the subclass so Compilation Error.
F. director.stockOption = 1_000;
StockOption is a variable of class Director So there is no problem here.
 
Question 47
Given the following

class Product {
	double price; 
}
public class Test {
	public void updatePrice (Product product, double price)
		price = price * 2;
		product.price = product.price + price;
                   }
         	public static void main (String[] args) {
	Product prt = new Product();
	prt.price = 200;
	double newPrice = 100;
	
	Test t = new Test();
	t.updatePrice(prt, newPrice);                //  LINE 20
	System.out.println(prt.price + “ : ” + newPrice);  
	}
}

What is the result?
A. 200.0 : 100.0
B. 400.0 : 200.0
C. 400.0 : 100.0
D. Compilation fails

Answer = C

Explanation
C. 400.0 : 100.0
This tests the “pass by value” concept of Java. Line 20 passes the object reference “prt” as well as the variable “newPrice” to the updatePrice method. This method multiplies the value of newPrice by 2, this value is then added to the price variable of the “prt” object and the price variable is reassigned to this new value (400.0).
The sysout then outputs the “price” variable of the prt object which has been made the new value of 400.0, along with the “newprice” variable which has not been changed and remains 100.0. 
 
Question 48
Given the code fragment:

If (aVar++ < 10)  {
	System.out.println(aVar + “ Hello world! ”);
} else {
	System.out.println(aVar + “ Hello universe! ”);
}

What is the result if the integer aVar is 9?
A. 10 Hello World!
B. Hello Universe!
C. Hello world 
D. Compilation fails

Answer: = A

A. 10 Hello World!
As the “++” operator is placed after variable aVar, the value will be incremented by 1 after the expression is evaluated. So the if condition uses the value 9 and is evaluated as true. But the increment takes effect after so the output for the aVar is the new value of 10, this is followed by the String “ Hello World!”.

B. Hello Universe!
The else condition is not entered because the if evaluated to true.

C. Hello world! 
The sysout contains the aVar variable before the String so that would also need to be printed.

D. Compilation fails
The compilation does not fail
 
Question 49
Given the following:

public static void main (String[] args) {
	String date = LocalDate
			.parse (“2014-05-04”)
			.format (DateTimeFormatter.ISO_DATE_TIME);
	System.out.println(date);
}

What is the result?
A. May 04, 2014 T00: 00: 00.000
B. 2014-05-04T00: 00: 00.000
C. 5/4 / 14T00: 00: 00.000
D. An exception is thrown at runtime.
Answer  =  D
Explanation
D. An exception is thrown at runtime
an exception is thrown at runtime. UnsupportedTemporalTypeException is thrown if you attempt use the ISO_DATE_TIME formatter on a LocalDate (i.e. without a time).
 
Question 50 
Given the code fragment:

public static void main (String[] args) {
	Short s1 =200;
	Integer s2 = 400;
	Long s3 = (long) s1 + s2;              //line n1
	String s4 = (String) (s3 * s2);     //line n2
	System.out.println(“Sum is  ” + s4);
}

What is the result?
A. Sum is 600
B. Compilation fails at line n1
C. Compilation fails at line n2
D. A ClassCastException is thrown at line n1
E. A ClassCastException is thrown at line n2

Answer = C

Explanations
C is the correct Answer
If you are trying to cast from one class to another and if there is no relationship between the classes, then the code will not compile. There is no relationship between a String class object and a Integer or Short wrapper object, so the code will not compile
D. A ClassCastException is thrown at line n1
This is not the case because s1 is a Short which can be cast to a long and the value is unboxed without problem. And the s2 Integer is automatically unboxed to an int which can be added to a long.
E. A ClassCastException is thrown at line n2
E is incorrect as the code will not compile, so no runtime exception can be generated if the code does nto compile



 
Question 51
What is the name of the Java concept that uses access modifiers to protect variables and hide them within a class?
A.	Encapsulation
B.	Inheritance
C.	Abstraction
D.	Instantiation
E.	Polymorphism

Answer A - CORRECT Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as data hiding.
To achieve encapsulation in Java −
•	Declare the variables of a class as private.
•	Provide public setter and getter methods to modify and view the variables values
Answer B. NOT CORRECT. Inheritance can be defined as the process where one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order.
The class which inherits the properties of other is known as subclass (derived class, child class) and the class whose properties are inherited is known as superclass (base class, parent class).
Answer C. NOT CORRECT.Abstraction is a process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words, the user will have the information on what the object does instead of how it does it.
In Java, abstraction is achieved using Abstract classes and interfaces.
Abstract Class
A class which contains the abstract keyword in its declaration is known as abstract class.
Abstract classes may or may not contain abstract methods, i.e., methods without body ( public void get(); )
But, if a class has at least one abstract method, then the class must be declared abstract.
If a class is declared abstract, it cannot be instantiated.
To use an abstract class, you have to inherit it from another class, provide implementations to the abstract methods in it.
If you inherit an abstract class, you have to provide implementations to all the abstract methods in it.
Answer D - NOT CORRECT. Instantiation  - universal and straightforward concept in Java programming: creating new instances of objects to be used in a program. Keyword new.
Answer E. NOT CORRECT.Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.
Any Java object that can pass more than one IS-A test is considered to be polymorphic. In Java, all Java objects are polymorphic since any object will pass the IS-A test for their own type and for the class Object.
It is important to know that the only possible way to access an object is through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.
The reference variable can be reassigned to other objects provided that it is not declared final. The type of the reference variable would determine the methods that it can invoke on the object.
A reference variable can refer to any object of its declared type or any subtype of its declared type. A reference variable can be declared as a class or interface type.

 
Question 52
Given the code fragment:
abstract class Planet{
	protected void revolve() {               //line 1
	}

	abstract void rotate();                     //line 2
}

class Earth extends Planet {
	void revolve() {                                //line 3
}

protected void rotate() {
}
}

Which two modifications, made independently, enable the code to compile?

A.	Make the method at line n1 public
B.	Make the method at line n2 public
C.	Make the method at line n3 public
D.	Make the method at line n3 protected
E.	Make the method at line n4 public

Answer = C & D

If we are overriding a method in a base class the overriding method cannot be ANY LESS AVAILABLE. So our method 
Protected void revolve(){}
Any class that overrides this method cannot be any less accessible, so a void revolve(){} would not work as this is default leve access which is less avaialbe than the base class method.
Answer A. NOT CORRECT - modifying this line will not make any difference

Answer B. NOT CORRECT - modifying this line will not make any difference

Answer C. CORRECT - modifying by changing access modifier to public will allow the code to compile - it overrides method revolve() from class planet - Overriding means keeping the access level the same or wider - never weaker

Answer D. CORRECT - modifying by changing access modifier to protected will allow the code to compile - it overrides method revolve () from class planet - Overriding means keeping the access level the same or wider - never weaker

Answer E. NOT CORRECT - modifying this line will not make any difference, because access level modifier is wider than is superclass (default level access) which is allowed

 
Question 53
class Vehicle {
	String type = “4W”;
	int maxSpeed = 100;

	Vehicle(String type, int maxSpeed)  {
		this.type = type;
		this.maxSpeed = maxSpeed;
	}
}
class Car extends Vehicle {
	String trans;

Car(String trans) {                              //line n1
	this.trans = trans;
}
Car(String type, int maxSpeed, String trans) {
	super(type, maxSpeed);
	this(trans);                     //line n2
}
}

And given the code fragment:
7.  Car c1 = new Car (“Auto”);
8.  Car c2 = new Car (“4W”, 150, “Manual”);
9.  System.out.println(c1.type + “ “ + c1.maxSpeed + “ “ + c1.trans); 
10. System.out.println(c1.type + “ “ + c1.maxSpeed + “ “ + c1.trans);

What is the result? 
A.	4W 100 Auto
B.	4W 150 Manual
C.	Null 0 Auto
4W 150 Auto
D.	Compilation fails only at line n1
E.	Compilation fails only at line n2
F.	Compilation fails at both line n1 and line n2

Answer = F
Answer A. NOT CORRECT - code will not compile, so it will not print anything

Answer B. NOT CORRECT - code will not compile, so it will not print anything

Answer C. NOT CORRECT - this answer would be correct, but there is one more problem in the code, so this is not the correct answer

Answer D. NOT CORRECT - this answer would be correct, but there is one more problem in the code, so this is not the correct answer

Answer E. NOT CORRECT - this answer would be correct, but there is one more problem in the code, so this is not the correct answer

Answer F. CORRECT - there are two lines of code which does not allow the code to compile:
line n1 -  Car Constructor contains (not visible, hidden) call to a default (no argument constructor) from class Vehicle - it does not exist in this class, missing
line n2 - another Car constructor which contains two calls - one to superclass constructor, one to own class constructor - call statement to another constructor should be the first line  within constructor, calling two constructors at the same time not possible

 
Question 54
1.   class X {
2.   public void printFileContent(){
3.   /* code goes here*/
4.   throw new IOException();
5.   }
6.   }
7.   public class Test{
8.   public static void main(String[] args){
9.    X xobj = new X();
10.   xobj.printFileContent();
11.   }
12.   }
Which two modifications should you make so that the code compiles successfully?
• A)Replace line 8 with public static void main(String args[]) throws Exception {
• B) Replace line 10 with:
try{
xobj.printFileContent();
}
catch(Exception e){}
catch(IOException e){}
• C) Replace line 2 with public void printFileContent() throw IOException {
• D) Replace line 4 with throw IOException ("Exception raised");
• E) At line 11, insert throw new Exception();
Answer A. CORRECT - calling method printFileContent() which throws an exception (which is a checked exception) requires enclosing call statement with try/catch block or throws clause in a method which calls this method (in this case is public static  void main(String args[]))
Answer B. NOT CORRECT  - Order of catch statements are wrong  - first place should be catch(IOException e) then following by catch (Exception e), because IOException is a subclass of class Exception
Answer C. CORRECT  - if method throws checked exception then it is required that method definition contain THROWS clause (which is missing in this case)
Answer D.NOT CORRECT   - throw clause should contain new keywrd , which iss missing here
Answer E.NOT CORRECT   - it would make the code not to compile -unnecessary statement, because the method printFileContent already throws an exception

 
Question 55
public class Customer{
ElectricAccount acct = new ElectricAccount();
public void useElectricity(double kWh){
acct.addKWh(kWh);
}
}
public class ElectricAccount{
private double kWh;
private double rate = 0.07;
private double bill;
//line n1
}
How should you write methods in the ElectricAccount class at line n1 so the member variable bill is always equal to the value of the member variable kWh multiplied by the member  variable rate? Any amount of electricity used by a customer (represented by an instance  of the customer class) must contribute to the customer's  bill (represented by the member variable bill) through the method useElectricity method.
An instance of the customer class should never be able to tamper with or decrease the value of the member variable bill.


A) public void addKWh(double kWh){
this.kWh +=kWh;
this.bill = this.kWh*this.rate;
}
B) public void addKWh(double kWh){
if (kWh>0){
this.kWh +=kWh;
this.bill = this.kWh*this.rate;
}
}
C) private void addKWh(double kWh){
if (kWh>0){
this.kWh +=kWh;
this.bill = this.kWh*this.rate;
}
}

D) public void addKWh(double kWh){
if (kWh>0){
this.kWh +=kWh;
setbill (this.kWh);
}
}
public void setBill(double kWh){
bill = kWh*rate;
}
Answer A. NOT CORRECT - 
Answer B. CORRECT  - 
Answer C.NOT CORRECT  - 
Answer D.NOT CORRECT  
NOT SURE about correct answer, but there is a similiar question in Ethnuware (but diffrent named data) Look !!!! TEST 3, Question 77

 
Question 56
Person.java;
public class Person{
String name;
int age;
public Person(String n,int a){
name=n;
age = a;
}
public String getName(){
return name;
}
public int getAge(){
return age;
}
Test.java;
public static void checkAge(List<person> list, Predicate<Person> predicate){
for (Person p:list){
if (predicate.test(p)){
System.out.println(p.name + " ");
}
}
}
public static void main(String[] args){
List<person> iList = Arrays.asList(new Person ("Hank", 45),
                                                                   new Person ("Charlie", 40),
                                                                   new Person ("Smith", 38));

// line n1
}
Which code fragment , when inserted at line n1, enables the code to print Hank?
A. checkAge(iList, () -> p.getAge()>40);
B.  checkAge(iList, Person p -> p.getAge()>40);
C. checkAge(iList, p -> p.getAge()>40);
D. checkAge(iList, (Person p) -> {p.getAge()>40;});
Predicate contains a method test() which takes a object and returns a boolean, so we are looking for a lambda that provides direct implementation for this.
Answer A. NOT CORRECT checkAge(iList,()->p.get Age()>40); marked (red) brackets suggest that 
abstract method from interface does not return any value (void method), which is not correct
Answer B. NOT CORRECT - checkAge(iList,Person p->p.get Age()>40); 
when a parameter type is declared (optional) should be enclosed within brackets (Person p)
Answer C. CORRECT  - 
Answer D.NOT CORRECT  - checkAge(iList,(Person p)->{p.get Age()>40;}); 
Curly brackets not allowed here, because expression body does not  contain return keyword
Optional curly braces − No need to use curly braces in expression body if the body contains a single statement.
Optional return keyword − The compiler automatically returns the value if the body has a single expression to return the value. Curly braces are required to indicate that expression returns a value.
 
Question 57
public void main (string [] args){
String [][] arr={{"A","B","C"},{"D","E"}};
for (int i = 0; i<arr.length;i++){
for(int j=0; j<arr[i].length;j++){
System.out.print(arr[i][j] + " ");
if (arr[i][j].equals("B")){
break;
}
} 
continue;
}
What is he result?
This will print out all of the letters, even if that letter is B. what happens is that it breaks out of the INNER loop when the letter is B, BUT NOT before it prints out the letter B. When it gets to the letter B it breaks out of the inner loop, which means it never gets to C in that row. It then starts on the second row and prints out DE
The continue statement effiectivly is part of the outer loop and this does nothing as the loop has no code after this so the loop will exit its current iteration after the continue statement, but it would do this regardless of whether the continue statement was there or not.
Answer A.ABC - NOT CORRECT -

Answer B. ABCDE – Not Correct

Answer C.ABDE -Correct

Answer D. Compilation fails - NOT CORRECT

 
Question 58
Given the code fragment: 


public static void main (String[]  args){
	String str = " ";
	str.trim();
	System.out.println(str.equals(" ") + " " + str.isEmpty() );
}


What is the result?

A. true true

B. true false

C. false false

D. false true



Correct answer: B

Answer A. NOT CORRECT - 
Answer B. Correct
Str contains just a space, so str.trim only removes spaces before or after a character, so str.trim does not change the string str, it still contains a space “ “. So str.equals(“ “) will return TRUE
isEmpty() returns a boolean if there is nothing in our string, however str has a space in so it is NOT empty, so this will return FALSE
Answer C is incorrect
Answer D.NOT CORRECT
 
Question 59
Given: 

class CD {
     int r;
     CD(int r) {
             this.r = r;
     }
}
 class DVD extends CD {
       int c;
       DVD(int r, int c) {
              // line n1
       }
}

And given code fragment:

DVD dvd = new DVD(10, 20);

Which code fragment should you use at line n1 to instantiate the dvd object successfully?

A. super.r = r;
     this.c = c;

B. super(r);
    this(c);

C. super(r);
    this.c = c;

D. this.c = r;
     super(c);

Correct answer: C


In a sub class constructor there is always a call to a super class constructor. If there is none present in your code,there is an implicit call to a hidden default constructor that takes no arguments 
Super().

Answer A. Not Correct
There is one user created constructor in the super cd class that takes an int, that means there is NO constructor in the CD class that takes no arguments. In order for the constructor in the DVD class there has to be a call to the super class constructor that takes an int. However in this example there is only implicit call to the hidden default constructor that takes no arguments, which does not exist for the CD class, so this will not compile
Answer B.  Not Correct
Can’t have two calls to a constructor from inside a constructor, you can only have, at most, a call to one constructor from inside a constructor. 
Answer C. CORRECT - super(r); is a call to superclass constructor (required in this case, which takes one parameter - int r) - MUST BE the first line within a constructor. Then this.c = c; marks that argument int c from DVD constructor has the same value as reference variable from superclass constructor, gives superclass constructor value equals to int c. 
Answer D.NOT CORRECT
The call to another constructor from inside a constructor has to be the first line of code, here it is the second line of code.

 
Question 60
Given the code fragment: 


int a[ ] = { 1, 2, 3, 4, 5};
for (xxx) {
         System.out.print( a [ e ] );
}


Which option can replace xxx to enable the code to print 135?

A. int e = 0; e < = 4; e++

B. int e = 0; e < 5; e + = 2

C. int e = 1; e < = 5; e + = 1

E. int e = 1; e < 5; e+ =2


Correct answer B



Answer A. NOT CORRECT - 
Answer B. CORRECT - array index starts at position 0, so it requires that first printed argument (1) 
which is at position 0 iteration sholkd start from 0 (int e =0;), than jumps two places forward, what can be achieved by adding to argument e (initial position 0) 2 (e+=2), 
additionaly condition (e<5) will evaluate to true , because e can not be bigger than 4 (because size of an a[] array is 5, but indexing starts at 0 to 4 - not 1 to 5) 
Answer C. NOT CORRECT - 
Answer D.NOT CORRECT
 
Question 61
Which statement best describes encapsulation?

A. Encapsulation ensures that classes can be designed so that if a method has an 
     argument MyType x, any subclass of MyType can be passed to that method.

B. Encapsulation ensures that classes can be designed so that only certain fields and 
    methods of an object are accessible from other objects.

C. Encapsulation ensures that classes can be designed so that their methods are 
     inheritable.

D. Encapsulation ensures that classes can be designed with some fields and methods 
    declared as abstract.
Answer is B
"Encapsulation ensures that classes can be designed so that only certain fields and methods of object are accessible from other objects"

Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.
Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as data hiding.
To achieve encapsulation:
	- declare the variables of a class as private
	- provide public setter and getter methods to modify and view the variables values
The public set() and get() methods are the access points of the instance variables of the class.
Normally, these methods are called getters and setters.
Any class that wants to access the variables should access them through these getters and setters.
Benefits of Encapsulation:
	- the fields of a class can be made read-only or write-only.
	- class can have total control over what is stored in its fields.
	- users of a class do not know how the class stores its data. A class can change the data type 	   of a field and users of the class do not need to change any of their code.
Encapsulation has a number of advantages that increase the reusability, flexibility and maintainability of the code.
Flexibility: It is more flexible and easy to change the encapsulated code with new requirements. For example, if the requirement for setting the age of a person changes, we can easily update the logic in the setter method setAge().
Reusability: Encapsulated code can be reused throughout the application or across multiple applications. For example, the Person class can be reused whenever such type of object is required.  
Maintainability: Application code is encapsulated in separate units (classes, interfaces, methods, setters, getters, etc.) so it is easy to change or update a part of the application without affecting other parts, which reduces the time of maintenance.
Examples:
		class Person {
			//Fields:
    			private String name;	// declaring variables private 
   			private int age;

     			//Getters and Setters methods:
   			 public String getName() {	// providing getters and setters methods
      		  	     return name;
    			}
     			public String getAge() {
       		 	     return age;
 		              }
		}
Remember:
This is the process of hiding information. The other objects cannot access the data directly. Instead, they have to invoke the getters, which are designed to protect the data from misuse or unwanted changes.
 
Question 62
Given the code fragment from three files: 

	SalesMan.java:				//< ---  source file
	package sales;				//< --- package		
	public class SalesMan {  }		//< --- class inside the package sales
						//       (you can have only one public class per file !)
	Product.java:
	package sales.products;
	public class Product {  }
	
	Market.java:
1.	package market;
2.	// insert code here
3.	public class USMarket {
4.		SalesMan sm;			
5.		Product p;
6.	}


Which code fragment, when inserted at line 2, enables the code to compile?


A.	import sales.*;
B.	import java.sales.products.*;
C.	import sales;
	import sales.products;
D.	import sales.*;
	import products.*;
E.	import sales.*;
	import sales.products.*;

Answer E is correct and will allow code to compile.

A package in Java is an encapsulation mechanism that can be used to group related
classes, interfaces, enums, and subpackages.
A package hierarchy represents an organization of the Java classes and interfaces. It does
not represent the source code organization of the classes and interfaces. The source code is
of no consequence in this regard. Each Java source file (also called compilation unit) can
contain zero or more type declarations, but the compiler produces a separate class file
containing the Java bytecode for each of them. A type declaration can indicate that it's Java
bytecode should be placed in a particular package, using a package declaration.
A package statement have following syntax:
	package   fully_qualified_package_name;
At most one package declaration can appear in a source file, and it must be the first
statement in the source file. The package name is saved in the Java bytecode for the types
contained in the package. Java naming conventions recommend writing package names in
lowercase letters.
Examples:
	package sales; 
	package com.android;
	package sales.products;




Importing
The accessibility of types (classes, interfaces, and enums) in a package determines their
access from other packages. Given a reference type that is accessible from outside a
package, the reference type can be accessed in two ways. One way is to use the fully
qualified name of the type. The second way is to use the import declaration that provides a shorthand notation for specifying the name of the type.
The import declarations must be the first statement after any package declaration in a
source file.
import declaration has the following syntax:
	import  fully_qualified_package_name;
This is called single type import. As the name implies, such an import declaration provides a shorthand notation for a single type. The simple name of the type (that is, its
identifier) can now be used to access this particular type.
Given the import declaration:
	import java.util.ArrayList;
name ArrayList can be used in the source file to refer to this class.

Alternatively, the following form of the import declaration can be used:
	import fully_qualified_package_name.*;
This is called type-import-on-demand. It allows any type from the specified package to be
accessed by its simple name.
An import declaration does not recursively import subpackages. The declaration also
does not result in inclusion of the source code of the types; rather, it simply imports type
names (that is, it makes type names available to the code in a compilation unit).

Answer to question:
We have declare three files: SaleMan.java , Product.java and Market.java
You are in file Market.java , in the class USMarket. You want to use SalesMan to sell your Product, Both are in separate files and packages.
To use each one of them you  need to import packages which contain class SalesMan and class Product.
SalesMan are inside package sales ( notice is in different source file than Product)
Product are in package sales.products (different source file than SalesMan) 
At line 2 you should insert:
import sales.*;     - this will allow you to use all what is contain package sales ( SalesMan)
import sales.products.*;   - this allow you to use Product which is inside this package.

Answer E is correct and will allow code to compile.

Rest of answers are not correct because will not allow code to compile ( compiler will complain )
A. allow to use only SalesMan
B. will not allow import SaleMan or Product ( different package name )
C. not allow to import Product
D is incorrect as this will import all classes in the Sales package, which is correct. However import product.*; will not import any of the sub packages and the products class is in the sales.products package. 
Question 63
Which two will compile, and can be run successfully using the command: 
javac fred1.java
java fred1 hello walls

(Type: Multiple Response, Points: 10, Attempts: 1)
[  ]	 A
[  ]	 B
[+]	 C
[+]	 D

Feedback if correct: 	Correct answer: C, D






Option A: not correct. There is missing [ ]
Option B: not correct. Try to access position args[2] cause ArrayIndexOutOfBoundsException
Option C: CORRECT. Class will compile and run with output [L java.lang.String:<hash>
       We not accessing any element of the array Return is telling that’s Array of Strings
       with address. Similar to method getClass();
Option D: CORRECT. Class compile and run with output walls. Position args[1] is walls

Feedback if failed: 	Correct answer: C, D






Option A: not correct. There is missing [ ]
Option B: not correct. Try to access position args[2] cause ArrayIndexOutOfBoundsException
Option C: CORRECT. Class will compile and run with output [L java.lang.String:<hash>
       We not accessing any element of the array Return is telling that’s Array of Strings
       with address. Similar to method getClass();
Option D: CORRECT. Class compile and run with output walls. Position args[1] is walls

	
 
Question 64
Given the code fragment: 


	
	String shirts [][]  = new String [2][2];			//< -- declaring  array
	shirts [0][0] = "red";
	shirts [0][1] = "blue";
	shirts [1][0] = "small";
	shirts [1][1] = "medium";


Which code fragment prints  red: blue: small: medium: ?


A.	for (int index = 1; index < 2; index++){			//< --- this for loops will give us  
	       for(int idx =1; idx < 2; idx++){			//	result [1][1] = medium:
		System.out.print(shirts[index][idx] + ": " );	//	( not correct )*/
	       }
	}

B.	for (int index = 0; index < 2; ++index){			//< --- this for loops will give us  
	       for(int idx =1; idx < 2; ++idx){			//	result  [1][1] = medium:
		System.out.print(shirts[index][idx] + ": " );	//	( not correct )
	       }
	}

C.	for( String c : colors ){					//< --- this  loops will not compile
	      For( String s : sizes){					//	notice: colors and sizes
		System.out.println(s + ": " );			//	( not correct )
	       }
	}

D.	for (int index = 0; index < 2; ){	
	           for(int idx = 0; idx < 2; ){				//< --- CORRECT ANSWER
		      System.out.print(shirts[index][idx] + ": ");
			idx++;
		}
	        index++;
	}
		

Answer A : NOT CORRECT - It will print only "medium:", which is at position shirts[1][0] - index starts at 1 - which means that all row (shirts[0][0] ,shirts[0][0] ) will not be printed and is skipped, then loop enters the second row , but because iteration starts at 1 it means that small (shirts[1][0] ) is skipped as well and only medium will be printed , for both: index and idx condition statement checks that they must be less than 2 (index<2, idx<2) so after incrementation they not fulfill this condition anymore and  it exists the loop (condition evolves to false)

Answer B :  NOT CORRECT  -  it will print only "small:" iteration of the loop starts at index = 0, then enters inside loop when iteration starts at position 0 as well - condition idx<index evaluates to false(0<0), exits inside loop and comes back to outside loop, when index is incremented to 1, then enters again inside loop condition idx<index evaluates to true (0<1) and it prints "small:" (shirts[1][0]), then idx is incremented, inside loop condition idx<index evaluates to false - exits inside loop, then index is incremented (now is two) and outside condition statement evaluates to false - exits outside loop 
Answer C: NOT CORRECT - it will not compile at all, arrays: colors sizes are not defined in the code (do not exist, not declared) so iteration can not take place
Answer D :  CORRECT  -  each iterartion enters the loop at position (index = 0, idx = 0), and finishes when required condition is fulfilled - it will print red:blue:small:medium which is order all values	
when they were entered, increment both values takes place outside for statement but it is the same as :	for(int index = 0; index<2;index++)
	 for(int idx = 0; idx<2; idx++)
 
Question 65
Given the following code snippet.

public class Test{

void readCard(int cardNo) throws Exception {
         System.out.println(“Reading Card”);
}
Void checkCard(int cardNo) throws RuntimeException{  // line n1         System.out.println(“Checking Card”);
}
Public static void main(String[] args) {
            Test ex = new Test();
            int cardNo = 12344;
            ex.checkCard(cardNo);           //line n2
            ex.readCard(cardNo);             // line n3
}
}

What is the result?

A. Code prints “Reading Card”.
B. Code prints “Checking Card”
C. Compilation Fail at line n1.
D. Compilation Fail at line n2.
E. Compilation Fail at line n3.

Answer is E.

We are in class Test which contain two methods: readCard() and checkCard()
Method readCard() throws Exception and method checkCard() throws RuntimeException
In main method we creating object class Test ex.
We assign to int cardNo value 12344. Next, using reference of object class we calling method 
checkCard() and readCard() 
At this point : 	ex.readCard(cardNo);                    //line  n3
Compiler will complain because method throws Exception which is superclass of all Exception and is unhandled exception. In the code there is nothing to handle this Exception. If compiler will allow you to compile the code, program will crash.
 
Question 66
Given the code fragment: What is the result? 

	StringBuilder sb = new StringBuilder(5);
		String s = "";        

		if(sb.equals(s)) {
				System.out.println("Match 1");
		}
		else if (sb.toString().equals(s.toString())) {
				System.out.println("Match 2");
		}
		else {
			System.out.println("No Match");
		}

What is the result?

A. Match 1
B. Match 2
C. No Match
D. A NullPointerException is thrown at Runtime.

Answer B


The line 
              if (sb.equals(s))
Is checking if sb and s objects for equality. As they belong to different classes this can never return true.
The line
             if (sb.toString().equals(s.toString())) 
Checks the string values returned by the toString method used on these objects for equality.
As both of these Strings returned by the toString method will be empty Strings (“”) it returns true. So the output is “Match 2”.

 
Question 67
Given: Which statement is true?

	package p1;
	public  class Acc {
		int p ;                            //  < -- visible to the package default
		private int q ;	          // < --- - visible to the class only
		protected int r ;	         // < --- - visible to the package and all subclasses
		public int s ;	         // < --- visible to the world
	}

	Test. java
	package p2;
	import p1.Acc;
	public class Test extends Acc{
	
		public static void main(String[] args) {
			Acc obj = new Test();
				
	}

}

A. Both p and s are accessible by obj.	( not correct )

B. Only s is accessible by obj.		( Not correct )

C. Both r and s are accessible by obj.	( correct )

D. p, r, and s are accessible by obj.	( not correct )



The class Test extends Acc and Test imports this class which means that Test has access to all public variables and also all protected variables as the protected keyword means varaibles are available in derived classes regardless of whether they are in the same package or not.
Answer:
C
 
Question 68
Given:
class Base {
 
    public void test() {
        System.out.println("Base ");
    }
}

class DerivedA extends Base {
 
    public void test() {
        System.out.println("DerivedA");
    }
}

class DerivedB extends Base {
 
    public void test() {
        System.out.println("DerivedB");
    }
 
    public static void main() {
        Base b1 = new DerivedB();
        Base b2 = new DerivedA();
        Base b3 = new DerivedB();
        b1 = (Base) b3;
        Base b4 = (DerivedA) b3;
        b1.test();
        b4.test();
    }
}

What is the Result?

A. Base
     Derived A
B. Base 
     DerivedB
C. DerivedB 
     DerivedB
D. DerivedB
     DerivedA
E exception is generated
Answer is E
the line 
Base b4 = (DerivedA) b3;
Generates a classCastException as b3 is a DerivedB object and there is no relationship between this class and the DerivedA class, so you can’t cast this object to be of type DerivedA.


 
Question 69

public static void main(String[]  args){
	Arraylist myList = new ArrayList();               //  < --- creating ArrayList
	String[] myArray;			     //< --- declaring String Array		

	try{				
	            while( true ){			    // < ---  error ending story
		        myList.add("My String");
	             }
	}
	catch( RuntimeException re ){
		System.out.println( "Caught a RuntimeException" );
	}
	catch( Exception e ){
		System.out.println( "Caught a Exception" );
	}
	System.out.println( "Ready to use" );


What is the result?

A.	Execution terminates in the first catch statement, and caught a RuntimeException is 
	printed to the console.
B.	Execution terminates In the second catch statement, and caught an Exception is printed 
	to the console.
C.	A runtime error is thrown in the thread “main”.
D.	Execution completes normally, and Ready to use is printed to the console.
	The code fails to compile because a throws keyword is required.

We creating ArrayList called myList . In try block we have while loop, where condition is set to true
So will always executes.
Inside while loop we have method add(), which allow us to adding elements to our ArrayList called myList. We adding String to it. 
Because of not giving any exit condition to while loop, the procces adding String to myLIst will finish with error thrown in "main" 

Answer :
	
A is NOT CORRECT (  We never get that far and first catch statement is design to deal with 						RuntimeException not Errors)				
B Is NOT CORRECT ( similar like above  )

C is CORRECT	A runtime error is thrown in the thread "main".
		While loop is an infinite loop so the program ends with an OutOfMemoryError. 
		This error can’t be caught with Exception or RuntimeException.

D is NOT CORRECT ( First line never happens. Second line is NOT true because code compiles but at 					runtime we getting Error )
 
		
Question 70
Given:

System.out.println( "5 + 2 = " + 3 + 4 );
System.out.println( "5 + 2 = " + (3 + 4) );

What is the result?

A.  5 + 2 = 34	NOT CORRECT  ( first line is fine, but second line is not correct)
      5 + 2 = 34
B.  5 + 2 + 3 + 4     NOT CORRECT ( first line is not correct, second line is fine)
      5 + 2 = 7
C.   7 = 7	NOT CORRECT	( both lines are not correct)
      7 + 7
D.  5 + 2 = 34	CORRECT
      5 + 2 = 7 

Operand of + is a reference to a String object, the operator is the arithmetic addition operator, not the string concatenation operator.
Java does not allow a program to define overloaded operators. However, the language defines the + operator to have a meaning that is fundamentally different from arithmetic addition if at least one of its operands is a String object.

In first print statement "5 + 2 = " is  a String and everything after, Java will see like a String (not  + )
So 3 + 4 become 34 . Result  "5 + 2 = 34"
Second print statement is similar, but Java will first do operation in parentheses (3 + 4) become 7 and then to String "5 + 2 = " will add 7 which results : "5 + 2 = 7"

Answer D is correct
 
Question 71
	public static void ( String[]  args){
		String ta = "A ";			//< ---  declaring and giving value to string ta
		ta = ta.concat("B ");		//< --- after this line ta holds value "A B "
		String tb = "C ";			//< --- declaring and giving value to string tb
		ta = ta.concat(tb);		//< --- after this line ta have value "A B C "
		ta.replace('C', 'D');		//< --- important to notice at this line
		ta = ta.concat(tb);
		System.out.println(ta);		//< --- prints out new value of String ta
				

Method String class concat():
Allow you to combine two Strings.
A new String, one with new value appended is returned.
Method String class replace():
There are many forms of the replace() method. Here we use version that replaces one char value with another. This will change all characters with matching values, not only first one (important to remember). What exits is just temporary.
You declare String ta and you  give value "A "  
Using reference ta  and  concat() method you creating new value of string. It takes the initial string "A " and concats "B ". Concat adds to the end of it's appends. The result of String named ta contains now "A B ".
At next line you declare new String named tb with value "C ". Next method concat() and reference tb 
creates value "A B C " which is assign to reference ta.
At  line  ta.replace( 'C', 'D')  you replacing  character 'C' for new character 'D' which results with value "A B D". Notice here that new value is not assign to reference ta !!!
At next line you concat value of tb "C " to "A B C " and you assign to ta . Finally ta holds value A B C C
Answer:
A B C C

 
QUESTION 72.
 Given the code fragment:
3.public static void main(String[]args){
4.int x = 5;
5.		while(isAvailable(x)){
6.			System.out.print(x);
7.
8.		}
9.		
10.	}
11.public static boolean isAvailable(int x){
12.			return x-- > 0 ? true : false;
13.		}
Which modification enables the code to print 54321? 

 

A. Replace line 6 with System.out. print (--x) ;
B. At line 7, insert x --; 
C. Replace line 6 with --x; and, at line 7, insert
    System.out.print (x); 
D. Replace line 12 With return (x > 0) ? false: true;

Answer: B
While(isAvailable(x)) will always return true as the number 5 is always being sent to isAvailable method, so this will be an infinite loop. If we decrement x each time we send it to the isAvailable method, x will decrement by 1 each time its sent to the method, and will print out 54321


 
QUESTION 73.
 Given the code fragment:
4.public static void main(String[]args){
5.Boolean opt = true;
6.    	  switch(opt){
7.    	  case true:
8.    		  System.out.println("True");
9.    		  break;
10.    	  default:
11.    			  System.out.println("xxx");
12.    	  }
13.    	  System.out.println("Done");
14.      }¬
Which modification enables the code fragment to print TrueDone? 
 
A. Replace line 5 With String result = "true"; Replace line 7 with case "true":
 B. Replace line 5 with boolean opt = l; Replace line 7 with case 1= 
C. At line 9, remove the break statement. 
D. Remove the default section.

Answer: A 
Explanation: Switch statements with String cases were implemented in Java SE 7.

 
QUESTION 74.
 Given the following main method:

public static void main(String[]args){
    	  int num = 5;
    	  do{
    		  System.out.println(num-- +" ");
    	  }
    	  while(num==0);
    	  }

What is the result? 
 
A. 5 4 3 2 1 0 
B. 5 4 3 2 1 
C. 4 2 1 
D. 5 
E. Nothing is printed

Answer: D 
Explanation: The loop body executes only once because on the while condition num = 4. When the execution reaches System.out.print, num = 5.
 
QUESTION 75.
 Given the code fragment: 
         int x = 100;
    	  int a =x++;
    	  int b = ++x;
    	  int c = x++;
  int d = (a<b) ? (a<c) ? a: (b<c)? b: c;
    	  System.out.println(d);
What is the result? 
 
A. 100
B. 101 
C. 102 
D. 103 
E. Compilation fails ¬
 
Answer: E
Explanation: Compilation fails with error ": expected" because we have three ternary operators but only two colons. 
Int d =(a<b) ? (a<c), a<c evaluates to true or false and this we attempt to assign this to d, you can’t assign a Boolean to a int.


 
QUESTION 76.
 Given:
String[][] chs = new String[2][];
    	  chs[0] = new String[2];
    	  chs[1] = new String[5];
    	  int i = 97;
    	  
    	  for (int a = 0; a < chs.length; a++){
    		  for(int b = 0; b < chs.length; b++){
    			  chs[a][b] = ""+i;
    			  i++;
    		  }
    	  }
    	  for (String[] ca : chs){
    		  for (String c : ca){
    			  System.out.println(c + "");
    		  }
    		  System.out.println();
    	  }
What is the result? 
A. 97 98 99 100 null null null 
B. 91 98 99 100 101 102 103 
C. Compilation rails. 
D. A NullPointerException is thrown at runtime. 
E. An ArraylndexOutOfBoundsException is thrown at runtime. 
 
Answer: A 
When we go chs.length we are referring the the first dimensiona of the array (the amount of rows) which is 2. So chs.length means the outer and inner loop will be go 2 times. 
This is an array of two rows, one row has two columns, the second row has five columns. Only 4 strings are inserted into the array, which leaves us with 3 null values occupying the remaining array positions. When you create an array of strings, and you don’t insert any explicit string values, each postion in that array has the value of null. As the last three positions in the array are never given explicit values they will have null values in those positions.
Explanation: When we exit first loop we have chs[0][0] = 97 chs[0][1] = 98 chs[1][0] = 99 chs[1][1] = 100 chs[1][2] = null; chs[1][3] = null; chs[1][4] = null; The second loop prints these values.


 
 QUESTION 77.
 Given the code fragment:
class Employee {
    		  String name;
    		  boolean contract;
    		  double salary;
    		  Employee(){
    			// line n1.
    		  }
    		  public String toString(){
    			  return name + ":" + contract + ":" + salary;
    		  }
             public static void main(String[] args) {
    		  Employee e = new Employee();
    		      // line n2.
    		  System.out.print(e);
    		  
    	  }
Which two modifications, when made independently, enable the code to print joe:true: 100.0?
A.	Replace line n2 with:  e.name = “Joe”;
                                                            e.contract = true;
                                                            e.salary = 100;
    B. Replace line n2 with:  this.name = “Joe”;
                                                                        this.contract = true;
                                                                        this.salary = 100;
    C. Replace line n1 with: this.name = new String(“Joe”);
                                                                       this.contract = new Boolean(true);
                                                                       this.salary=new Double(100);
    D. Replace line n1 with: name = “Joe”;
                                                                       Contract =TRUE;
                                                                       Salary=100.0f;
      E. Replace line n1 with: this(“Joe”, true, 100);

 Answer. A and C

 
QUESTION 78.
 View the exhibit:

 class Student {
       public String name = "";
       public int age = 0;
    	public String major = "Undiclared";
       public boolean fulltime = true;
    	public void display(){    System.out.println("Name:" + name + "Major: " + major );}
    		  public boolean isFullname(){
    			  return fulltime;
    		  }

Which line of code initializes a student instance? 
 
A. Student student1; 
B. Student student1 = Student.new();
C. Student student1 = new Student();
D. Student student1 = Student();

Answer: C
 
QUESTION 79.

 What should keyword 1 and keyword 2 be respectively, in order to produce output 2345? 

int [] array = {1,2,3,4,5};
    	  for (int i: array) { 
    		  if ( i < 2) {
    			  keyword 1
    			  } 
    		  System.out.println(i); 
    		  if ( i == 3) { 
    			  keyword 2
    			  }}

A. continue, break 
B. break, break 
C. break, continue 
D. continue, continue 
 
Answer: D
Any answer with a break in it is wrong as if we have a break where we have keyword1 it would print nothing, as i at start is <2. If we have a break at keyword2, the numbering displayed cannot go beyond 3
 
QUESTION 80.

Given.


int i, j=0;
    	  i = (3* 2 +4 +5 ) ;
    	  j = (3 * ((2+4) + 5));
     System.out.println("i:"+ i + "\nj"+j); 
    	  

 What is the result?
\n puts everything after it on a new line


Answer is B, but j:33 will be on a new line
A. i:16 j:33
B. i: 15 j:33
C. i: 33 j:23
D i: 15 j:23

 
QUESTION 81:
What is the result?
boolean log3 = (5.0 != 6.0) && (4 != 5);
boolean log4 = (4 != 4) || (4 == 4);
System.out.println("log3:" + log3 + "\nlog4" + log4);

A.log3:false
  log4:true

B.log3:true 
    log4:true

C.log3:true
  log4:false

D.log3:false
  log4:false

ANSWER: B
Explanation:
“!=” Is the “not equal to” operator.
“&&” is the short circuit AND operator
“||” is the short circuit OR operator
The “\n” in a String in a print statement is just a way to start printing on a new line.
Breakdown:
Log3 = (5.0! = 6.0) && (4! = 5) 
      = true && (4! = 5)
      = true && true 
      = true
Log4 = (4! = 4) || (4 == 4) 
     = false || (4 == 4) 
     = false || true 
     = true


 
QUESTION 82:
Which statement will empty the contents of a StringBuilder variable names sb?
A.	sb.deleteAll();	
B.	sb.delete(0, sb.size());
C.	sb.delete(0, sb.length());
D.	sb.removeAll();
ANSWER: C
Explanation:
A: StringBuilder does not have a deleteAll() method.
B: StringBuilder’s delete() method can delete a range of characters. But StringBuilder does not have a size() method. To obtain the length of the string, you must use the StringBuilder’s length() method.
C: This is the correct way to empty the contents of a StringBuilder.
D: StringBuilder does not have a removeAll() method.

 
QUESTION 83:
Given:
class StaticField {
    static int i = 7;
    public static void main(String[] args) {
        StaticField obj = new StaticField();
        obj.i++;
        StaticField.i++;
        obj.i++;
        System.out.println(StaticField.i + " " + obj.i);
    }
}

What is the result?
A.
10 10
B.
8 9
C.
9 8
D.
7 10
ANSWER: A
Explanation:
i is a static variable so is the same variable regardless of which object of the class is used to access it. This means that both the obj.i and StaticField.i refer to the same variable and so it is incremented 3 times from 7 to 10. So the output is 10 10.
 
QUESTION 84:
Which two are valid array declarations?
A. Object array [];
B. Boolean array [3]; 
C.  int[] array;
D. Float [2] array;
ANSWER: A, C.
Explanation:
You cannot provide a length of an array in a declaration that does not initialise an array. This means B and D will not compile.
Length can be provided on the right hand side of the = sign when initialising an array.

 
QUESTION 85:
Given:
class Overloading {
 
    int x(double d) {
        System.out.println("one");
        return 0;
    }
 
    String x(double d) {
        System.out.println("two");
        return null;
    }
 
    double x(double d) {
        System.out.println("three");
        return 0.0;
    }
 
    public static void main(String[] args) {
        new Overloading().x(4.0);
    }
}

What is the result?
A. one
B. two
C. three
D. Compilation fails
Answer: D
Explanation:
The method signature for the x methods are the same as both the name and parameter list are identical. This leads to duplicate methods as the compiler cannot distinguish which method is being called and so compilation fails. 

 
QUESTION 86:
Given:
public class MainMethod {
 
    void main() {
        System.out.println("one");
    }
 
    static void main(String args) {
        System.out.println("two");
    }
 
    public static void main(String[] args) {
        System.out.println("three");
    }
 
    void mina(Object[] args) {
        System.out.println("four");
    }
}

What is printed out when the program is executed?
A. one
B. two
C. three
D. four
ANSWER: C
Explanation:  
The valid main method will be public, static, and void and it will take an array of Strings as parameters. The only one that matches this format is the method that prints “three”.
It may also take varargs as a paremeter: 
public static void main(String... args) {}

 
QUESTION 87:
Given:
public class ScopeTest {
    int j;
    int k;
    public static void main(String[] args) {
        new ScopeTest().doStuff();
    }
 
    void doStuff() {
        int x = 5;
        doStuff2();
        System.out.println("x");
    }
 
    void doStuff2() {
        int y = 7;
        System.out.println("y");
        for (int z = 0; z < 5; z++) {
            System.out.println("z");
            System.out.println("y");
        }
    }
}
Which two items are fields?
A. j
B. k
C. x
D. y
E. z

ANSWER: A, B
Explanation: 
A field is an instance variable, bound to the object itself. I can use it in the object without the need to use accessors, and any method contained within the object may use it. x,y,z are local variables.

 
QUESTION 88:
A method is declared to take three arguments.
A program calls this method and passes only two arguments.
What is the result?
A. Compilation fails
B. The third argument is given the value null.
C. The third argument is given the value void.
D. The third argument is given the value zero.
E. The third argument is given the appropriate 
ANSWER: A
Explanation: If a matching signature for a method call cannot be found in a defined method, then compilation will fail.
 
QUESTION 89:
Which three are valid replacements for foo so that the program will compile and run?
public class ForTest {
    public static void main(String[] args) {
        int[] array = {1, 2, 3};
        for (foo) {
        }
    }
}

A. int i : array
B. int i = 0; i < 1;
C. ; ;
D. ; i < 1; i++ 
E. i = 0; i<1;

Answer: A, B, C
Explanation: 
A is a correct implementation of an enhanced for loop.
B is a standard for loop but without any modifier to change the value of i so it is an infinite loop.
C is also a valid standard for loop that will create an infitite loop.
D attempts to use a variable i before defining it so will not compile.
E also does not correctly define the variable i.


 
QUESTION 90:
Given:

public class SampleClass {
    public static void main(String[] args) {
        AnotherSampleClass asc = new AnotherSampleClass();
        SampleClass sc = new SampleClass();
        sc = asc;
        System.out.println("sc: " + sc.getClass());
        System.out.println("asc: " + asc.getClass());
    }
} 
class AnotherSampleClass extends SampleClass {
}


What is the result?
A. sc: class Object 
     asc: class AnotherSampleClass
B. sc: class SampleClass
     asc: classAnotherSampleClass
C. sc: class AnotherSampleClass
     asc: class SampleClass
D. sc: class AnotherSampleClass
     asc: class AnotherSampleClass

ANSWER: D
Explanation:
In the line where it says: sc =asc; the original SampleClass object referenced by sc is now dereferenced and so is eligible for GC.
Both asc and sc now refer to the original AnotherSampleClass object created. 
So now both references refer to an object from the class AnotherSampleClass, which is why the answer is D. getClass() just gets the class of the object and ignores the reference in this case.




 
QUESTION 91 
Given the code fragment: 
int b = 3; 
if ( !(b > 3)) { 
system.out.println("square"); 
}{ 
system.out.println("circle"); 
} 
system.out.println ("...");

What is the result?
A.	square... 
B. 	circle... 
C. 	squarecircle... 
D. 	Compilation fails. 

Correct C.
The correct answer is:
square
circle
… 
Because system.out.println jumps to the next line after printed.
Explanation:
The if condition verifies if b> 3, which is false and then !(false), which true. Therefore it enters to the if block and print square. As there is no else condition it enters to the next block and print circle and then print …
 
QUESTION 92
What is the proper way to defined a method that take two int values and returns their sum as an int value?

A. int sum(int first, int second) { first + second; } 
B. int sum(int first, second) { return first + second; } 
C. sum(int first, int second) { return first + second; } 
D. int sum(int first, int second) { return first + second; } 
E. void sum (int first, int second) { return first + second; } 

Correct D.
Explanation:
     A incorrect: Is missing the return keyword (return first + second).
     B incorrect: Is missing the data type of the second method parameter (int second).
     C incorrect: Is missing the return type (int sum()). 
     E incorrect: Wrong return type (void) have to be int.
 
QUESTION 93
Which two are Java Exception classes?

A. SercurityException .
B. DuplicatePathException. 
C. IllegalArgumentException 
D. TooManyArgumentsException 

Correct A and C
 
QUESTION 94
Given the for loop construct:

for ( expr1 ; expr2 ; expr3 ) {
statement; 
}

Which two statements are true?
A. This is not the only valid for loop construct; there exits another form of for loop constructor. 
B. The expression expr1 is optional. It initializes the loop and is evaluated once, as the loop begin. 
C. When expr2 evaluates to false, the loop terminates. It is evaluated only after each iteration through    
     the loop. 
D. The expression expr3 must be present. It is evaluated after each iteration through the loop. 

Correct A and B.
Explanation:
     A is correct because there are two different for loops in java .This one in the example and this     
     other one:
	for( datatype variable:Array/List){
	statement;
}
     B is correct because	the expr1 is for initialize the variable and the programmer could be initialize it  
     outsite the for loop:
     expr1: int i=0;
	   for ( ; expr2 ; expr3 ) {
  statement; 
 }
      C is incorrect because the expr2 is evaluated before each iteration.
      D is incorrect because the expr3 may not be in the statement:
                for (expr1 ; expr2 ;) {
  statement; 
       }
 
QUESTION 95
What is the result?

public class StringReplace {
public static void main(String[] args) {
String message = "Hi everyone!";
System.out.println("message = " + message.replace("e", "X")); }
}

A. message = Hi everyone! 
B. message = Hi XvXryonX! 
C. A compile time error is produced. 
D. A runtime error is produced. 
E. message = 
F. message = Hi Xveryone! 

Correct B.
Explanation:
The Replace() method checks for string “Hi everyone” for the character ‘e’, it then replaces everywhere it finds ‘e’ with X. So you end up with Hi XvXryonX! 
 
QUESTION 96
Which two statements are true for a two-dimensional array?

A. It is implemented as an array of the specified element type. 
B. Using a row by column convention, each row of a two-dimensional array must be of the same size 
C. At declaration time, the number of elements of the array in each dimension must be specified 
D. All methods of the class Object may be invoked on the two-dimensional array. 

Correct A and D.
Explanation:
     B is incorrect because each row of a two-dimensional array don’t have to be the same size.
     C is incorrect because you have to specified the number of elements at initialization time.

 
QUESTION 97
Which three statements are benefits of encapsulation?

A. allows a class implementation to change without changing the clients 
B. protects confidential data from leaking out of the objects 
C. prevents code from causing exceptions 
D. enables the class implementation to protect its invariants 
E. permits classes to be combined into the same package 
F. enables multiple instances of the same class to be created safely 

Correct A, B and D.
Explanation:
•	Option A is correct as if a class is properly encapsulated (private members with public getter methods), then if you do some change in the class it should not break the code where you already have created members of that class
•	Option B is correct as by having private members of class, it means any information held by these private members can only be accessed inside of that class
•	Option C is incorrect as encapsulation has nothing really to do with exceptions
•	Option D is correct as invariant is some property of a class that stays the same for all instances of a class, no matter what other code does. So if something is private it is more difficult for it to be accessed or changed in any way by other code
•	Option E is incorrect as encapsulation is not something that effects whether classes can be combined in the same package
•	Option F is incorrect as again encapsulation is not something that really effects whether you can create multiple instances of the same class, there is something called a“singleton” which means you can only create one instance of a class, but this is not on this exam

 
QUESTION 98
Given the code fragment:

1. ArrayList<Integer> list = new ArrayList<>(1);
2. list.add(1001);
3. list.add(1002);
4. System.out.println(list.get(list.size()));

What is the result?
A. Compilation fails due to an error on line 1. 
B. An exception is thrown at run time due to error on line 3 
C. An exception is thrown at run time due to error on line 4 
D. 1 002 

Correct C.
Explanation:
     A is incorrect because there is nothing wrong on line 1. (1) is the initial size of the ArrayList list.
     B is incorrect because an ArrayList can adjust its size. First check if there is enough space. If not,   
     create a new bigger ArrayList, added the old one plus the new element.
 
QUESTION 99
Given the code fragment:
String[] colors = {"red", "blue", "green", "yellow", "maroon", "cyan"};

Which code fragment prints blue, cyan, ?
A. for (String c : colors) {
    if (c.length() != 4) {
        continue;
    }
    System.out.print(c + ", ");
}

B. for (String c : colors[]) {
    if (c.length() <= 4) {
        continue;
    }
    System.out.print(c + ", ");
}

C. for (String c : String[] colors) {
    if (c.length() >= 4) {
        continue;
    }
    System.out.print(c + ", ");
}

D. for (String c : colors) {
    if (c.length() >= 4) {
        System.out.print(c + ", ");
        continue;
    }
}

Answer A 
A is correct because when the element c lengths is different than 4 the instruction continue is calling and is going to the next iteration (Skipping the print statement). When the element c’s length is equal to 4 it will not enter to the if condition(thus, no continue) and prints that element. 
B wont compile because it is wrong way to declare an enhanced for loop (no [] should be present).
C wont compile because it is wrong way to declare an enhanced for loop (no [] should be present,           and the type before the array name should not be present).
D is incorrect because is going to print all elements where the length is 4 or higher, so will just print out all of the strings in the array apart from “red”.

 
QUESTION 100
View the Exhibit. 
public class Hat { 
public int ID =0; 
public String name = "hat"; 
public String size = "One Size Fit All"; 
public String color=""; 
public String getName() { return name; } 
public void setName(String name) { 
this.name = name; 
} 
} 

Given: 
public class TestHat {
public static void main(String[] args) { 
Hat blackCowboyHat = new Hat(); 
} 
} 

Which statement sets the name of the Hat instance?
A. blackCowboyHat.setName = "Cowboy Hat"; 
B. setName("Cowboy Hat"); 
C. Hat.setName("Cowboy Hat"); 
D. blackCowboyHat.setName("Cowboy Hat"); 

Correct D.
Explanation:
A is incorrect because is wrong syntax (blackCowboyHat.setName = "Cowboy Hat";).
B is incorrect because is missing the object instance to call the method.
C is incorrect because you cannot call a method using a class. You have to use an object  
instance.
 
Question 101:
Given:

import java.util.ArrayList;
import java.util.List;


public class TestRemIf
 {
public static void main(String[] args) 
{ 
List<Integer> list = new ArrayList<>();
list.add(21); list.add(13);
list.add(30); list.add(11);
list.add(2);

// insert here

System.out.println(list);    //     [21, 13, 11]
}
}

Which inserted  at line (insert here) WILL PROVIDE following output:   [ 21, 13, 11 ]  ?

A.	list.removelf(e-> e%2 != 0);
B.	 list.removelf(e -> e%2 != 0);
C.	list.removelf(e -> e%2 == 0);
D.	list.remove(e -> e%2 = 0);
E. None of the above
Answer is C
In output we can see only odd numbers, so we need remove only even numbers to get [ 21, 13, 11 ]
We have new method in JSE 8 called removelf() which takes Predicate object and remove elements which satisfies Predicate condition.
Predicate has functional method call: take object and check if the given condition met or not, if met it returns true, otherwise false.
(3):
we have passed correct lambda expression to check  whether the number is odd or even that matches to functional method of all odd numbers.

 
Question 102;
public class TestLoop {
	
	public static void main(String args []){
		
		int array[] = {0, 1, 2, 3, 4};
		int key = 3;
		
			for (int pos = 0; pos < array.length; ++pos){
				
				if(array [pos] == key){
					
					break;
				}
			}
			System.out.println("Found "+ key + "at " + pos);
	}

}

A.	Found 3 at 2
B.	Found 3 at 3
C.	Compilation fails
D.	An exception is thrown at runtime
Answers
A.	Wrong: But would have worked if pos had been initialised outside the loop as a variable.
B.	Wrong: Even if pos had been initialised outside the loop as a variable. The difference between the  array length and position of the numbers in the index of the array would have resulted in Found 3 at 2.
C.	Correct:  pos cannot be printed at the end because it was initialised inside the loop and cannot be reached.
D.	Wrong: since it doesn’t compile to begin with it doesn’t reach runtime.










 
Question 103:
import java.util.*;

public class Ref {
	public static void main(String [] args){
		
		StringBuilder s1 = new StringBuilder("Hello Java");
		String s2 = s1.toString();
		
		List<String> lst = new ArrayList<String>();
			lst.add(s2);
		
		System.out.println(s1.getClass());
		System.out.println(s2.getClass());
		System.out.println(lst.getClass());
	}

}

A.	class.java.lang.String
           class.java.lang.String
	class.java.util.ArrayList

     B. 	class.java.lang.Object
	class.java.lang.Object
	class.java.util.Collection

    C.  	class.java.lang.StringBuilder
	class.java.lang.String
	class.java.util.ArrayList

    D.	class.java.lang.StringBuilder
	class.java.lang.String
	class.java.util.List
Answers
A.	Wrong: s1 is a StringBuilder class
B.	Wrong: Object and Collection are the ultimate base classes but are not used here.
C.	Correct: 
D.	Wrong: lst is an ArrayList not a List.

Answer is C
List is a super class of the ArrayList class, so this will compile. The .getClass command will get the class of the object and the reference of the object is not considered for this command.
So S1 is a StringBuilder object
S2 is a String object that was produced by using the s1.toString() method which produced a new String object from the StingBuilder object s2
Lst is a ArrayList Object, this object has a List reference to a ArrayList object but .getClass only considers the class of the object.

 
Question 104:
public class Case {
	
	public static void main (String args []){
		
		String product = "Pen";
		product.toLowerCase();
		product.contact(" Box".toLowerCase());
		System.out.println(product.substring(4,6));
	}

}

A.	box
B.	nbo
C.	bo
D.	nb
E.	An exception is thrown at runtime

E. Correct the method contact() is undefined. However if contact had been written as concat() then a StringIndexOutOfBoundsException would have been thrown. So, the answer would still be E.

 
Questions 105:
public class Whizlabs {
	
	public static void main(String args[]){
		
		int sum = 0;
		
		for( int x = 0; x <= 10; x++)
			sum += x; //line 6
		
		System.out.println("Sum for 0 to "+ x);// line 7
		System.out.println(" = " + sum );
	}
}
Which is true?

A.	Sum for 0 to 0 = 55
B.	Sum for 0 to 10 = 55
C.	Compilation fails due to error on line 6
D.	Compilation fails due to error on line 7
E.	An exception thrown at runtime.
Answers
A.	Wrong
B.	Wrong
C.	Line 6 is fine as x is a LOCAL variable that is only available inside the for loop, and this line is inside the for loop
D.	Correct – x is local to the for loop, and this statement is outside the for loop so it cannot be accessed from this location.
E.	Wrong - Compilation fails so our program does not run so can throw an exception at runtime
 
Question 106:
Given the code fragment:

		System.out.println(28 + 5 <= 4 + 29);
		System.out.println((28 + 5) <= ( 4+ 29));

What is the result?

A.	28false29
	true
  
     B. 	285 < 429
	true
	
     C.	true
	true

     D. compilation fails
Answers
A.	Wrong. The addition operators go first even without brackets so it is 33 <= 33  so it prints out true in both cases.
B.	Wrong: In the first print statement the angle symbol is as one with the equals symbol in the comparator <=. It isn’t treated separately.
C.	Correct
D.	Wrong: Compiles just fine.

 
E.	Question 107:
Given:
public class Equal {
	public static void main(String [] args){
		
		String str1 = "Java";
		String [] str2 = {"J","a","v","a"};
		String str3 =  "";
			for (String str : str2){
				
				str3 = str3+str;
			}
			
			boolean b1 = (str1 == str3);
			boolean b2 = (str1.equals(str3));
			System.out.println(b1+ " , "+ b2);
	}

}
What is the result?

A.	true, false
B.	false, true
C.	true, true
D.	false, false

A.	Wrong:
When you create a string by using the concatnator (either concat() or +), you are creating a NEW string and the resultant string is NOT placed in the pool
B.	Correct
C.	Wrong: The first comparator == is false.
D.	Wrong: The second comparator equals() is true.
 
Question 108:
Given:

public class Test {
	
	static void dispResult (int [] num){
		
		try{
			System.out.println(num[1] / num[1] - num[2]);
		}
		catch(ArithmeticException e){
			System.out.println("First Exception");
		}
		System.out.println("Done");
	}
	public static void main(String[] args){
		
		try{
			int[] arr = {100, 100};
			
			dispResult(arr);
		} 
catch(IllegalArgumentException e){
			System.err.println("Second Exception");
		} 
catch (Exception e) {
			System.err.println("Third Exception");
		}
	}

}
What is the result?

A.	0
	Done
     B.	First
	Done
     C.	Second Exception
     D. 	Done
	Third Exception
     E.	Third Exception
E. Correct
 This line
System.out.println(num[1] / num[1] - num[2]);
Generates ArrayIndexOutOfBounds which is not caught by the try/catch block inside of the dispResult() method. So we go to where this method is being called and we see that the call to the method is inside a try/catch block and the first catch block does not catch our exception. However we have a second catch block which catch(Exception e), which means it can catch all exceptions and it’s sub classes, so this catch block deals with ArrayIndexOutOfBounds Exception and prints out “Third Excpetion”
 
Question 109:
public class MarkList {
	
	int num;
	public static void graceMarks (MarkList obj4){
		obj4.num +=10;
	}
	public static void main(String args[]){
		
		MarkList obj1 = new MarkList();
		MarkList obj2 = obj1;
		MarkList obj1 = null;
		obj2.num = 60;
		graceMarks(obj2);		
	}
}

How many objects are created in the memory at runtime?

A.1
B.2
C.3
D.4

A:Correct

 
Question 110:
public class X implements Z {
	
	public String toString(){
		
		return "X";
	}
	public static void main(String args[]){
		
		Y myY = new Y();
		X myX = myY;
		Z myZ = myX;

		System.out.println(myX);
		System.out.println((Y)myX);
		System.out.println(myZ);
	}
}
class Y extends X {
	public String toString(){
		
		return "Y";
	}
}
What is the result?

A.	XXX
B.	XYX
C.	YYX
D.	YYY

A.	Wrong: 
B.	Wrong
C.	Wrong
D.	Correct

System.out.println(myX);
As myX is a X reference to a Y object, it takes it’s implementation from the object, so this will print out “Y”
System.out.println((Y)myX);
This is casting myX to be of type Y, so it would force this object to takes it’s implementation from the Y class if it was not already doing so
Print out “Y”
System.out.println(myZ);
Every reference, regardless of whether is a interface reference, will have access to the “toString()” method, and all other methods that every class inherits from the Object class (i.e equals(), getClass(), etc. So when we put the interface referenced object to a class that implments that reference, which is this line
System.out.println(myZ);
This is the same as 
System.out.println(myZ.toString());
myZ is referencing the Y OBJECT myX, so it it the Y objects toString(). The Y object overrides the toString() 
Print out “Y”
 
Question 111:
Given:

public class Patient {
	
	String name;
	public Patient(String name){
		
		this.name = name;
	}
}
And the code fragment:

public class Test {
	
	public static void main(String args[]){
		
		List ps = new ArrayList();
		Patient p2 =  new Patient("Mike");
		ps.add(p2);
		
//insert code here
		
		if ( f >=0 ){
			
			System.out.println("Mike Found");
		}
	}
		
}

Which code fragment when inserted at line 14, enables the code to print Mike Found?

A.	int f = ps.indexOf(new patient(“Mike”));
B.	int f = ps.indexOf(patient(“Mike”));
C.	Patient p = new Patient(“Mike”);
	int f = pas.indexOf(P);
     D.	int f = ps.indexOf(p2);

Answer D
We can declare a list reference to a ArrayList object, and we do not need to to give it a type (i.e List<Integer> myList). We can declare this type of list and this is a list where we can add ANY type of object, but objects in this class can only call methods first created in the object class (i.e if we added a dog to this list, you cannot call the eat() method for that object,we can only call overridden methods of the object class in the Dog class)
A.	Wrong: Patient cannot be resolved to type, this is creating a new patient, with the name of “mike” and then gets the index of This patient, which is a DIFFERENT paitent to the original patient called mike
B.	Wrong: this is trying to call a method called paitent() that takes a string, with the string “Mike”
C.	Wrong: same issue as in option A
D.	Correct, this is getting the indexOf the patient p2, which is the original patient called “Mike”
 
Question 112:
public class Test {
	public static void main(String args []){
		
		try{
			String [] arr = new String[4];
			arr[1] = "Unix";
			arr[2] = "Linux";
			arr[3] = "Solaris";
			
			for (String var : arr){
				System.out.print(var + " ");
			}
		} catch(Exception e){
			System.out.println(e.getClass());
		}
	}

}
What is the result?

A.	Unix Linux Solaris
B.	null Unix Linux Solaris
C.	Class java.lang.Exception
D.	Class java.lang.NullPointerException

A.	Wrong: Code doesn’t throw exception as is valid but this answer omits arr[0] which is null. if we try to do something with a null object we would have got a NullPointerException
B.	Correct
C.	Wrong: No exception is thrown as code compiles and runs.
D.	Wrong No NullPointerException is thrown as code compiles and runs.
 
Question 113:
public class Series {
	private boolean flag;
	public void displaySeries(){
		int num = 2;
		
		while(flag) {
			if (num%7 == 0)
				flag =false;
				System.out.println(num);
			num += 2;
		}
	}
	public static void main(String []args){
		new Series().displaySeries();
	}

}
What is the result?

A.	2 4 6 8 10 12
B.	2 4 6 8 10 12 14
C.	Compilation fails
D.	The program prints multiple of 2 infinite times
E.	The program prints nothing.

A.	Wrong: Default value of boolean is false. So while(false) means loop isn’t entered and nothing is printed.
B.	Wrong: Default value of boolean is false. So while(false) means loop isn’t entered and nothing is printed.
C.	Wrong: Default value of boolean is false. So while(false) means loop isn’t entered and nothing is printed.
D.	Wrong: Default value of boolean is false. So while(false) means loop isn’t entered and nothing is printed.
E.	Correct.
 
Question 114:
Which of the following can fill in the blank this code to make it compile?

public interface canFly {
	
	String type = "A";
	void fly();
	
	---------	String getType() {
			return type;
		}

}
A.	abstract
B.	public
C.	default
D.	It will not compile with any as interfaces cannot have non abstract methods
E.	It will compile without filling the blank.

A.	Wrong: Abstract methods do not have bodies in an interface.
B.	Wrong: Abstract methods do not have bodies in an interface
C.	Correct: You can have a default method in an interface.
D.	Wrong. Interfaces can have abstract methods.
E.	Wrong: Default method has to be explicit in an interface.

 
Question 115
Given:

public static void main(Strinng[]  args){
Which lines of code will compile and execute
int a, b, c = 0;
int a, b, c;
int g, int  h, int I = 0;
int d, e, F;
Int k, l, m; = 0;
}

Which lines of code will Not cause a compilation error?

(Type: Multiple Response, Points: 10, Attempts: 1)
[+]	A. int a, b, c = 0;
[  ]	B. int a, b, c;
[  ]	C. int g, int h, int i = 0;
[+]	D. int d, e, F;
[  ]	E. Int k, l, m; = 0;

A is correct this is declaring three int variables and giving the variable c a value of 10.
B is incorrect as we have already declared a,b,c in the prevous line of code so we have duplicate variables which will not compile
C is incorrect, we can declare many variables of the same type on the same line of code, however we don’t supply the data type more than once per line. Here we have  are supplying the data type “twice” with the word “int”
D is correct
This is declaring three int variables d,e,f
E is incorrect
We have a semi colon after the “m” then we try and give the value to m on a separate line of code	
 
Question 116
Given:

public class ScopeTest1{
          public static void main (String[]  args){
doStuff();// line x1
int x1 = x2;// line x2
int x2 =j;// line x3
          }
          static void doStuff(){
                  System.out.println(j);// line x4
          }
          static int j;
}
Which line causes a compilation error?

(Type: Multiple Response, Points: 10, Attempts: 1)
[  ]	A. line x1
[+]	B. line x2
[  ]	C. line x3
[  ]	D. line x4

Feedback if correct: 	Answer B

The error is caused by attempting to use the variable x2 before it has been declared.



Question 117. 
Given the code fragment:

int j = 0, k = 0;

for ( int i =0; i < x; i++ ) {
        do {
k = 0;
while ( k  <  z ) {z = 4
        k++;
        System.out.print( k + "  " );
}
System.out.println( "  " );
j++;
        } while ( j < y );y = 4
          System.out.println( "---" );
}

What values of x, y, z will produce the following result? 
1 2 3 4
1 2 3 4
1 2 3 4
----
1 2 3 4
----


(Type: Multiple Response, Points: 10, Attempts: 1)
[  ]	A. X = 4, Y = 3, Z = 2
[  ]	B. X = 3, Y = 2, Z = 3
[  ]	C. X = 2, Y = 3, Z = 3
[  ]	D. X = 4, Y = 2, Z = 3
[+]	E. X = 2, Y = 3, Z = 4

Feedback if correct: 	Answer E
This is the only option which will produce the correct output.

	
	


Question 118
Given this:

public class Recorder {
    class Record {}
    class LongRecord extends Record {}
 
    public List<LongRecord> gatherRecords() {
        return Arrays.asList(
            new LongRecord(), new LongRecord()
        );
    }
 
    public void processRecords(
          Collection<Record> records) {  // line n1
       records.forEach(System.out::println);
    }
 
    public void gatherAndProcess() {
        List<LongRecord> lr = gatherRecords(); // line n2
        processRecords(lr);
    }
 
    public static void main(String[] args) {
        new Recorder().gatherAndProcess();
    }
}
Which is true? choose one.
(Type: Multiple Response, Points: 10, Attempts: 1)
[  ]	 
[  ]	 
[  ]	 
[+]	 
[  ]	 

Feedback if correct: 	Answer is D
The correct answer is option D. This question delves into one of the most startling consequences of the type-erasure mechanism of Java’s generics system. When a variable of a collection type is declared with its generic specification—as in something like List<Record>—the “Record” part of the information exists only at compile time. The underlying object is still a List that actually accepts any object type. The power of generics is that they allow the compiler to do “consistency checking” that can ensure that type errors cannot happen in the code.
Full explanation can be found here.

	
	


 
Question 119
Given:

class Alpha {
 
    public String[] main = new String[2];
 
    Alpha(String[] main) {
        for (int ii = 0; ii < main.length; ii++) {
            this.main[ii] = main[ii] + 5;
        }
    }
    public void main() {
        System.out.print(main[0] + main[1]);
    }
}

 public class Test {
 
    public static void main(String[] args) {
        Alpha main = new Alpha(args);
        main.main();
    }
}
And the commands:

javac Test.java
java Test 1 2

What is the result?

(Type: Multiple Response, Points: 10, Attempts: 1)
[+]	A. 1525
[  ]	B. 13
[  ]	C. Compilation fails
[  ]	D. An exception is thrown at runtime
[  ]	E. The program fails to execute due to runtime error

Feedback if correct: 	Correct answer A


Option A: correct, output is 1525.  position main[0] = "1" + 5 => 15,  main[1] = "2" + 5 => 25
Option B: is not correct, wrong output
Option C: is not correct, there is no problem with the code.
Option D: is not correct , there is no exception generated with above commands. If we add one more  argument to commands ( java Test 1 2 3 ), then we get    ArrayIndexOutOfBoundException.
Option E: is not correct, program compile and run with no problems

	
	


 
Question 120
Given:

public class Test {
       public static void main(String[] args) {
        Cake c = new Cake();
        c.bake1(c);
        System.out.println(c.model + " " + c.flavor);
        c.bake2(c);
        System.out.println(c.model + " " + c.flavor);
    }
}
class Cake{
        String flavor;
        int model;
        public Cake bake1(Cake c) {
                 c.flavor = "Strawberry";
                 c.model = 1200;
                 return c;
        }
        public Cake bake2(Cake c) {
                c.flavor = "Chocolate";
                c.model = 1230;
                return c;
        }
}
What is the result?

(Type: Multiple Response, Points: 10, Attempts: 1)
[  ]	 Alternative 1
[  ]	 
[+]	 
[  ]	D. Compilation fails

Feedback if correct: 	Correct answer C



Option A : is not corect Wrong output
Option B:  is not correct. Only first part is correct, second part are not correct 
Option C   CORRECT program produce output: 1200 Strawberry, 1230 Chocolate
Option D:  is not correct. There is no problem with code



 
QUESTION 121
Given:
public class Msg {
	public static String doMsg(char x){
	return “Good Day!”;
	}
public static String doMsg(int y){
	return “Good Luck!”;
	}
	public static void main(String[] args){
		char x = 8;
		int z = ‘8’;
		System.out.println(doMsg(x));
		System.out.print(doMsg(z));
	}
}
What is the result?

A.	Good Day!
Good Luck!
B.	Good Day!
Good Day!
C.	Good Luck!
Good Day!
D.	Good Luck!
Good Luck!
E.	Compilation fails

Answer: A
In the class Msg there are two overloaded doMsg methods, one that takes a char as a method parameter and another that takes an int. In the main method the doMsg method that takes a char is called first and thus “Good Day!” is printed.
The doMsg method that takes an int is then called and “Good Luck!” is printed. Therefore the answer is A. 
 
Question 122
Which of the following will print current time? 

A. System.out.print(new LocalTime()-now0); 
B. System.out.print(new LocalTime()); 
C. System.out.print(LocalTime.now()); 
D. System.out.print(LocalTime.today()); 
E. None of the above.

Answer: C 
C will print the current time
A is wrong as now0 cannot be resolved to a variable and the constructor LocalTime() is undefined
B is wrong as the constructor LocalTime() is undefined
D is wrong as the method today() is undefined for the type LocalTime
E is wrong as C is correct
 
Question 123
Given: 
public class Test { 
public static void main(String[] args) { 
int day = 1; 
switch (day) { 
case "7": System.out.print("Uranus"); 
case "6": System.out.print("Saturn"); 
case "1": System.out.print("Mercury"); 
case "2": System.out.print("Venus"); 
case "3": System.out.print("Earth"); 
case "4": System.out.print("Mars"); 
case "5": System.out.print("Jupiter"); 
} 
} 
} 
Which two modifications, made independently, enable the code to compile and run?
 
A. Adding a break statement after each print statement 
B. Adding a default section within the switch code-block 
C. Changing the string literals in each case label to integer 
D. Changing the type of the variable day to String 
E. Arranging the case labels in ascending order 

Answers: C, D
C enables the code to compile and run as the case labels now match the type of the switch parameter
D enables the code to compile and run as the type of the switch parameter now matches the case labels
A will not enable the code to compile as even with this modification the case labels still do not match the type of the switch parameter
B will not enable the code to compile as even with this modification the case labels still do not match the type of the switch parameter
E will not enable the code to compile as even with this modification the case labels still do not match the type of the switch parameter
 
Question 124. 
Given the code fragment: 

public static void main(String[] args) { 
int iArray[] = {65, 68, 69}; 
iArray[2] = iArray[0]; 
iArray[0] = iArray[1]; 
iArray[1] = iArray[2]; 
for (int element : iArray) { 
System.out.print(element + " "); 
} 
}

A. 68, 65, 69 
B. 68, 65, 65 
C. 65, 68, 65 
D. 65, 68, 69 
E. Compilation fails 

Answer: B (Assuming that missing “}” is included)
The three elements of iArray are initialised to 65, 68 and 69. The third element is then assigned the value of the first element, 65. The first element is then assigned the value of the second element, 68. The second element is then assigned the value of the third element, 65. Within the enhanced for loop the first element is printed first 68, then the second element 65 and then the third element 65. Therefore the correct answer is B. 
 
Question 125
Given:
 
public class Test1 { 
static void doubling (Integer ref, int pv) { 
ref =20; 
pv = 20; 
} 
public static void main(String[] args) { 
Integer iObj = new Integer(10); 
int iVar = 10; 
doubling(iObj++, iVar++); 
System.out.println(iObj+ ", "+iVar); 
}
}

What is the result? 
A. 11, 11 
B. 10, 10 
C. 21, 11 
D. 20, 20 
E. 11, 12 

Answer: A (Assuming that missing “}” are included)
In the main method an Integer wrapper object, iObj, is declared and assigned an initial value of 10. This wrapper object is passed as an argument to the method doubling, along with a primitive integer variable, iVar. The doubling method does not change the value of either iObj or iVar in the main method. The values of iObj and iVar are incremented in the main method. The code then prints out the values of iObj and iVar which are 11 and 11. Therefore the correct answer is A.  
 
Question 126
 Consider:

Integer number = Integer.valueOf(“808.1");
Which is true about the above statement? 

A. The value of the variable number will be 808.1 
B. The value of the variable number will be 808 
C. The value of the variable number will be 0. 
D. A NumberFormatException will be throw. 
E. It will not compile. 

Answer: D (Assuming that Integer.valueOff 808.1") should be Integer.valueOf(“808.1"))
Although the code will compile it will throw a NumberFormatException at runtime. The String “808.1” is not a valid argument for the method Integer.valueOf. The correct answer is D.

 
Question 127
Given: 

public class MyClass { 
public static void main(String[] args) { 
while (int ii = 0; ii < 2) { 
ii++; 
System.out.println("ii = " + ii); 
} 
} 
} 
What is the result? 

A. ii = 1 ii = 2 
B. Compilation fails 
C. The program prints nothing 
D. The program goes into an infinite loop with no output 
E. The program goes to an infinite loop outputting: ii = 1 ii = 1 

Answer: B
The termination condition of the while loop must evaluate to a boolean. In this case the inclusion of “int ii = 0;” will cause a compilation error. Therefore, the correct answer is B.
 
Question 128
 

The class is poorly encapsulated. You need to change the circle class to compute and return the area instead. 
Which two modifications are necessary to ensure that the class is being properly encapsulated? 

A. Remove the area field. 
B. Change the getArea( ) method as follows: 
     public double getArea ( ) { return Math.PI * radius * radius; } 
C. Add the following method: 
     public double getArea ( ) {area = Math.PI * radius * radius; } 
D. Change the cacess modifier of the SerRadius ( ) method to be protected.

Answer A,B
Here you can only work with the answers you are given and ideally you would make all of the variables private and have public getters for those variables, but you are not given those options so you have to work with the answers you are given. It is in  also possible that there is a option missing, as making the radius private should really also be an option and it maybe it is asking for three modifications.
A is correct as other options given allow us to calculate the area from the existing variables
B is correct as we are using public method to calculate the area from existing variables
C is incorrect as if you make the change in option B, then you can no longer access the Area variable as it does not exist
D is incorrect as a well encapsulate class using “private” access modifiers, not “protected”

 
Question 129
 Given the code fragment? 

public class Test { 
public static void main(String[] args) { 
Test t = new Test(); 
int[] arr = new int[10]; 
arr = t.subArray(arr,0,2); 
} 
// insert code here 
} 

Which method can be inserted at line // insert code here to enable the code to compile? 

A. public int[] subArray(int[] src, int start, int end) { 
	return src; 
     } 
B. public int subArray(int src, int start, int end) { 
	return src; 
    } 
C. public int[] subArray(int src, int start, int end) { 
	return src; 
     } 
D. public int subArray(int[] src, int start, int end) { 
    	return src; 
     }

Answer: A
The subArray method in option A accepts an integer array and two integer variables as method parameters. It also returns an integer array. This matches the return type of, and the method arguments passed to, the subArray method in the code fragment. Therefore, the subArray method in option A will enable the code to compile if inserted at line //insert code here. The method parameters of the subArray methods in options B and C don’t match the method arguments passed to the subArray method in the code fragment. The subArray method in option D will not compile as its return type is int but it returns an integer array. 
 
Question 130
 Given: 

public class App { // Insert code here System.out.print("Welcome to the world of Java"); } } 

Which two code fragments, when inserted independently at line // Insert code here, enable the program to execute and print the welcome message on the screen? 

A. static public void main (String [] args) { 
B. static void main (String [] args) { 
C. public static void Main (String [] args) { 
D. public static void main (String [] args) { 
E. public void main (String [] args) { 

Answers: A, D 
Inserting the standard main method at line //Insert code here will enable the program to execute and print the message. The main method in option A is the standard main method. The positions of the public and static keywords are interchangeable. The main method in option D is also the standard main method. Therefore the correct answers are A and D. Option B will not work as the main method does not have the public access modifier. Option C will not work as the Main method is not the standard main method. Option E will not work as the main method is not static. 
 
Question 131
 Given: 

package p1; 
public interface DoInterface { 
void method1(int n1); // line n1 
} 
package p3; 
import p1.DoInterface; 
public class DoClass implements DoInterface { 
public DoClass(int p1) { } 
public void method1(int p1) { } // line n2 
private void method2(int p1) { } // line n3 
} 
public class Test { 
public static void main(String[] args) { 
DoInterface doi= new DoClass(100); // line n4 
doi.method1(100); 
doi.method2(100); 
} 
} 
Which change will enable the code to compile? 

A. Adding the public modifier to the declaration of method1 at line n1 
B. Removing the public modifier from the definition of method1 at line n2 
C. Changing the private modifier on the declaration of method 2 public at line n3 
D. Changing the line n4 DoClass doi = new DoClass ( );

None of the changes will enable the code to compile. 
A does not have any effect as abstract method method1 in interface DoInterface is implicitly public anyway.
B will not work as when implementing the abstract method method1 from the interface DoInterface in the class DoClass the access modifier will have to be public.
C will not enable the code to compile. In the main method there is an interface reference (DoInterface doi) to an object of a class (new DoClass(100)) that implements the interface. However, the method method2 is undefined for the type DoInterface. Therefore, the call to method2 in the main method will not compile. Changing the access modifier for method2 in class DoClass will not prevent this compilation error.
D will case a compilation error as there is no constructor in class DoClass that takes no arguments.  

 
Question 132
Given:
public class Series {
private boolean flag;
public void displaySeries() {
int num = 2;
while (flag) {
if (num % 7 == 0)
flag = false;
System.out.println(num);
num += 2;
}
}
public static void main(String[] args) {
new Series().displaySeries();
}
}
What is the result?
A. 2 4 6 8 10 12
B. 2 4 6 8 10 12 14
This case may be printed if boolean flag variable was initialized with value of true
C. Compilation fails.
D. The program prints multiple of 2 infinite times
E. The program prints nothing.
Boolean variable flag in this case is initialized by default to false. The code won’t enter the loop because the condition num % 7 == 0 isn’t true until num assumes the value of 14. When this condition is met, flag = false; statement change the value of flag to false, and then the loop is never executed.  

 
Question 133
Which of the following can fill in the blank in this code to make it compile?
interface CanFly {
	String type = "A";
	void fly();
	_______ String getType(){
	return type;
	}
}
A. abstract
B. public
C. default 
D. It will not compile with any as interfaces cannot have non abstract methods..
E. It will compile without filling the blank.

A is incorrect
That method cannot be abstract, because abstract method do not specify a body.
B is incorrect 
as this will change only the access modifier, and this is default method as it has a body
C is Correct
Interface methods can define an implementation by using default methods. Starting with Java 8, interfaces can be augmented by adding methods with default implementation. Implementing classes might choose to override these methods to define their own specific behaviour. If they don’t choose to override them, the default implementation from the interface is used. The definition of a default method must include the keyword default:
D is incorrect
Interfaces can have non abstract methods 
E is incorrect 
Question 134
Consider Following method:
default void print(){
}
Witch statement is true?
A. This method is invalid.
B. This method can be used only in an interface.
Only interfaces use default keyword in a method.
C. This method can return anything.
Not. This method is void and does not return anything. 
D. This method can be used only in an interface or an abstract class.
A class does not use default access modifier.
E. None of above.
 
Question 135
Given:
public class MyFor3 {
public static void main(String[] args) {
int[] xx = null;
for (int ii : xx) {		//line 4
System.out.println(ii);
}
}
}

What is the result?
A. Null.
B. Compilation fails.
C. An exception is throw at runtime.
Null pointer access: The variable xx can only be null at this location, and then NullPointerException is thrown.
 
Exception in thread "main" java.lang.NullPointerException
	atMyFor3.main(MyFor3.java:4)

C. 0
 
Question 136
Given:
public class TestLoop {
public static void main(String[] args) {
		float myarray[]={10.20f, 20.30f, 30.40f, 50.60f};
		int index= 0;
		boolean isFound = false;
		float key= 30.40f;
		//insert code here
		System.out.println(isFound);
	}
}

Which code fragment, when inserted at line 7, enables the code print true?

A. Option A.
while(key == myarray[index+1]) {
isFound =true;
}
This code prints false as:  boolean isFound = false statement assumes the value of isFound to false.

B. Option B.
while (index <= 4) {
	if (key == myarray[index]) {
	index++;
	isFound = true;
	break;
}
}
This code prints nothing, and the loop will never terminate.

C. Option C.
while (index++ < 5) {
	if (key == myarray[index]) {
	isFound = true;
	}
}
This code will throw an Exception as the index reach number 4, because index ends at 3.

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 4
	at TestLoop.main(TestLoop.java:8)

D. Option D.
while (index < 5) {
	if (key == myarray[index]) {
	isFound = true;
	break;
	}
	index++;
}
This code works, because as if statement meets the condition, isFound variable assumes value of true, and true is printed.
		
Question 137
Given:
public class Base {
public static void main(String[] args) {
	System.out.println("Base " + args[2]);
	}
}
public class Sub extends Base {
	public static void main(String[] args) {
	System.out.println("Overriden " + args[1]);
	}
}
And commands:
javac Sub.java
java Sub 10 20 30

What is the result?
A. Base 30
This case may be printed if the program was executed with command prompt: 
javac Base.java
java Base 10 20 30 

B. Overriden 20
As a java executes Sub.java file which override main method of Base class, and prints the second element of java Sub 10 20 30 command which is 20 and is at args[1] position.

C. Overriden 20
     Base 30
D. Base 30
    Overriden 20
 
Question 138 
Given:
class SpecialException extends Exception {
	public SpecialException(String message){
	super(message);
	System.out.println(message);
	}
}
public class ExceptionTest {
	public static void main(String[] args) {
	try{
	doSomething();
}
		catch (SpecialException e){
	System.out.println(e);
		}
	}
	static void doSomething() throws SpecialException{
	int[] ages = new int[4];
	ages[4]=17;
	doSomethingElse();
	
	}
	static void doSomethingElse() throws SpecialException {
	throw new SpecialException("Throw at end of doSomething() method");
	}
}
What will be the output?
The line
ages[4]=17;
Produces a ArrayIndexOutOfBoundsException as ages is an array of length 4 and this is trying to access the fifth element of the array which does not exist. So the line
doSomethingElse() 
never executes. This exception is thrown out of the method by the to the main
throws SpecialException() 
in the doSomething() metho, as speicalException() extends excpetion, then it can handle ALL exceptions. In Main the call to the method is enclosed in a try catch block, the catch part just catching the exception generated and printing out the exception.

A. Option A.
SpecialException: Thrown at end of doSomething() method
B. Option B.
Error in thread “main” java.lang.ArrayIndexOutOfBoundsError
C. Option C.
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 4
	at ExceptionTest.doSomething(ExceptionTest.java:13)
	at ExceptionTest.main(ExceptionTest.java:4)
D. Option D.
SpecialException: Thrown at end of doSomething() method
	at ExceptionTest.doSomethingElse(ExceptionTest.java:16)
	at ExceptionTest.doSomething(ExceptionTest.java:13)
	at ExceptionTest.main(ExceptionTest.java:4)
Question139
Given:
interface Contract { }
class Super implements Contract{ }
class Sub extends Super{ }
public class Ref {
	public static void main(String[] args) {
		List objs = new ArrayList();
		Contract c1 = new Super();
		Contract c2 =new Sub();		//line n1
		Super s1 = new Sub();
		objs.add(c1);
		objs.add(c2);
		objs.add(s1);		//line n2
		for (Object itm :objs) {
		System.out.println(itm.getClass().getName());
		}
	}
}

What is the result?
A. Super 
     Sub
     Sub 
The statement System.out.println(itm.getClass().getName()); prints names of the class  objects c1, c2, s1 which are Super, Sub and Sub

B. Contract 
     Contract
     Super 

C. Compilation fails at line n1

D. Compilation fails at line n2
 
Question 140
Given:
public class Test {
	public static void main(String[] args) {
		Test ts = new Test();
		System.out.println(isAvailable + " ");
		isAvailable = ts.doStuff();
		System.out.println(isAvailable);
	}
	public static boolean doStuff() {
	return !isAvailable;
	}
	static boolean isAvailable = false;
}

What is the result?

A. true true
B. true false
C. false true
As first System.out.println(isAvailable + " ") statement is calling boolean isAvailable variable with false value, prints false. Then doStuff() method is called with return type !isAvailable (negative) changing variable isAvailable to true. Then System.out.println(isAvailable); command is called and prints true.

D. false false
E. Compilation fails.


 
Question 141
Which code fragment cause a compilation error? 

A. float flt = 100F; 
B. float flt = (float) 1_11.00; 
C. float flt = 100; 
D. double y1 = 203.22; float flt = y1 
E. int y2 = 100; 
    Float flt = (float)y2;

Answer is D
•	there is a possible typo for this questions and it revolves around option A, there is no data type called flat, unless that this should be float instead of flat, then a would compile
•	B will compile as we are casting 1_1100 to be of type float, and underscores “_” are ignored by the compiler if  they are NOT at the start of a number, end of a number, directly before or after a decimal point
•	C will compile as 100 is an int and an int will fit inside a float
•	D will NOT COMPILE, and there is a bit of typo in the original which has been rectified here. Y1 is a double. We can’t assign a double to a float as a double is bigger than a float, we would have to cast it.
•	E will compile as y2 is a int and an int will fit inside a float, so this would even work without a cast

 
Question 142
Which three statements are true about the structure of a Java class? 

A. A class can have only one private constructor. 
B. A method can have the same name as a field. 
C. A class can have overloaded static methods. 
D. A public class must have a main method. 
E. The methods are mandatory components of a class. 
F. The fields need not be initialized before use. 
Answer is B,C,F
•	Option A is not true as a constructor can be private and you can have as many overloaded constructors in a class as you want, the private constructor is usually called by another public constructor in the same class
•	Option B is true as a method can have the same name as a field, i.e spot.name is a field and spot.name() is a method
•	Option C is true a class can have as many overloaded methods, both static and non static, as you want. However you CANNOT OVERRIDE a static method
•	Option D is false as public class does not have to have a main method, the main method is the “jumping” off point for our program
•	A class does not have to have any methods
•	F is true as fields of a class, i.e age of a dog, are given default values if they are not given any explicit values.

 
Question 143
View the exhibit: 

public class Student { 
public String name = ""; 
public int age = 0; 
public String major = "Undeclared"; 
public boolean fulltime = true; 
public void display() { 
System.out.println("Name: " + name + " Major: " + major); } 
public boolean isFullTime() { 
return fulltime; 
} 
} 
Which line of code initializes a student instance? 

A. Student student1; 
B. Student student1 = Student.new(); 
C. Student student1 = new Student(); 
D. Student student1 = Student(); 

Answer is C
•	Option A creates a Student REFERENCE but it does not initialise a object of the student class, to do that you have to use the new keyword
•	Option B is incorrect as that is incorrect syntax
•	Option C is correct as this is the correct way to create Student reference to a newly initialised Student object
•	Option D is incorrect as to create a new object of the class student you have to use the “new” keyword

 
Question 145
Given: 

public class Test { 
public static void main(String[] args) { 
int ax = 10, az = 30; 
int aw = 1, ay = 1; 
try { 
aw = ax % 2; 
ay = az / aw; 
} catch (ArithmeticException e1) { 
System.out.println("Invalid Divisor"); 
} catch (Exception e2) { 
aw = 1; 
System.out.println("Divisor Changed"); 
} 
ay = az /aw; // Line 14 
System.out.println("Succesful Division " + ay); 
} 
} 

What is the result? 

A. Invalid Divisor 
     Divisor Changed 
     Successful Division 30 
B. Invalid Divisor 
     Successful Division 30 
C. Invalid Divisor 
     Exception in thread "main" java.lang.ArithmeticException: / by zero 
     at test.Teagle.main(Teagle.java:14) 
D. Invalid Divisor 
     Exception in thread "main" java.lang.ArithmeticException: / by zero 
     at test.Teagle.main(Teagle.java:14) 
     Successful Division 1 
Answer is C
Ax is 10
So aw=10%2
So aw is 0
The line 
Ay=az/aw
Is 
Ay=30/0
Which throws a ArithmeticException and this is caught by the first catch, which prints out
“Invalid Divisor”
aw stays at 0, as the second Catch block NEVER runs, so aw values stays at 0
the program continues until it gets to the line 
ay=az/aw
ay=30/0
this throws another ArithmeticException, which is not caught or dealt with so this will result in a runtimeException generated at this point.
•	A incorrect as “Divisor changed” is in the second try block which is never executed
•	B incorrect as the line before the print out of “successful division” produces a exception so the code is never reached
•	C is correct because of the above explanation
•	D is incorrect as a unhandled exception of any type, results in a program termination, and in this example we have the program continuing on after a unhandled exception and producing the print out “successful division”, which you can’t do

 
Question 146
Given: 

public class ForTest { 
public static void main(String[] args) { 
int[] array = {1,2,3}; 
for ( foo ) { 
} 
} 
} 

Which three are valid replacements for foo so that the program will compiled and run? 

A. int i: array 
B. int i = 0; i < 1; i++ 
C. ;; 
D. ; i < 1; i++ 
E. ; i < 1; 
Answer is A,B,C
•	A is correct as this is an enhanced for loop and is using the int I to iterate through the array of  ints called array
•	B is correct as this is a valid for loop
•	C is also valid as each of the arguments in a for loop can be left blank (in this circumstance it would result in a infinite loop, but his would compile anD run)
•	D is incorrect as we have not defined what “I” is, nor given it a value, we have not said it is an int, if we had inputted the following line before the code ,int i=0;then this option would be correct
•	E is wrong for the same reason as option D and if modified in the same way would work as well

 
Question 147
Given the for loop construct:
 
for ( expr1 ; expr2 ; expr3 ) { 
		statement; 
} 
Which two statements are true? 

A. This is not the only valid for loop construct; there exits another form of for loop constructor. 
B. The expression expr1 is optional. it initializes the loop and is evaluated once, as the loop begin. 
C. When expr2 evaluates to false, the loop terminates. It is evaluated only after each iteration through the loop. 
D. The expression expr3 must be present. It is evaluated after each iteration through the loop. 
Answer is A,B
•	A is correct, there is an enhanced for loop
•	B is correct as all expressions in a for loop are optional, and expr1 evaluates only at very start of our loop, i.e for(int i=0
•	C is incorrect it is true that  the second argument determines if our loop continues or not, i.e for(int i=0;i<10;i++) as soon as I is no longer less than 10, the loop will exit. However it checks the value BEFORE each iteration
•	D is false as all expressions in a for loop are optional




 
Question 148
 Given: 

public class SampleClass { 
public static void main(String[] args) { 
AnotherSampleClass asc = new AnotherSampleClass(); SampleClass sc = new 
SampleClass(); 
sc = asc; 
System.out.println("sc: " + sc.getClass()); 
System.out.println("asc: " + asc.getClass()); 
}} 
class AnotherSampleClass extends SampleClass { 
} 

What is the result? 

A. sc: class Object asc: class AnotherSampleClass 
B. sc: class SampleClass asc: class AnotherSampleClass 
C. sc: class AnotherSampleClass asc: class SampleClass 
D. sc: class AnotherSampleClass asc: class AnotherSampleClass 

Answer is D
You have one class extending another class and then you create two objects of these classes. The object sc(sample class) is a super class object and the object asc(AnotherSampleClass) is a sub class object. The line
sc=asc;
assigns a sub class object to a super class reference, so sc is now a super class reference to a sub class object.
The getClass() method, gets the class of the OBJECT, and does not care what the reference of the object is.
So the object sc, is a sub class object, which is the AnotherSampleClass.
The object asc is simply a AnotherSampleClass reference to a AnotherSampleClass object, and the getClass()method returns the class of the Object, which is AnotherSampleClass
So the option D is correct







 
Question 149
Given: 

int [] array = {1,2,3,4,5}; 
for (int i: array) { 
if ( i < 2) { 
keyword1 ; 
} 
System.out.println(i); 
if ( i == 3) { 
keyword2 ; 
}} 

What should keyword1 and keyword2 be respectively, in order to produce output 2345? 

A. continue, break 
B. break, break 
C. break, continue 
D. continue, continue 
Answer is D
Break will break out of the loop completely and will not execute any more iterations of the loop, so any option that has a break in it CANNOT be correct. As if you replace keyword1 with BREAK, your loop will exit without printing anything as
At start of loop i=0
So 
If(i<2) is true
Then we
Break;
The loop exits without producing any output
If you replace keyword2 with BREAK, then your loop exits when i==3, so 4 and 5 then would never be printed.
•	Option A will produce 2,3
•	Option B will produce nothing
•	Option C will Produce nothing
•	Option D will produce 2,3,4,5








 
Question 150. 
Given:
 
public class ScopeTest { 
int j, int k; 
public static void main(String[] args) { 
ew ScopeTest().doStuff(); } 
void doStuff() { 
int x = 5; 
doStuff2(); 
System.out.println("x"); 
} 
void doStuff2() { 
int y = 7; 
System.out.println("y"); 
for (int z = 0; z < 5; z++) { 
System.out.println("z"); 
System.out.println("y"); 
} 
}

Which two items are fields? 

A. j 
B. k 
C. x 
D. y 
E. z 
Answer is A,B
Fields also known as instance variables, are variables each object of class has. i.e every Dog has an age, name, weight, etc. and in this example j and k are both fields. 
•	Option A is correct
•	Option B is correct
•	Option C is incorrect as x is a local variable, and is local to the doStruff() method
•	Option D is incorrect as y is a local variable, and is local to the doStuff2() method
•	Option E is incorrect as z is a local variable, and it is local to the for loop contained inside the doStuff2() method
 
Question 151
Given:

public class StringReplace { 
public static void main(String[] args) { 
String message = "Hi everyone!"; 
System.out.println("message = " + message.replace("e", "X")); } 
} 

What is the result? 

A. message = Hi everyone! 
B. message = Hi XvXryonX! 
C. A compile time error is produced. 
D. A runtime error is produced. 
E. message = 
F. message = Hi Xveryone

Answer is B
The replace() method of the String class replaces all instances of a particular character with another character. So in this example the original string was 
“Hi everyone”, 
so 
message.replace("e", "X"));
will replace everywhere is sees an “e” with a “X”
so we get
Hi XvXryonX! 
When we print out this statement.
A word of caution, Strings are IMMUATABLE and you cannot change them, so if we just printed out the string using this command
System.out.println(message)
It would still read
Hi Everyone




 
Question 152
 Given: 

public class ColorTest { 
public static void main(String[] args) { 
String[] colors = {"red", "blue","green","yellow","maroon","cyan"}; 
int count = 0; 
for (String c : colors) { 
if (count >= 4) { 
break; 
} 
else { 
continue; 
} 
if (c.length() >= 4) { 
colors[count] = c.substring(0,3); 
} 
count++; 
} 
System.out.println(colors[count]); 
} 
} 

What is the result? 

A. Yellow 
B. Maroon 
C. Compilation fails 
D. A StringIndexOutOfBoundsException is thrown at runtime. 

Answer is C

The key part of this code is the following lines
if (count >= 4) { 
break; 
} 
else { 
continue; 
} 
If you have just a break and a contine, in an IF, ELSE structure and nothing else inside this structure, then the loop will always either skip the rest of the code in the loop, or exit the loop completely. So anything after this if, else is unreachable code, and unreachable code results in a compilation error
•	Option A is incorrect as this is unreachable code
•	Option b is incorrect as this is unreachable code
•	Option C is correct as explained above
•	Option d is incorrect as this is unreachable code
Question 153
 Which three statements are benefits of encapsulation? 

A. Allows a class implementation to change without changing the clients 
B. Protects confidential data from leaking out of the objects 
C. Prevents code from causing exceptions 
D. Enables the class implementation to protect its invariants 
E. Permits classes to be combined into the same package 
F. Enables multiple instances of the same class to be created safely 
Answer is A,B,D
•	Option A is correct as if a class is properly encapsulated (private members with public getter methods), then if you do some change in the class it should not break the code where you already have created members of that class
•	Option B is correct as by having private members of class, it means any information held by these private members can only be accessed inside of that class
•	Option C is incorrect as encapsulation has nothing really to do with exceptions
•	Option D is correct as invariant is some property of a class that stays the same for all instances of a class, no matter what other code does. So if something is private it is more difficult for it to be accessed or changed in any way by other code
•	Option E is incorrect as encapsulation is not something that effects whether classes can be combined in the same package
•	Option F is incorrect as again encapsulation is not something that really effects whether you can create multiple instances of the same class, there is something called a“singleton” which means you can only create one instance of a class, but this is not on this exam


 
Question 154
Given: 

class Mid { 
public int findMid(int n1, int n2) { 
return (n1 + n2) / 2; 
} 
} 
public class Calc extends Mid { 
public static void main(String[] args) { 
int n1 = 22, n2 = 2; 
// insert code here 
System.out.print(n3); 
} 
} 

Which two code fragments, when inserted at // insert code here, enable the code to compile and print 12? 

A. Calc c = new Calc(); int n3 = c.findMid(n1,n2); 
B. int n3 = super.findMid(n1,n3); 
C. Calc c = new Mid(); int n3 = c.findMid(n1, n2); 
D. Mid m1 = new Calc(); int n3 = m1.findMid(n1, n2); 
E. int n3 = Calc.findMid(n1, n2); 

Answer is A, D
•	Option A is correct as you are created an object of the sub class calc, which extends Mid. Mid has a method called find(), and calc does have access to
•	Option B is incorrect as you are sending the variable n3 to the method find in the super class, without first giving n3 a value. N3 is a LOCAL variable and local variable are given no default value unlike instance variables. Note super.find() is correct as you are calling the find() method in the super class
•	Option C is incorrect as you have a sub class reference (Calc c) to a super class object (new Mid(), which will not compile.
•	Option D is correct as you have a super class Reference (Mid m1) to a sub class object (new Calc()). This means this object has access to methods first defined in the super class, and the find() method was first defined in the super class Mid
•	Option E is incorrect as this is calling a static method find() in the Calc class, there is NO static method in the Calc class



 
Question 156
Which two statements correctly describe checked exception? 

A. These are exceptional conditions that a well-written application should anticipate and recover from. 
B. These are exceptional conditions that are external to the application, and that the application usually cannot anticipate or recover from. 
C. These are exceptional conditions that are internal to the application, and that the application usually cannot anticipate or recover from. 
D. Every class that is a subclass of RuntimeException and Error is categorized as checked exception. 
E. Every class that is a subclass of Exception, excluding RuntimeException and its subclasses, is categorized as checked exception. 

Answer is A,E
Checked Exceptions are conditions (such as reading or writing to a file) that a well written application should be able to anticipate and recover from. Every class that is a subclass of Exception, excluding RuntimeExcpetion, is a checked Exception
•	Option A is correct as explained above
•	Option B is incorrect as this is the explanation for Errors
•	Option C is incorrect 
•	Options D is incorrect as RuntimeException are NOT checked exception and will compile if not dealt with
•	Option E is correct as explained above



 
Question 157
Given the code fragment: 

public class Test { 
public static void main(String[] args) { 
boolean isChecked = false; 
int arry[] = {1,3,5,7,8,9}; 
int index = arry.length; 
while ( <code1> ) { 
if (arry[index-1] % 2 ==0) { 
isChecked = true; 
} 
<code2> 
} 
System.out.print(arry(index]+", "+isChecked)); 
} 
} 

Which set of changes enable the code to print 1, true? 

A. Replacing <code1> with index > 0 and replacing <code2> with index--; 
B. Replacing <code1> with index > 0 and replacing <code2> with --index; 
C. Replacing <code1> with index > 5 and replacing <code2> with --index ; 
D. Replacing <code1> with index and replacing <code2> with --index ; 

Answers is A, B
This loop starts at the last index in the array, which is 9, and works back to the first index in the array, which is 1. Index refers to the current index in your array, but we note that we go
Int index=arry.length
So index=6
However our array numbering goes from 0 to 5, so that is why inside the loop we start at arry[index-1] and this will be arry[6-1] which will be arry[5]
•	Option A is correct and will print out 1,true
•	Option B is correct and will print out 1,true
•	Option C is incorrect and will print out 9, false
•	Option D is incorrect as the while condition has to evaluate to a Boolean, and 
•	While(index){} is NOT a boolean

 
Question 158
Given the code fragment: 

System.out.println(2 + 4 * 9 - 3); //Line 21 
System.out.println((2 + 4) * 9 - 3); // Line 22 
System.out.println(2 + (4 * 9) - 3); // Line 23 
System.out.println(2 + 4 * (9 - 3)); // Line 24 
System.out.println((2 + 4 * 9) - 3); // Line 25 

Which line of codes prints the highest number? 

A. Line 21 
B. Line 22 
C. Line 23 
D. Line 24 
E. Line 25 
Answer is B
Option A is 35
Option B is 49
Option C is 35
Option D is 26
Option E is 35





 
Question 159
Given: 

public class ComputeSum { 
public int x; 
public int y; 
public int sum; 
public ComputeSum (int nx, int ny) { 
x = nx; y =ny; 
updateSum(); 
} 
public void setX(int nx) { x = nx; 
updateSum();
} 
public void setY(int ny) { x = ny; 
updateSum();
} 
void updateSum() { sum = x + y;} 
} 

This class needs to protect an invariant on the sum field. 
Which three members must have the private access modifier to ensure that this invariant is maintained? 

A. The x field 
B. The y field 
C. The sum field 
D. The ComputerSum ( ) constructor 
E. The setX ( ) method 
F. The setY ( ) method 
Answer is C,E,F 






 
Question 160
Which two are Java Exception classes? 

A. SercurityException 
B. DuplicatePathException 
C. IllegalArgumentException 
D. TooManyArgumentsException 

Answer is A and C
SecurityException and IllegalArugument Excepion are exceptions in Java







 
Question 161
Given: 

public class Test { 
static boolean bVar; 
public static void main(String[] args) { 
boolean bVar1 = true; 
int count =8; 
do { 
System.out.println("Hello Java! " +count); 
if (count >= 7) { 
bVar1 = false; 
} 
} while (bVar != bVar1 && count > 4); 
count -= 2; 
} 
} 

What is the result? 

A. Hello Java! 8 Hello Java! 6 Hello Java! 4 
B. Hello Java! 8 Hello Java! 6 
C. Hello Java! 8 
D. Compilation fails 

Answer is C
The boolean bVar is a field, instance variable, so it is given the default value of false. The Boolean bVar1 is a LOCAL variable that is given the value “true”. A do while loop always executes always at least once, a int variable count is given the value 8. So our loop enters and first time prints out:
“Hello Java! 8
If(count>=7) is true so bVar1=false 
While(bVar ! = bVar1..which is 
While(FALSE is not the same as FALSE, which is false and this is short circuit “and” operator so if the first argument is false, it does not bother with the second operator. So we have
Do{
}
While(false) and our loop exits having only run once and printed out 
“Hello Java! 8”

 
Question 162
Given: 

public class String1 { 
public static void main(String[] args) { 
String s = "123"; 
if (s.length() >2) 
s.concat("456"); 
for(int x = 0; x <3; x++) 
s += "x"; 
System.out.println(s); 
} 
} 
What is the result? 

A. 123 
B. 123xxx 
C. 123456 
D. 123456xxx 
E. Compilation fails
Answer is B
s.length is greater than 2 so the if executes
s.concat(“456”) would display 123456 if it was in a print statement, but it’s not and string are immutable so s is still “123” at this point
we enter the for loop and it is going to execute three times, for(int x=0;i<3;x++)
s+=”x” is implemented each time for each loop iteration, we are actually doing
s=s+”X”
so it is doing in each iteration
s=123+”X”
s=123X+”X”
s=123XX+”X”
so finally s is 123XXX



 
Question 163
Given: 

public class MyClass { 
public static void main(String[] args) { 
String s = " Java Duke "; 
int len = s.trim().length(); 
System.out.print(len); 
} 
} 
What is the result? 

A. 8 
B. 9 
C. 11 
D. 10 
E. Compilation fails
Answer is B
S is string “ java Duke “, so the length of this string INCLUDING SPACES is 11
Int len the length of the string with the spaces at the beginning and end of the string removed. S.trim() removes the spaces from the string, and the length()METHOD gets the length of the string without the spaces at the end and beginning of the string, so its 11-2 spaces which is 9

 
Question 164
Given the classes: 

* AssertionError 
* ArithmeticException 
* ArrayIndexOutofBoundsException 
* FileNotFoundException 
* IllegalArgumentException 
* IOError 
* IOException 
* NumberFormatException 
* SQLException 

Which option lists only those classes that belong to the unchecked exception category? 

A. AssertionError, ArrayIndexOutOfBoundsException, ArithmeticExcep tion 
B. AssertionError, IOError, IOException 
C. ArithmeticException, FileNotFoundException, NumberFormatException 
D. FileNotFoundException, IOException, SQLException 
E. ArrayIndexOutOfBoundException, IllegalArgumentException, FileNotFoundException 

Answer is A
A simplier way that learning all these exceptions is to realise that anything to do with file or inputting and outputting information (IOException) is a Checked exception so all of the answers, except A, has either some IO or File exception (SQLException is a checked exception that is generated when we connect to a database)



 
Question 165
Given the code fragment: 

for (int ii = 0; ii < 3;ii++) { 
int count = 0; 
for (int jj = 3; jj > 0; jj--) { 
if (ii == jj) { 
++count; 
break; 
} 
} 
System.out.print(count); continue; 
} 

What is the result? 

A. 011 
B. 012 
C. 123 
D. 000 
Answer is A
The outer loop will execute three times, the break statement breaks out only of the inner loop. 
First iteration of the inner loop
ii is 0
count is 0
the inner loop will execute three times using the variable jj, the variable count will be incremented by 1 if ii==jj, but I does not happen as the loop does not enter when jj=0. So count will print 0
Second iteration loop
ii is 1
the inner loop, will execute until jj=1, so that will mean ii==jj at this point count, which was 0, will be incremented by 1 and the inner loop will be exited
count is 1
Third iteration of loop
ii is 2
the inner loop will execute until jj=2, so that will mean ii==jj at this point count, which was 0, will be incremented by 1 and inner loop will be exited and the outer loop will be exited.









 
Question 166
Given the code fragment: 

public class Test { 
static String[][] arr =new String[3][]; 
private static void doPrint() { 
//insert code here 
} 
public static void main(String[] args) { 
String[] class1 = {"A","B","C"}; 
String[] class2 = {"L","M","N","O"}; 
String[] class3 = {"I","J"}; 
arr[0] = class1; 
arr[1] = class2; 
arr[2] = class3; 
Test.doPrint(); 
} 
} 

Which code fragment, when inserted at line //insert code here, enables the code to print 
COJ? 
A. int i = 0; 
     for (String[] sub: arr) { 
     int j = sub.length -1; 
     for (String str: sub) { 
     System.out.println(str[j]); 
     i++; 
     } 
     } 
B. private static void doPrint() { 
     for (int i = 0;i < arr.length;i++) { 
     int j = arr[i].length-1; 
     System.out.print(arr[i][j]); 
     } 
     } 
C. int i = 0; 
    for (String[] sub: arr[][]) { 
    int j = sub.length; 
    System.out.print(arr[i][j]); 
     i++; 
} 
D. for (int i = 0;i < arr.length-1;i++) { 
     int j = arr[i].length-1; 
     System.out.print(arr[i][j]); 
     i++; 
     } 

Answer is B
A is incorrect 
The second enhanced for loop is for loop through a single string, not an array of strings
B is correct
The line for 
(int i = 0;i < arr.length;i++)
Will mean that this loop will iterate three times, as this is a two dimensional array so this is the amount of rows, which is three
Each row has a different amount of columns. 
So arr[0].length is 3 columns, arr[1].length is 4 columns, array[2].length is 2 columns.
The letter we want is the last letter in each row, so the array positions are
arr[0][2], arr[1][3],arr[2][1]. 
We can’t use arr[i].length to access the last letter as this will give us ArrayIndexOutOfBoundsException (i.e for first row we would get arr[0][3]). The position we want is always one number less than the length of the row. So if we go for first row
int j=arr[0].length-1, which is int j=3-1, j is 2, str[i][j], would be str[0][2]
same process for arr[1] and arr[2]

 
Question 167
Given: 

class Sports { 
int num_players; 
String name, ground_condition; 
Sports(int np, String sname, String sground){ 
num_players = np; 
name = sname; 
ground_condition = sground; 
} 
} 
class Cricket extends Sports { 
//insert code here
int num_umpires; 
int num_substitutes; 
}
Which code fragment can be inserted at line //insert code here to enable the code to compile? 

A. Cricket() { 
     super(11, "Cricket", "Condidtion OK"); 
     num_umpires =3; 
     num_substitutes=2; 
     } 
B. Cricket() { 
     super.ground_condition = "Condition OK"; 
     super.name="Cricket"; 
    super.num_players = 11; 
    num_umpires =3; 
    num_substitutes=2; 
    } 
C. Cricket() { 
     this(3,2); 
     super(11, "Cricket", "Condidtion OK"); 
     } 
     Cricket(int nu, ns) { 
     this.num_umpires =nu; 
     this.num_substitutes=ns; 
     } 
D. Cricket() { 
     this.num_umpires =3; 
     this.num_substitutes=2; 
     super(11, "Cricket", "Condidtion OK"); 
     } 

Answer is A
This calls a super constructor that takes a int, a String and a String, and there is such a constructor in the Sports Super class. 
Answer B is incorrect
There is only a call to the implicit default no argument constructor in the super class in this constructor. There is only one constructor in the super Sports class and that takes an int, String and String



 
Question 168
Given the code fragment: 

public static void main(String[] args) { 
int iArray[] = {65, 68, 69}; 
iArray[2] = iArray[0]; 
iArray[0] = iArray[1]; 
iArray[1] = iArray[2]; 
for (int element : iArray) { 
System.out.print(element + " "); 
} 

A. 68, 65, 69 
B. 68, 65, 65 
C. 65, 68, 65 
D. 65, 68, 69 
E. Compilation fails 

Answer is B
We start off with 
{65, 68, 69}; 
After 
iArray[2] = iArray[0]; 
we have 65,68,65
after 
iArray[0] = iArray[1]; 
we have 68,68,65
after
 iArray[1] = iArray[2]; 
we have 68,65,65

 
Question 169
Given: 

public class FieldInit { 
char c; 
boolean b; 
float f; 
void printAll() { 
System.out.println("c = " + c); 
System.out.println("c = " + b); 
System.out.println("c = " + f); 
} 
public static void main(String[] args) { 
FieldInit f = new FieldInit(); 
f.printAll(); 
} 
} 
What is the result? 

A. c = null 
    b = false 
    f = 0.0F 
B. c = 0 
   b = false 
   f = 0.0f 
C. c = null 
   b = true 
   f = 0.0 
D. c = 
    b = false 
    f = 0.0


Answer D

Answer D is correct. In the exercise, the default values of the variables c, b, f are printed. The default value for a char variable is \u0000, for a Boolean variable is false and for a float variable is 0.0

 
Question 170
Which access modifier makes a member available only to classes within the same package or subclasses?

A) private
B) protected
C) public
D) package-private


Protected Access Modifier
Variables, methods, and constructors, which are declared protected in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class.
The protected access modifier cannot be applied to class and interfaces. Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected.
Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it.

Private Access Modifier 
Methods, variables, and constructors that are declared private can only be accessed within the declared class itself.
Private access modifier is the most restrictive access level. Class and interfaces cannot be private.
Variables that are declared private can be accessed outside the class, if public getter methods are present in the class.
Using the private modifier is the main way that an object encapsulates itself and hides data from the outside world.

Public Access Modifier 
A class, method, constructor, interface, etc. declared public can be accessed from any other class. Therefore, fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java Universe.
However, if the public class we are trying to access is in a different package, then the public class still needs to be imported. Because of class inheritance, all public methods and variables of a class are inherited by its subclasses.

Default Access Modifier
Default access modifier means we do not explicitly declare an access modifier for a class, field, method, etc.
A variable or method declared without any access control modifier is available to any other class in the same package. The fields in an interface are implicitly public static final and the methods in an interface are by default public.
 
Question 171
Given:

 class Java{

	public static void main(String[] args) {

		 int a[] = { 1, 2, 053, 4 };

		int b[][] = { {1,2,4} , {2,2,1}, {0, 43, 2} };

		System.out.print( a[3] == b[0][2] );

		System.out.print(" " + ( a[2] == b[2][1] )  );

	 }
}

Which is the output?


A. true false
B. false false
C. false true
D. true true
E. Compilation fails



Answer is D
Indexing of array elements begin with zero. So [1] refers to the second element of an array. So here a[3] refers to the fourth element of array a. It’s value is 4 and we have assigned 4 to b[0][2]. 
We have assigned octal value to a[2] so the value of element is 43 in decimals. And we have assigned 43 in decimal to b[2][1]. So both will print true
According to above  A, B and C are incorrect. 
E is incorrect as code compiles fine.

 
Question 172
Given

1.   class Test{
2.
3.   public static void main(String[] args){
4.
5.   int []a = {1,2,3,4,5,6};
6.   int i = a.length;
7.
8.      while(i>=1){
9.      System.out.print(a[i]);
10.     i--;
11. }
12. }
13. }

What would be the output, if it is executed as a program?

A. 123456
B. 65432
C. 12345
D. An exception could be thrown at runtime.
E. Compile error.





Length of array “a” is 6, so the value of the variable i is 6. 
Execution of while loop will try to print array element reverse as variable “i” has initial value 6 , So trying to access element with index position 6 will cause ArrayIndexOutOfBoundsException since the array positions start with 0. 
Correct answer is D

 
Question 173
Given:

	String color = "teal";

		switch(color) 
		{
		     case  "Red":
			System.out.println("Found Red");
		     case "Blue":
			System.out.println("Found Blue");
			break;
		     case "Teal":
			System.out.println("Found Teal");
			break;
		     default:
			System.out.println("Found default");
		}


What is the result?

1.Found Red Found Default
2.Found Teal
3.Found Red Found Blue Found Teal
4.Found Red Found Blue Found Teal Found Default
5.Found Default
Answer is E
Found Default


A switch statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case.
Following rules apply to a switch statement :
- variable used in a switch statement can only be integers, convertable integers (byte, short, char), strings(since Java 7) and enums.
- you can have any number of case statements within a switch. Each case is     followed by the value to be compared to and a colon.
- the value for a case must be the same data type as the variable in the switch and  it must be a constant or a literal.
- when the variable being switched on is equal to a case, the statements following that case will execute until a break statement is reached.
- when a break statement is reached, the switch terminates, and the flow of control jumps to the next line following the switch statement.
- not every case needs to contain a break. If no break appears, the flow of control will fall through to subsequent cases until a break is reached.
A switch statement can have an optional default case, which must appear at the end of the switch. The default case can be used for performing a task when none of the cases is true. No break is needed in the default case.

 switch is taking color " teal". There is no case  with color "teal" so default will be printed.
 See the difference between " teal " and " Teal "  
 Answer is : Found default
 Question 184
			teal
 

What is the result?

Found Red Found Default
Found Teal
Found Red Found Blue Found Teal
Found Red Found Blue Found Teal Found Default
Found Defaul


			Red
 

 
Question 174
Given:

public class Test{
	public static void main(String[] args) {
		// line 1					
		
		switch (x) 
		{
		      case 1:      System.out.println("One");
			          break;
		      case 2 :     System.out.println("Two");
			          break;
		}
	}
}	

Which three code fragments can be independently inserted at line nl to enable the code to print one?
  
  	Byte x = 1;
 	short x = 1;
  	String x = "1";
 	Long x = 1;
 	Double x = 1;
	Integer x = new Integer ("1");
 
		
		
 The switch expression must evaluate to a value of following types:
  - Primitive Data Types : 	char, byte, short, int
  - Wrapper Types :		Character, Byte, Short, Integer
  - String Type
  - An Enumerated Type	

  Type of expression switch statement CANNOT be : boolean, long, floating points
 

Answer is : Byte x = 1;
	      short x = 1;
	      Integer x = new Integer ("1");

 
Question 175
Given:


1. class Test{
2. 	public static void main(String args[]){
3.		 int i = 0, j=10;
4. 		try{
5.			 j /=i;
6. 		}
7. 			System.out.print("Divide by Zero! ");
8. 		catch(Exception e){
9. 			System.out.print(“error”);
10.		 }
11.	}
12.}


What is the output?


A. 0
B. 0 Divide by Zero!
C. Divide by Zero! Error
D. Error
E. Compilation fails.
F. An uncaught exception is thrown at runtime.



You can’t enter code between try and catch clause. Here at  line 7 causes the compilation. 
If you remove line 7 then code will compile fine and provide output as error so in that case answer would D
Compilation error at line 7

Answer is E. 




 
Question 176
Given:
 
public class SuperTest {
             public static void main(String[] args) {
                              statement1
                              statement2
                              statement3
             } 
}
 class Shape {
                     public Shape() {
                                 System.out.println(“Shape: constructor”);
                      }
                      public void foo() {
                                 System.out.println(“Shape: foo”);
                       }
 }
 class Square extends Shape {
                        public Square() {
                                super();
                        }
                       public Square(String label) {
                                    System.out.println(“Square: constructor”);
                        }
                        public void foo() {
                             super.foo();
                        }
                       public void foo(String label) {
                                     System.out.println(“Square: foo”);
                       }
 }
 }
 }

What should statement1, statement2, and statement3, be respectively, in order to produce the result?
 Shape: constructor
 Square: foo
 Shape: foo
 
A.	Square square = new Square (“bar”);
square.foo (“bar”);
square.foo();
B.	Square square = new Square (“bar”);
square.foo (“bar”);
square.foo (“bar”);
C.	Square square = new Square ();
square.foo ();
square.foo(bar);
D.	Square square = new Square ();
square.foo ();
square.foo(“bar”);
E	Square square = new Square ();
square.foo ();
square.foo ();
F.	Square square = new Square();
square.foo(“bar”);
square.foo();

Answer is F
Option A is incorrect as the line
Square square = new Square (“bar”);
This calls the constructor in the Square class that takes a string, this then calls the constructor in the base class Shape that takes no arguments, and prints out 
“Shape constructor”
And then control goes back to the square constructor that takes an argument and prints out
“Square constructor”
Option B is incorrect for the same reason as option A
Option C is incorrect, the line 
Square square = new Square ();
Calls the constructor in the Square class that takes no arguments, this in turn calls the constructor in the base Shape class that prints out
“Shape Constructor”
The line
Squre.foo()
Calls the foo method, which in turn calls the foo() method in the super shape class and prints out
“Square foo”
The line
Square.foo(bar) will not compile as this is sending a variable called bar to the foo method, there is NO variable called bar defined in the code
Option D is incorrect as square.foo(), followed by square.foo(“bar”) produces shape:foo and square:foo which is the wrong order
Option E is incorrect as square.foo() and square.foo() will just produce, shape:foo, shape:foo
F is correct as square.foo(“bar”) and square.foo() produces Square:foo and shape:foo which is the correct order

 
Question 177
Given:

class Caller{
	private void init(){
		System.out.println("Initialized");
	}
 	public void start(){
		init();
		System.out.println("Started");
	}
}
public class TestCall{
	public static void main(String[]  args){
		Caller c = new Caller();
		c.start();
		c.init();

What is the result?				
A.	Initialized
Started
B.	Initialized
Started
Initialized
C.	Compilation fails
D.	An exception is thrown at runtime
Answer is C
The class Caller, has a PRIVATE method called init(). That means that this method CANNOT be accessed outside of it’s own class and any attempt to do so will not compile. We can see here that in another class, TestCall, we are trying to access the private method of the class Caller with the line “c.init() which you cannot do.

 
Question 178
Given: 

public class App{
           public static void main (String[]  args){
	int I = 10;
	int j = 20;
	int k = j += i / 5;
	System.out.println( I + ":" + j +":" + k );
           }	
}

What is the result?
 
A.	10 : 22 : 20
B.	10 : 22 : 22
C.	10 : 22 : 6
D.	10 : 30 : 6

Answer is B

I is 10, j is 20
We can rewrite the line int k = j += i / 5; as follows:
Int k=  j = j + i/5
The assignment operator “=” has the lowest precedence of all operators so we do the division part of the equation first.
So we get
K= j= 20 +(10/5)
K=j=20+2
K=j=22
I is 10
J is 22
K is 22


 
Question 179
Given the fragment:

float var1 = ( 12_345.01 >= 123_45.00 )? 12_456 : 124_56.02 ;
float var2 = var1 + 1024;
System.out.println( var2 );

What is the result:

A.	13480.0
B.	13480.02
C.	Compilation fails
D.	An exception is thrown at runtime

Answer is C
All numbers with a decimal place in java are, by default, double. A double is larger than a float so will not fit inside a float, so the line
float var1 = ( 12_345.01 >= 123_45.00 )
will not compile as we are trying to assign a double to a float, which you can’t do for the above mentioned reason



 
Question 180
Given the code fragment:

int [] lst = { 1, 2, 3, 4, 5, 4, 3, 2, 1};
int sum = 0 ;
	for(int frnt = 0, rear = lst.length - 1 ;
		frnt < 5 && rear > = 5;
			frnt++, rear--)
	{
		sum = sum + lst[frnt] + lst[rear] ;
	}
	System.out.println( sum );

What is the result:
A. 20
B. 25
C. 29
D. Compilation fails
F. AnArrayIndexOutOfBoundsException is thrown at runtime.
Answer is A

This loop adds up the first and last elements of an array and then works inwards, 
1	2	3	4	5	4	3	2	1
[0]	[1]	[2]	[3]	[4]	[5]	[6]	[7]	[8]

So the following loop
Sum=sum+lst[frnt]+lst[rear]
Sum=sum+lst[0]+lst[8]
Sum=sum+1+1
Sum=2
Sum=sum+lst[1]+lst[7]
Sum=2+2+2
Sum=6
Sum=sum+lst[2]+lst[6]
Sum=6+3+3
Sum=12
Sum=sum+lst[3]+lst[5]//as its rear>=5
Sum=12+4+4
Sum=20
At this point rear is greater than 5 so our loop exits at this point


 
Question 181
Given:
 
public class TestField {
	 int x;
	 int y;
 	 public void doStuff(int x, int y) {
 		 this.x = x;
 		 y =this.y;
	 }
 	 public void display() {
 		System.out.print(x + ” ” + y + ” : “);
	 }
	 public static void main(String[] args) {
         	      TestField m1 = new TestField();
		 m1.x = 100;
		 m1.y = 200;
      	     TestField m2 = new TestField();
		 m2.doStuff(m1.x, m1.y);
		 m1.display();
		 m2.display();
 
	}
 }
 
What is the result?
 
A.	100 200 : 100 200
B.	100 0 : 100 0 :
C.	100 200 : 100 0 :
D.	100 0 : 100 200 :
Answer is C 
We create a TestField object called m1 and they x variable of this class is given the value 100 and the y variable is given the value of 200
We then create a second TestField object called m2, and the x and y variable are not given any initial values so that means that for now they are given the default value of 0 for both.
The m2 object then calls the doStuff() method which sends to VALUES 100 and 200, as this is the values of the variable m1.x and m1.y, the important point here is that you are only sending VALUES, so if these change inside the doStuff method, m1.x and m1.y are still not changed back in main.
In the do stuff method, the line
This.x=x
Assigns the value 100 to m2.x
The line 
Y=this.y
Only changes the LOCAL VARIABLE Y, so there is no effect back in main
So after this m2 has the values m2.x=100 and m2.y=0, as the y variable of this object has not been given any value so it will take the default value for Y which is 0
So m1.display() prints 100 200:
M2.display() prints 100 0:


Question 182
Which two items can legally be contained within a java class declaration?
 
A.	An import statement
B.	A field declaration
C.	A package declaration
D.	A method declaration

Answer B,D
Imports and package declarations are always placed OUTSIDE a class and are always placed at the top of the file. The package statement has to place before the import and nothing can come before these two statements. You can only have one package statement per file but you can have many imports.

 
Question 183
Given the class definitions:

class Alpha{
	public String doStuff(String msg){
	return msg;
	}
}
class Beta extends Alpha{
	public String doStuff(String msg){
	return msg.replace( 'a', 'e' );
	}
}
class Gamma extends Beta{
	public String doStuff(String msg){
	return msg.substring (2);
}

And the code fragment of the main() method

List<Alpha> strs = new ArrayList<Alpha>();
strs.add(new Alpha())
strs.add(new Beta());
strs.add( new Gamma());
for (Alpha t.strs){
	System.out.println( t.doStuff("Java"));
}

What is the result?
 
A.	Java
Java
Java

B.	Java
Jeve
va

C.	Java
Jeve
ve

D.	Compilation fails
Answer is B

We have added three objects of different types to our arrayList of Alpha objects, we have one Alpha object, one beta Object and one gamma object, as Both beta and gamma extend Alpha then we can add all these objects to an arraylist of reference type Alpah. 
Inside the enhanced for loop, each classes doStuff method is called for each object and the word “java” is sent to each one of these methods. 
The alpha doStuff() method just returns the string “Java”
The Beta doStuff() method replaces all the occurances of “a” with a “e” so this returns “jeve”.
The Gamma doStuff() takes the string “java” and prints out from index position 2 to the end of the string, which is “va”

 
Question 184
Given:
 public class Natural {
                  private int i;
 	void disp() {
	     while (i <= 5) {
                           for (int i=1; i <=5;) {
                                   		System.out.print(i + ” “);
                                   		 i++;
                                   }
                                   i++;
                           }
                        }
                        public static void main(String[] args) {
                                  new Natural().disp();
                        }
 }
 
What is the result?
 
A.	Prints 1 2 3 4 5 once
B.	Prints 1 3 5 once
C.	Prints 1 2 3 4 5 five times
D.	Prints 1 2 3 4 5 six times
E.	Compilation fails
Answer is D
We have a for loop inside a while loop, you also have the private int I field of the Natural class, which is a different variable from the local int variable I in the for loop
So the line
while (i <= 5) 
is dealing with the I field of the Natural class, 
the line
for (int i=1; i <=5;)
creates a local variable I, so that means everywhere inside the for loop where we see I, we are referring to the LOCAL variable I, and everywhere outside of this loop we are referring to the FIELD/INSTANCE VARIABLE i.
the inner for loop executes 5 times and will print out 1,2,3,4,5
the outer while loop starts at 0 (it is using the field I which is given the default value of 0) and goes as far and including 5, which is 6 times. So it prints 1,2,3,4,5 six times

 
Question 185
Which usage represents a valid way of compiling java source file with the name “Main”?
 
A.	javac Main.java
B.	java Main.class
C.	java Main.java
D.	javac Main
E.	java Main

Answer is A
When  you are compiling a source file in java from the command line prompt, the command is javac followed by the full file name plus file extension, so the answer is javac Main.java. This process creates a class file, which is stored usually in the bin folder in each of your projects, as we can in this screenshot
 


 
Question 186
Which of the following data types will allow the following code snippet to compile?

float I = 4;
float j = 2;
____z = i + j;

A.	long
B.	double
C.	int
D.	float
E.	Byte
Answer is B and D
I and j are both floats, so Z then has to be at least a float. A double will also work as a float is smaller than a double and will fit

 
Question 187
Given:

public class Calculator {
	public static void main(String[] args) {
		int num = 5;
		int sum;
				
		do {
			sum += num;
		}
		while( (num--)  >  1 );
				
		System.out.println("The sum is  " + sum + " . ");
	}

}

What is the result?
 
A.	The sum is 2
B.	The sum is 14
C.	The sum is 15
D.	The loop executes infinite times
E.	Compilation fails
The answer is E
Int sum declares an int LOCAL variable, but it does not give it any value.
The line
Sum=+num
Is 
Sum=sum+num
Sum is a local variable and so is not given any initial, as local variables are not given any initial values by default, so this means that the previous line cannot compile as you have the first time you enter the loop
Sum = has no value +num
Which you cannot do
 
Question 188
Given:

public class Test22 {
	int fvar ;
	static int cvar;
public static void main(String[] args) {
		Test22  t = new Test22();
// insert code here to write field variables
}
}
Which code fragments, inserted independently, enable the code compile?
A.	t.fvar = 200;

B.	cvar = 400;

C.	fvar = 200;
cvar = 400;
D.	this.fvar = 200;
this.cvar = 400;

E.	t.fvar = 200;
Test22.cvar = 400;

F.	this.fvar = 200;
Test22.cvar = 400;
Answer is A,B,E
You can’t use the keyword “this” inside a static method, any time you try to access a field/instance variable you are implicitly using “this” even if you don’t actually have it in your code. 
Remember statics are CLASS variables, so not every instance of class has its own copy For example
Class Dog{
Int age=23;
Void eat(){
System.out.println(this.age)
//is exactly the same as 
System.out.println(age)
A is correct, t.fvar will compile as we are using the variable t to access the field fvar
B is correct, cvar will compile as a static method CAN access a static variable of class directly, and we are in main which is a static method.
C is incorrect as we cannot directly access the field fvar from inside a static method
D is incorrect as we can’t use “this” inside a static method
E is correct as t.fvar is accessing the fvar field through the t object and Test22.cvar is accessing the static variable cvar in a static way, which is class name. followed by static method name
F is incorrect as you cannot use “this” in a static method
 
Question 189
Given:
public class CharToStr {
	public static void main(String[] args) {
		String str1 = "Java";
		char str2 [] = { 'J', 'a', 'v', 'a' };
		String str3 = null ;
		for ( char c : str2 ) {
			str3  = str3 + c ;
		}
		if (str1 .equals( str3))
			System.out.println("Successful");
		else 
			System.out.println("Unsuccessful");
	}
}

What is result?
 
A.	Successful
B.	Unsuccessful
C.	Compilation fails
D 	An exception is thrown at runtime

Answer is B
Str3 is null, so if we just printed out str3, the printout would read “null”. So the enhanced for loop is using the character c to go through the character array called str2, which contains “J”,”A”,”V”,”A”
So the line str3=str3+c is doing the following when the loop executes
NullJ
nullJA
nullJAV
nullJAVA
and the if is checking if
if(st1.equals(str3))
which is asking the question
if (java is the same as nulljava) and it is not, so it goes to the else part of the if statement and prints
unsucessful






 
 
	
	
	
	
	


Question 190
Given the following four Java file definitions:
 
// Foo.java
 package facades;
 public interface Foo { }
 
// Boo.java
 package facades;
 public interface Boo extends Foo { }
 
// Woofy.java 
 package org.domain
 // line n1
public class Woofy implements Boo, Foo { }
 
// Test.java
 package.org;
//line n2
 public class Test {
 public static void main(String[] args) {
 Foo obj=new Woofy();
 
Which set modifications enable the code to compile and run?
 
A.	At line n1, Insert: import facades; At line n2, insert:import facades;import org.domain;
B.	At line n1, Insert: import facades.*; At line n2, insert:import facades;import org.*;
C.	At line n1, Insert: import facades.*; At line n2, insert:import facades.Boo;import org.*;
D.	At line n1, Insert: import facades.Foo, Boo; At line n2, insert:import org.domain.Woofy;
E.	At line n1, Insert: import facades.*; 
At line n2, insert:import facades.*;import org.domain.Woofy;

Answer is E
Import facades.* will import all the classes and interfaces contained in this particular package, but NOT the sub packages. Both Foo and Boo are contained in the facades package, so one  importing all from this package will make both classes accessible. To access the Woofy class we can either import just the class or import all from the package.org.domain
The import keyword can import a category or interface, not a package (pa c kage), so option A is wrong.
And option B and option C , it is important to note that "*" refers to all categories or interfaces under the package and does not contain subprograms. This is importing all from the org package, but not from the sub package org.domain
Option D, the syntax is wrong, can not use "," to introduce different categories.
Option E is correct, this is importing all classes and interfaces from the facades.* package and also importing the class woofy

Question 191
Given:
 
Class A { }
 
Class B { }
 
Interface X { }
 
Interface Y { }
 
Which two definitions of class C are valid?
A.	Class C extends A implements X { }
B.	Class C implements Y extends B { }
C.	Class C extends A, B { }
D.	Class C implements X, Y extends B { }
E.	Class C extends B implements X, Y { }
Answer is A,E
A class extends another class, a class implements an interface. Multiple inheritance is not allowed in java, so you can only extend one class. A class can implement many interfaces, extends comes before implements. An interface extends an interface, an interface cannot implement anything.
 
Question 192
Given:

public class TestTry {
public static void main(String[] args) {
        StringBuilder message = new StringBuilder("hello java!");
        int pos = 0;
        try {
            for (pos = 0; pos < 12; pos++) {
                switch (message.charAt(pos)) {
                    case 'a':
                    case 'e':
                    case 'o':
                        String uc = Character.toString(message.charAt(pos)).toUpperCase();
                        message.replace(pos, pos + 1, uc);
                }
            }
        } 
        catch (Exception e) {
            System.out.println("Out of limits");
        }
        System.out.println(message);
    }
}


What is the result?
 
A.	hEllOjAvA!
B.	hello java!
C.	Out of limits
	hEllOjAvA!
D.	Out of limits

Answer is C
Pos is 0 and we are going to use this as a counter to go through our StringBuilder object message, which contains the message “hello java!”, which is of length 11, so numbering goes from 0 to 10. 
Our for loop goes from 0 to 12 so we know this will generate a StringindexOutOfBoundsException when I gets to index
position 11 as this does not exist, however this is not generated until pos gets to 11. So the loop will still execute 11 times,
which is the length of the StringBuilder object message. We have a switch statement inside the for loop, that checks 
the character at each position in the string, if that character is ‘a’,’e’ or ‘o’ then that character is replaced with the uppercase 
version
replace method of the StringBuilder class takes three arguments, start position index, end position index, string replacement

Question 193
Given the code fragment:
 
StringBuilder sb = new StringBuilder ( ) ;
 sb.append (“world”);
 
Which code fragment prints Hello world?
 
A.	sb.insert(0,”Hello “);
System.out.println(sb);
B.	sb.append(0,”Hello “);
System.out.println(sb);
C.	sb.add(0,”Hello “);
System.out.println(sb);
D.	sb.set(0,”Hello “);
System.out.println(sb);D

Answer is A
Option A is correct at this inserts “Hello “ at position 0 in our stringBuilder object, which is the first position
Option B is incorrect as there is no append()method that takes more than one argument
Option C is incorrect as there is no add method in the StringBuidler class
Option D is incorrect at there is no set method in the StringBuilder class
 
Question 194
Given:

	int x = 10;
	if(x > 10) {
		System.out.println(">");
	}
	else if ( x < 10 ) {
		System.out.println("<");
	}
	else {
		System.out.println("=");
	}


Which of the following is equivalent to the above code fragment?
 
A.	System.out.printLn(x>10?”>,’: “<“:,’=”);
B.	System.out.println( x > 10  ?   “>”  ?  ”<“  :  ”=”  );
C.	System.out.println(x>10?”>”:x<10?”<“:”=”);
D.	System.out.printLn(x>10?”>”?,'<“?”=”);
E.	None of the above

Answer is C

Option A is incorrect as (there is also typos in this one) as this does not give an option for x being 10
Option B is incorrect as you can use a ternary operator inside a ternary operator, but you have to test for some other condition and you have to use colons :
Option C is correct as if our number is 10 the first part of the ternary construct is skipped and it goes to the second ternary construct which is the SECOND argument of the first ternary construct, number is not less than 10, so it goes to the last argument which is the equals “=” sign
Option D is incorrect as the second ternary operator is not checking for anything and there is no colons “:” separating the arguments



 
Question 195
Given:
   public class Test3 {
	public static void main(String[] args) {
	        String names[] = new String[3];
	        names[0] = "Mary Brown";
	        names[1] = "Nancy Red";
	        names[2] = "Jessy Orange";
	        try {
	            for (String n : names) {
	                try {
	                    String pwd = n.substring(0, 3) + n.substring(6, 10);
	                    System.out.println(pwd);
	                } catch (StringIndexOutOfBoundsException sie) {
	                    System.out.println("String out of limits");
	                }
	            }
	        } catch (ArrayIndexOutOfBoundsException e) {
	            System.out.println("Array out of limits");
	        }
	    }
	}
What is the result?
 
A.	Marrown
String out of limits
JesOran
B.	Marrown
String out of limits
Array out of limits
C.	Marrown
String out of limits
D.	Marrown
NanRed
JesOran

Answer is A
We have a try/catch block inside the try block which is allowed as any structure in java can be inside any other structure. We are using the String n to iterate through a array of names, which are “Mary Brown”, and length 10, “Nancy Red”, and length, 9, and “Jessy Orange, which is of length 12. 
The line
String pwd = n.substring(0, 3) + n.substring(6, 10);
Gets a substring of each of the names, which is made up of two substrings. As an example we take the String “Mary Brown”. First n.substring(0,3) gets us a substring from position 0 UP TO but not including position 3, this gives us “Mar”, then n.substring(6,10) gets us a substring from position 6 UP TO but not including position 10, this gives us “Rown”. Combining the two strings gives us “MarROwn”. Each iteration of the loop is inside it’s OWN try/catch block, so if a an StringIndexOutOfBoundsException is for any of the strings, this will catch the exception and the loop will continue onto the next string in the list.
This Process is then repeated for all of the strings in our list, however the string “Nancy Red” is only of length 9, so for this string a StringIndexOutOfBoundsException is generated and caught, and the message "String out of limits" is displayed. 
For the last string the message “JesOran” is generated 
 
Question 196
Given:
public class Vowel {
     private char var;
     public static void main(String[] args) {
        char var1 = 'a';
        char var2 = var1;
        var2 = 'e';
        Vowel obj1 = new Vowel();
        Vowel obj2 = obj1;
        obj1.var = 'i';
        obj2.var = 'o';
        System.out.println(var1 + ", " + var2);
        System.out.println(obj1.var + ", " + obj2.var);
    }
}
What is the result:
A.	a, e
i, o

B.	a, e
o, o

C.	e, e
I, o
D.	e,e

Answer is B
Var1 refers to the character ‘a’ and Var2 refers to the character ‘e’. 
Obj1 and Obj2 refer to the same object as this line
Vowel obj2 = obj1;
Assigns obj1 to obj2 so this means that both are pointing to the same object, and than means that obj1 and obj2 are THE SAME object. So with this line
obj1.var = 'i';
you are changing the value of obj1.var AND obj2.var, as this is the same object, similarily
obj2.var = 'o';
you are changing the value of obj1.var AND obj2.var, as this is the same object.
This all means that the answer is B
a,e
o,0


 
Question 197
Given:
 
public class TestOperator {
 public static void main(String[] args) {
 int result = 30 -12 / (2*5)+1;
 System.out.print(“Result = ” + result);
 }
 }
 
What is the result?
A.	Result = 2
B.	Result = 3
C.	Result = 28
D.	Result = 29
E.	Result = 30

Answer is E

Brackets come first so we have
30-12/10+1
Multiplication and division before addition and subtraction and it’s integer division so no decimal points so 12/10 will be 1
30-1+1
30
 
Question 198
Given:
 
class MarksOutOfBoundsException extends IndexOutOfBoundsException { }
public class GradingProcess {
 	void verify(int marks) throws IndexOutOfBoundsException {
	 if (marks > 100) {
		 throw new MarksOutOfBoundsException();
	 }
	 if (marks > 50) {
		 System.out.print(“Pass”);
	 } else {
		 System.out.print(“Fail”);
	 } 
}
public static void main(String[] args) {
int marks = Integer.parseInt(args[2]);
 	try {
		 new GradingProcess().verify(marks));
	 } 
	catch(Exception e) {
		 System.out.print(e.getClass());
 
	}
 }
}
 
And the command line invocation:
 Java GradingProcess 89 50 104
 
What is the result?
A.	Pass
B.	Fail
C.	Class MarksOutOfBoundsException
D.	Class IndexOutOfBoundsException
E.	Class Exception

Answer is C
The line Java GradingProcess 89 50 104, runs the program and passes in our three numbers into the string array called args in the main. So in args we have
Args[0]=”89”
Args[1]=”50”
Args[2]=”104”
The line
int marks = Integer.parseInt(args[2]);
takes the string “104” and converts it to an int and assigns it to the variable marks.
A new GradingProccess object is created and the verify(marks) method is called and 104 is sent to this method.
104 is greater than 100 so a new MarksOutOfBoundsException() is thrown, MarkOutOfBoundsException extends IndexOutOfBoundsException which means that the method signature can throw out the this exception as it can throw out an IndexOutOfBoundsException or a subclass of this exception.. 
Back in main the exception generated by the verify method is caught by the catch block, as this can catch exception or any subclass of exception, which means it can catch ANY exception.
In the catch block it then gets the class of the generated exception and prints it out, which is 
Class MarksOutOfBoundsException 
 
Question 199
Given the code fragment:

class Student{
    String name;
    Int age;
}
public class Test{
    public static void  main(String[]  args){
       Student s1 = new Student();//1
     Student s2 = new Student();//2
       Student s3 = new Student();//3
	s1 = s3;		//5
	s3 = s2;		//6
	s2 = s2;		//7
	s2 = null;		//8
    }			//9
}			//10
Which statement is true?
A.	After line 8, three objects are eligible for garbage collection
B.	After line 8, two objects are eligible for garbage collection
C.	After line 8, one object is eligible for garbage collection
D.	After line 8, none of the objects are eligible for garbage collection

Answer is C
If an object can no longer be accessed then it is liable for garbage collection. 
Student s1=object x
Student s2=object y
Student s3 = object z
S1=s3
Means that we can access object z through both S1 and S3
S3=s2
Means that we can access object y through S3 and S2
S2=S2 just reassigns the object y to s2
S2=null means we can no longer acess object y through S2 but we ca access object Y through S3.
So at the end we canot access the X object, so this is liable for garbage collect
We can access the Y object through S3
We can access the Z object through S1

 
Question 200
Given:

               public class Test222 {
	 public static void main(String[] args) {
	        int numbers[];
	        numbers = new int[2];
	        numbers[0] = 10;
	        numbers[1] = 20;
	 
	        numbers = new int[4];
	        numbers[2] = 30;
	        numbers[3] = 40;
	        for(int x : numbers){
	            System.out.print(" " + x);
	        }
	    }
	}
What is the result?
A. 10 20 30 40
B. 0 0 30 40
C. Compilation Fails
D. An exception is thrown at runtime
Answer is B
We first assign an array of length 2 to numbers, and populate it with the int values 10 and 20. We then assign a new array to numbers, which means the previous values are now overwritten by this new array of four ints, and each position in the array has a default value of 0. We then assign values to the third and fourth position of this array. We then end up with an array that looks like the following:
Numbers={0,0,30,40}
 
Question 201
Given:

class Star {
	 public void doStuff() {
        System.out.println("Twinkling Star");
    }
}
 interface Universe {
	 public void doStuff();
}
class Sun extends Star implements Universe {
	public void doStuff() {
        System.out.println("Shining Sun");
    }
}
 public class Bob {
	 public static void main(String[] args) {
        Sun obj2 = new Sun();
        Star obj3 = obj2;
        ((Sun) obj3).doStuff();
        ((Star) obj2).doStuff();
        ((Universe) obj2).doStuff();
    }
}
What is the result?
A.	Shining Sun
Shining Sun
Shining Sun

B.	Shining Sun
Twinkling Star
Shining Sun

C.	Compilation fails

D.	A ClassCastException is thrown at runtime

The Answer is A
Both obj2 and obj3 are SUN objects, and doStuff() is overridden in the sun class, which means it first exists in the Star class which is  super class of Sun. so it does not matter if you cast it to be of type Sun or Star, as this only changes the reference to the object and it will still takes it’s implementation from the Sun class so
((Sun) obj3).doStuff();
        ((Star) obj2).doStuff();
Both produce Shining sun
Obj2 is a Sun object which does implement the Universe interface and you can have a interface reference to a class that implements the interface, which is what we have with the following code:
((Universe) obj2).doStuff();
This will also produce “Shining Sun”
It is important to note that when you are casting anything, you are not changing the object (right hand side of an assignment) but the reference (left hand side of assignment) i.e Animal anDog=new Dog();
 
 
Question 202
import java.util.Random;            //1
import java.lang.System;            //2   
import java.util.*;                 //3
import java.lang.*;                 //4  

public class MyExamCloudOCAJP8 {
	
	public static void main(String[] args) {
		Random r = new Random();
		System.out.println(r.nextInt(10));
	}

}
Which lines contains redundant imports that are not necessary for this code to compile?(Select one answer).
A. lines 1 and 2.
B. lines 1, 2 and 3.
C. lines 2,3 and 4.
D. lines 1, 3 and 4.
E. All.
Answer is C
Explanation: After the import in line 1 the code will compile and run without any additional imports. Therefore lines 2,3, and 4 are redundant imports.
Java.util.Random will import the Random class, so then we can create a Random object.
Java.lang.System class has many methods to deal with input and output amongst other methods, nothing to do with Random and we don’t use any classes or static methods from this class
Java.util.* will import all the classes of the java.util package, but we have already imported the Random class so this import is also redundant
Java.lang.* is already imported by default whenever you create any application, for instance the Object class is contained in the java.lang package














 
Question 203
Given:
public class MyExamCloudOCAJP8 {
	public static void main(String[] args) {
		int x=3;
		int y = ++x * 4 / x-- + --x;
		System.out.println("y + x is "+ (y+x));	
	}

}
What is the output? (Select one answer).
A. y + x is 7
B. y + x is 10
C. y + x is 9
D. y + x is 8
E. Compilation fails.
Answer is D
Explanation:
The rules for order of precedence and the use of pre and post increments and decrements mean that y= 4*4/4+2 which using BOMDAS evaluates to ((16/4)+2) => (4+2) = 6.
So y is 6 and since the increment and decrement operators used on x in the declaration of y effect the original x value that value is now 2 (From: ++x=4, x--=3, --x=2).
So the answer is 6+2, so y+x=8.
















 
Question 204
Which of the following is true about java source code files? (Select one answer).
A. Each source file can contain only one class.
B. The file name must match the class name including case, and have a java extension.
C. Each source file can contain only one public class.
D. All of the above.
E. None of the above.
Answer is C.

Explanation:
Source files can contain many classes. 
The file name must only match the name of the public class, if there is one.
There can only be one public class in a source file and the name of the public class much the file name.





















 
Question 205
Which of the following is a valid identifier? (Select one answer).
A. 2DPoint
B. $ocajp
C. new
D. java@elabs
E. $*coffee
Answer is B. 
An identifier is a name assigned to a variable. 
An identifier cannot start with a number. (e.g. 2Dpoint)
An identifier cannot be the same as a java keyword (e.g. new)
An identifier cannot contain the @ symbol
An identifier cannot contain a mathematical operator (e.g.+-*/=)





















 
Question 206
Given:
public class MyExamCloudOCAJP8 {
	static int y =10;
	
	public static void main(String[] args) {
		int y;
		System.out.println(y+MyExamCloudOCAJP8.y);	
	}
}
What is the output? (Select one answer).
A. 10
B. 11
C. 20
D. NullPointerException
E. Compilation error

Answer is E.
Explanation:
The int y inside the main method is a local variable to that method. Attempting to use the local variable(such as in the sysout) before it is initialized gives a compilation error.


 
Question 207


public class MyExamCloudOCAJP8 {


static int y = 10;


public static void main(String [] args){


int y;


System.out.println(y+MyExamCloudOCAJP8.y);
}
}



What is the output?


•	Choice A: 10
•	Choice B: 11
•	Choice C: 20
•	Choice D: NullPointException
•	Choice E: Compilation error.


Answer E: The local variable y has not been initialized.




 
Question 208



1. import java.time.LocalDate;
2. import java.time.Period;
3.
4. public class MyExamCloudOCAJP8 {
5. public static void main(String [] args){
6. LocalDate date = LocalDate.of(2015, 3, 24);
7. Period p = Period.ofDays(2);
8. System.out.println(date.plus(p));
9. }
10. }


What is the output?


•	Choice A:  2015-04-26
•	Choice B:  2015-03-26
•	Choice C: 2015-02-27
•	Choice D: Compilation fails due to error at line 6
•	Choice E:  Compilation fails due to error at line 8


Answer:  B
Date is a date of 24th of March, 2015 and we then create a period of 2 days with the command
 Period p = Period.ofDays(2);
We then add this period onto our date which will give us the 26th of March, 2015 or Choice b


 
Question 209


Which of the following methods can be included in an interface?


•	A: static void print(){System.out.println(“interface”);}
•	B: static abstract void print();
•	C: default abstract void print();
•	D: default String toString(){ return “a”;}
•	E: None of the above.


Answer: A
A is correct as a static method in an iterface has to have a body
B is incorrect as a method in an interface can’t be static and abstract. Also if it was just an abstract method it would have no body
C is incorrect as a method can’t be default and abstract, as a default method has to have a body and a abstract method can’t have a body
D is incorrect as you can’t override a method from the object class in an interface, toString is a method of the object class
E is incorrect as A is correct


 
Question 210
Given
package epractizelabs;
public class A {
protected int y=15;
}
package elab;
import epractizelabs.A:
public class B extends A{
int y=10;
public void print() {
	A a = new A();
	System.out.println(a.y+y);
}
public static void main(String[]args){
B b=new B();
b.print();
}}
What will be output
A 15
B 25
C NullPointerException thrown
D 10
E File will not compile

Answer : the file will not compile - the protected variable of a class A (int y) is visible to its subclasses, but only through objects of the subclass’s type or its subtypes. A subclass can see a protected variable of its superclass as an inherited variable, but it can’t access that same variable via a reference to the superclass itself. The caller's (Object a is class A instance) is not defined in the same package (package elab) so can't access the protected variable. 
 
Question 211
Given: 

public class MyClass { 
public static void main(String[] args) { 
       while (int ii = 0; ii < 2) { 
ii++; 
System.out.println("ii = " + ii); 
       } 
                  } 
} 
What is the result?
A. ii = 1 ii = 2 
B. Compilation fails 
C. The program prints nothing 
D. The program goes into an infinite loop with no output 
E. The program goes to an infinite loop outputting: ii = 1 ii = 1 

Answer is B
A while loops condition has to evaluate to a Boolean the line
while (int ii = 0; ii < 2)
Does not evaulage to true or false so this will not compile 
Question 212
public interface A<R> extends B{
static void method(){
} 
}
public interface B<T>{
public void print(T t);
static void print(){
} 
}
public interface C {
void methodC (String s);
}
public interface D <T> extends A,B,C {
default void printer (T t){
}  
}
How many functional interfaces are they in this code
A none
B 2
C 1
D 3
E 4
Functional interfaces provide target types for lambda expressions and method references. Each functional interface has a single abstract method, called the functional method for that functional interface, to which the lambda expression's parameter and return types are matched or adapted. Functional interfaces can provide a target type in multiple contexts, such as assignment context, method invocation, or cast context.
An interface can inherit from multiple interfaces (multiple inheritance is not allowed in Java, but multiple implementation of interfaces IS allowed, an interface can’t implement an interface so it uses the extends keyword instead.
Inteface D extends A,B and C so that means it also inherits all of the abstract methods contained in those interfaces. There is a abstract method in B and a abstract method in C. Which means that C now has TWO abstract method and a function method can only contain ONE abstract method.
B and C both contain only ONE abstact method which means they are functional interfaces
A has no abstract method, however A extends B and B has a abstract method so that means that A also has ONE abstract method which means that A is also a functional interface
Answer A: NOT CORRECT  - there are 3 interfaces that can be considered as functional
Answer B: Correct – there are 3 interfaces that can be considered as functional

Answer C: NOT CORRECT -  there are 3 interfaces that can be considered as functional
Answer D: CORRECT - Interface A extends B (which means inherits abstract method void print(T t) from B interface), Interface B contains one abstract method void print(T t) , interface C contains one abstract method 
methodC(String s)
Answer E: NOT CORRECT - interface D extends A,B,C so it inherits two abstract methods from interface B and C
 
Question 213
Given this code:

Collection<String> coll = new ArrayList<>();
coll.add("Fred"); coll.add("Jim"); coll.add("Sheila");
System.out.println("coll is " + coll);
coll.remove(0);			 // line n1
System.out.println("coll is " + coll);


What is the result? Choose one.

a. coll is [Fred, Jim, Sheila]
    coll is [Jim, Sheila]

b. coll is [Fred, Jim, Sheila]
    coll is [Fred, Jim, Sheila]

c. Compilation fails at line n1.

d. An exception is thrown at line n1.
Answer is B
Collection is a super interface of the List interface, and Arraylist implements the list interface, which means it also implements the Collection interface. So we can have a Collection reference to a ArrayList object
The remove method here will return true if it finds in the list what is sent to it, in this case the integer 0, so this will return false and not change our list. So it will print out the same list order twice. List has its own toString() method which will print out the contents of a list.
 
Question 214
I.Functional interface should contain only one method.
II.Functional interface should contain only one method and it shoulb be an abstract method .
III.Functional interface can have more than one method.
Which of the following is true
A I
B I II
C I III
D III
E I II III 

Answer is D
A functional interface is an interface that can be used to create lambdas. This interface can contain only ONE ABSTRACT method, however it can contain other default and static methods. Default and static methods were introduced in Java 8






 
Question 215


public class A {
int y;
public A(int x){
x = y;
}
public void print(){
System.out.println(y);
}
}
public class B extends A{
//Constructor goes here
}
Which of the following can be a constructor for class B?


A: public B(){super();}
B: public B(int x){this(x);}
           C: public B(int x){System.out.println(x);super(x);
D: public B(int x){super(x);}
E: public A(){ super();}


Answer: D

Answer A is wrong because there is no constructor in the A class that takes no arguments
Answer B is wrong as there is no constructor in the B class that takes an int, and also there has to be a call to a super constructor of the A class
Answer C is wrong as the call to the super class constructor has to be the line of code in a sub classes constructors
Answer D is correct as we are calling the super B class constructor that takes an int
Answer E is incorrect as there is no constructor in the Super class that takes no arguments

 
Question 216
Given:
public class TestOperator {
 
    public static void main(String[] args) {
        int result = 30 - 12 / (2 * 5) + 1;
        System.out.print("Result = " + result);
    }
}
What is the result?
A.  Result = 2
B. Result = 3
C. Result = 28
D. Result = 29
E. Result = 30
Answer is E

Explanation:
Points to remember:
1. The operators order of precedence BOMDAS.
2. Integer division (decimals are always rounded down).
So what happens is:
30 - 12 / (2 * 5) + 1
=30-12/10+1    
= 30-1+1 = 30 // the result of 12/10 is rounded to 1 when dividing ints.












 
Question 217
Given:
class Star {
    public void doStuff() {
        System.out.println("Twinkling Star");
    }
}
 
interface Universe {
 
    public void doStuff();
}
 
class Sun extends Star implements Universe {
 
    public void doStuff() {
        System.out.println("Shining Sun");
    }
}
 
public class Bob {
 
    public static void main(String[] args) {
        Sun obj2 = new Sun();
        Star obj3 = obj2;
        ((Sun) obj3).doStuff();
        ((Star) obj2).doStuff();
        ((Universe) obj2).doStuff();
    }
}

What is the result?
A. Shining Sun
     Shining Sun
     Shining Sun
B. Shining Sun
     Twinkling Star
     Shining Sun
C. Compilation fails
D. A ClassCastException is thrown at runtime.
Answer is A
Explanation:
Only 1 object is created. It is a Sun Object created in the line Sun obj2 = new Sun();
This means that the method implementation will be taken from the Sun Class. 
The reference will determine which methods the object can access but as there is a doStuff method defined in the Sun and Star classes, as well as in the Universe interface, the casting to these references will not prevent access to this method. And the implementation taken from the Sun class each time as it is a Sun Object. So the answer is A.
 
Question 218
Given:
public class Test {
    public static void main(String[] args) {
        int arr[] = new int[4];
        arr[0] = 1;
        arr[1] = 2;
        arr[2] = 4;
        arr[3] = 5;
        int sum = 0;
        try {
            for (int pos = 0; pos <= 4; pos++) {
                sum = sum + arr[pos];
            }
        } catch (Exception e) {
            System.out.println("Invalid index");
        }
        System.out.println(sum);
    }
}

What is the result?
A. 12
B.  Invalid index
     12
C. Invalid index
D. Compilation fails

Answer is B
Explanation:
The values of the pos variable in the for loop are 0,1,2,3,4 as the loop specified <=4 rather than just <4. When the pos variable is 4, the line 
sum = sum + arr[pos];
Will throw an ArrayIndexOutOfBoundsException as the index 4 would be the 5th element and the array length is only 4. 
This exception will be caught by the catch so the program will first print “Invalid index” and then the output of sum which is (1+2+4+5) = 12. 
So the answer is B.










 
Question 219
Given:
public static void main(String[] args) {
    List colors = new ArrayList();
    colors.add("green");
    colors.add("red");
    colors.add("blue");
    colors.add("yellow");
    colors.remove(2);
    colors.add(3, "cyan");
    System.out.print(colors);
}
What is the result?

A. [green, red, yellow, cyan]
B. [green, blue, yellow, cyan]
C. [green, red, cyan, yellow]
D. An IndexOutOfBoundsException is thrown at runtime

Answer is A

Explanation:
The colors.remove(2); method removes the string “blue” from the colors ArrayList. At this point the elements of the ArrayList are [green, red, yellow].
The next line colors.add(3, “cyan”); adds the string “cyan” to the location of index 3, which is the next position after the string “yellow”. In this case the new values of the elements in the ArrayList are [green, red, yellow, cyan], which is option A.





















 
Question 220
Given:
public class Test2 {
    public static void main(String[] args) {
        int ar1[] = {2, 4, 6, 8};
        int ar2[] = {1, 3, 5, 7, 9};
        ar2 = ar1;
        for (int e2 : ar2) {
            System.out.print(" " + e2);
        }
    }
}

What is the result?

A. 2 4 6 8
B. 2 4 6 8 9
C. 1 3 5 7
D. 1 3 5 7 9

Answer is A

Explanation:
The line  ar2 = ar1; means that now both ar2 and ar1 refer to the array originally defined when initializing ar1[] .
The enhanced for loop then iterates through each int contained in the array and prints out the int value for each one. So the elements of the original array arr1 are printed out, meaning the answer is A.

 
Question 221
You are writing a method that is declared not to return a value. Which two are permitted in the method body?
A.      Omission of the return statement
B.      return;
C.      return null;
D.      return void;
Correct answers: A and B
Explanation: Any method declared void doesn't return a value. It does not need to contain a return statement, but it may do so. In such a case, a return statement can be used to exit the method and is simply used like this:
                return;
 
 
Question 222
Which three are valid types for switch?
A.      int
B.      float
C.      double
D.      Integer
E.       String
F.       Float
Correct answers: A,D and E
Explanation: A switch works with the byte, short, char, and int primitive data types. It also works with enumerated types,the String class, and a few special classes that wrap certain primitive types: Character, Byte, Short, and Integer.
 
 
Question 223
 
Which declaration initializes a boolean variable?
 
A.      boolean h=1;
B.      boolean k=0;
C.      boolean m = null;
D.      boolean j =(1<5);
 
Correct answers: D
 
Explanation: The primitive type boolean has only two possible values: true and false. Here j is set to (1 <5), which evaluates to true
 


 
 
Question 224
 
What will the following program snippet print?
  
                Int i=0,j=11;
do{
                if(i>j){break;}
                j--;
}while(++i<5)
System.out.println(i+” “+j);	

A 11 0
B 0 11
C 6 5
D 6 6
E 5 6

 
Correct Answer: 5 6
 
Explanation: The loop iterates until i and j are left with the values 5 and 6

 
Question 225
String color = "teal";
switch(color){
case "Red":
System.out.println("Found Red");
case "Blue":
System.out.println("Found Blue");
break;
case "Teal":
System.out.println("Found Teal");
break;
default :
System.out.println("Found Default");
}
Answer 1. NOT CORRECT - Found Red Default
Answer 2. NOT CORRECT - Found Teal
Answer 3. NOT CORRECT - Found Red Found Blue Found Teal
Answer 4. CORRECT - Found Default - variable String color = "teal" is lowercase , so it CAN NOT apply to case "Teal" - uppercase, only default option is avaialble in this case , which is at the end of switch statement
 
Question 226
public class MyClass{
public static void main(String [] args){
String s  = " Java Duke ";
int len = s.trim().length();
System.out.println(len);
}
}
Answer A. NOT CORRECT -8
Answer B. CORRECT - 9 - String s initial length is 11, but because string is trimmed (using trim() method which removes trailing spaces in front and at the end of given string)  itreturns value of 9 and asssigns this value to int len.
Answer C. NOT CORRECT - 11
Answer D. NOT CORRECT - 10
Answer E. NOT CORRECT - Compilation Fails
 
Question 227
Which is/are true?
I.Scope of a local variable is lesser than scope of an instance variable.
II.The instance variables are only visible to the methods in which they are declared.
III.The variable "i" in the declaration "int i = 12;" should be an instance variable
Answer A.  CORRECT - Only I - scope of the local variable is limited to a method/ expression 
A.	Only I is corect
B.	Only II is correct
C.	Only I and ii is correct
D.	Only I and iii
E.	None are correct
Answer A.  CORRECT - Only I - scope of the local variable is limited to a method/ expression 
within curly braces {} , scope of a instance variable is wider  = but limited by access modifier (private, default, protected or public)
Answer B. NOT CORRECT - Only II  - instance variables are class object's  variables, belongs to an object, not methods and their visibilty is determined by access modifiers
Answer C. NOT CORRECT - Only I and II
Answer D. NOT CORRECT - Only I and III - this declaration is taken out of full context - it can be an instance variable, a local variable , or can belong to expression/statement within it is declared (loop, switch etc.)
Answer E. NOT CORRECT - None
 
Question 228
interface Pet{
}
class Dog implements Pet{
}
public class Beagle extends Dog{
}
Which lines of code will compile and run?
Answer A. CORRECT - Pet a = new Dog();
Answer B. NOT CORRECT - Pet b = new Pet();
Answer C. NOT CORRECT - Dog f = new Pet();
Answer D. CORRECT - Dog d = new Beagle();
Answer E. CORRECT - Pet e = new Beagle();
Answer F. NOT CORRECT - Beagle c = new Dog();
 
Answer A is correct because a Dog can me a Pet.
Answer D is correct because the class Beagle inherits from class Dog, so any Beagle is a Dog.
Answer E is correct because the class Beagle inherits from class Dog and Class Dog implements the Interface Pet, so any object of the class Beagle can implements the Interface Pet.


 
Question 229
Which two statements  correctly describe checked exception
These are exceptional conditions that a well-written application should anticipate and recover from - 
These are exceptional conditions that are external to the application , and that the application usually can not anticipate or recover from.
These are exceptional conditons that are internal to the application , and that the application usually can not anticipate or recover from.
Every class  that is a subclass of Exception, excluding RuntimeException and its subclasses, is categorized as checked exceptions - Exception class has only two direct subclasses  - RuntimeException and IOException

 
Question 230
Given the code fragment:
int[][] array2d = new int[2][3];
System.out.println(“Loading the data.”);
for(int x = 0; x < array2d.length;x++){
for (int y = 0; y < array2d[0].length; y++){
System.out.println(“x= “+x);
System.out.println(“x= “+x);
//insert load statement here
}
}
System.out.println(“Modify the data. “);
for(int x = 0; x < array2d.length; x++){
for(int y = 0; y < array2d[0].length; y++){
System.out.println(“x= “+x);
System.out.println(“x= “+x);
//insert Modify statement here
}
}
Which pair of load and modify statements should be inserted into the code? 
The load statement should set the array’s x row and y column value to the sum of x and y.
The modify statement should modify the array’s x row and y column value by multiplying it by 2.
A.	Load statement: array2d(x,y) = x + y;
Modify statement: array2d(x,y) = array2d(x,y)*2;
       B. Load statement: array2d[x,y] = x + y;
Modify statement: array2d[x,y] = array2d[x y]*2;
       C. Load statement: array2d[x,y] = x + y;
Modify statement: array2d[x,y] = array2d[x,y]*2;
       D Load statement: array2d[x][y] = x + y;
Modify statement: array2d[x][y] = array2d[x][y]*2;
        E Load statement: array2d[[x][y]] = x + y;
Modify statement: array2d[[x][y]] = array2d[[x][y]]*2;


Answer is D - This question is about the use of brackets.
A is wrong - The left hand side must be a variable.
B is wrong - Cannot convert int to int[]
C is wrong - Cannot convert int to int[]
E is wrong - Too many brackets.


 
Question 231
Given:
public class SuperTest {
public static void main(String [] args){
statement1
` statement2
statement3
}
}
class shape(){
public Shape(){ 
System.out.println("Shape: constructor"); 
} 
public void foo() { 
System.out.println("Shape: foo"); 
} 

} class Square extends Shape { 
public Square() {
super(); 
} 
public Square(String label) { 
System.out.println("Square: constructor");
} 
public void foo() { 
super.foo(); 
} public void foo(String label) { 
System.out.println("Square: foo");
}
}
}
What would statement1, statement2 and statement2, be respectively, in order to produce this result?
Shape: constructor
Square: foo
Shape: foo


A: Square square = new Square(“bar”);
square.foo(“bar”);
square.foo();


B: Square square = new Square(“bar”);
square.foo(“bar”);
square.foo(“bar”);


C: Square square = new Square();
square.foo();
square.foo(bar);


D: Square square = new Square();
square.foo();
square.foo(“bar”);


E: Square square = new Square();
square.foo();
square.foo();


F: Square square = new Square();
square.foo(“bar”);
square.foo();


Answer is F:
Answer A produces:
Shape: constructor
Square: constructor
Square: foo
Shape: foo


Answer B produces:
Shape: constructor
Square: constructor
Square: foo
Square: foo


Answer C: bar cannot be reduced to a variable.
Answer D produces:
Shape: constructor
Shape: foo
Square: foo


Answer E produces:
Shape: constructor
Shape: foo
Shape: foo


Answer F Produces:
Shape: constructor
Square: foo
Shape: foo


 
Question 232
Given:


class Caller{private void init(){
System.out.println(“initialized”);
}
public void start(){
init();
System.out.println(“Started”);
}
}
public class TestCall{
public static void main(String [] args){
Caller c = new Caller();
c.start();
c.init();


What is the result?
A.	Initialized
Started
      B. Initialized
Started
Initialized
       C.  Compilation fails
       D. An exception is thrown at runtime.
Answer C: Compilation fails as the init method is private.



 
Question 233
Given:
public class App{
public static void main(String [] args){
int i = 10;
int j = 20;
int k = j = i/5;
System.out.println(i + “ : “+j+ “ : “ +k);
}
}
What is the result?
A.	10 : 22 : 20
B.	10 : 2 : 2
C.	10 : 22 : 6
D.	10 : 30 : 6


Answer: B
Assignment “=” has the lowest precedence of all operators so the line 
Int k = j=i/5
The division is done first
Int k=j= 10/5
Int k=j=2;
So will print out
10:2:2

 
Question 234
Given the fragment:
float var1 = ( 12_345.01 >= 123_45) ? 12_456 : 124_56.02;
float var2 = var1 + 1024;


What is the result?


A.	13480.0
B.	13480.02
C.	Compilation fails
D.	An exception is thrown at runtime.

Answer: C  - Compilation fails as you cannot convert from a double to a float in this example.

 
 
 
Question 235
 
Given, what is the result?
 
public static void main(String[]args){
                                int x= 0;
                                while(x<5)
while(x<3)
                                System.out.println(x++);
}

 A 0 1 2
B 0 1 2 3 4 5 
C Nothing prints out
D does not compile
E 0 1 2 five times

Correct Answer is A: 0 1 2
 
Explanation: The inner loop iterates until x is no longer less than 3, ending the print statements.



 
Question 236
public class Test {
public static List data =new ArrayList<>();

/*n1*/
for(String x : strs){
data.add(x);
}
return data;
}

public static void main(String[] args) {
// TODO Auto-generated method stub
String[] d = {"a","b","c"};
update(d);
for(String s : d){
System.out.println(s + " ");
}
}

}
What method signature, inserted at n1,  will compile and correctly run the above code?
A.	List update(String[] strs)
This is incorrect as the method so be static so that you can call it in the same class without having to create an instance.
B.	static ArrayList update(String[] strs)
The method returns a List data so the return type cannot be an ArrayList.
C.	static List update(String[] strs)
This is correct it is a static method meaning it belongs to the class and an instance need not be created in order to call it i.e. update(String[] arr) will work.
D.	static void update(String[] strs)
The method has a return statement that returns a List so the return type cannot be void.
E.	ArrayList static update(String[] strs)
The return type must directly precede the method signature. Here it is preceded by static. In any case the return type cannot be ArrayList(As discussed in Option B above).










 
Question 237

Which of the following are uses of the Object class?

A.	To achieve inheritance at user defined class level.
B.	To generate String representation of an Object.
C.	To get HashCode for an object.
D.	To achieve polymorphism at user-defined class level.
E.	To handle any Java Object in the name of Object.

Answer is B,C,E
A is incorrect
User defined class is a class you create yourself and inheritance between user defined classes is not dependant on the object class, although all classes do ultimately inherit from the object class
B is correct
The toString() method of the object class can be overridden by any class to print out a string representation of an object
C is correct
hashCode() is a method of the object class that attempts to produce a unique hash (number) for each object. There are literally an infinite number of ways a hash can be produced and this method is used in conjuction with the equals() method of the object class to find if two objects have the same values.
D is incorrect
Polymorphism, which are overridden methods, has nothing to do with the object class. You can override any method of the object class, but the ability to do this is not dependant on the object class
E is correct
You can create an object of the object class by 
Object obj = new Object()
In order to be albe to do this you have to be have access and usage of the object class (this object though is very limited in what it can do)


 
Question 238

Under which of the following scenarios a checked exception is thrown? (Choose 2)

A.	5TH Element of an array is accessed, whose size is 3.
B.	A file that actually does not exist is opened for reading.
C.	An attempt to connect to the database is made but failed.
D.	Length() method is called on a String Object, that is assigned to null.
E.	Given username and password is checked with database and found invalid. 

Answer is B. , C
A generates a ArrayIndexOutOfBoundsException exception which is a RuntimeException
B is correct
Anything to do with inputing or outputting to files has to put in a try catch block or the method with the code has to have a “throws exception” clause in its method signature. If a specified file is not found then a checked exception is generated
C is correct
Again anything to do with databases or external files can generate a checked exception, so if it can generate a checked exception then it has to be dealt with by a try catch block or by a “throws exception” in the method signature
D is incorrect
This generates a StringIndexOutOfBoundsException, which is a RuntimeException
E is incorrect
This is not a checked exception this would be a invalidArguement exception which is a runtimexception (which is one we create ourselves) 
Question 239
String deepak = "Did Deepak see bees? Deepk did.";
System.out.println(deepak.charAt(10));	
Which of the following options will give the output for the method call deepak.chatAt(10) ?
A.	None of the listed options?
B.	S
C.	H
D.	Space
Indexing starts at 0 with that considered charAt(10) is the space between Deepak and see.


	







 
Question 240
When inserted at line 11(Insert code here), will provide the following output? [21,13,11] 
static void Q65(){
		List<Integer> list = new ArrayList<>();
		list.add(21);list.add(13);
		list.add(30);list.add(11);
		list.add(2);
		//Insert code here 
		
/*Option A*///list.removeIf(e > e%2 != 0);
//			System.out.println(list);
This option is incorrect as the removeIf method takes a predicate and it is missing a – before the greater than sign i.e. -> instead of just >. 
		
/*Option B*///list.removeIf(e -> e%2 != 0);
//			System.out.println(list);
This option is incorrect even though the removeIf method receives the correct paramaters it will remove any number were the modulus is not equal 0 meaning it removes the uneven numbers and prints out 2 and 30. 
		
		
/*Option C*///list.removeIf(e -> e%2 = 0);
//			System.out.println(list);
This is incorrect as the single equals sign is for assignment and not a test for equivalence. If == was used this would work fine. 		
/*Option D*///list.remove(e -> e%2 = 0);
//			System.out.println(list);
The remove method takes a variable not a predicate so the method will not compile.
	
/*Option E*///None of the Above.	
This is the correct answer.
	}

 
Question 241
Given the code fragment: 



int a = -10;					++a, - - b   => -8, 15
int b =  17;					++a, b - - => -8, 16
int c =	/*expression1*/;			A++, - - b => won't compile (A is not defined code)
int d =  	 /*expression2*/;			A++, b - - => won't compile 		
c++ ;
d - - ;
System.out.println( c + " , " + d );



What could expression1 and expression2 be, respectively, in order to produce output 
–8, 16? 

A. 	 ++a,  - -b 
B. 	 ++a, b - -
C.  	A+ +,  - - b 
D.  	A + +, b - -





Correct answer B



Increment and decrement operators are used to update a variable to a new value.
Both these operators have two forms each: pre and post. In pre form, the operand appears before the operand and in post form, the operand appears after the operand. 
Also referred to as pre increment, post increment, pre decrement and post decrement
(before/after)
In the code above "expression" is there only to confuse (constants and expressions are not allowed with these operators)
If you like call it  line1 and line2. Now, you have to understand why they called pre and post.

So, a holds value -10 and b value 17. Value of a is first incremented to -10 and is then assigned to c. a and c holds now value -9. At line 2 (expression2) value of d holds value of b which is 17 and then/after decremented by one.
After print statement value of c is now -8 ( c was incremented by one after "expression2")
Value of d holds value of current b and then/after decremented by one  which is 16


 
Question 242
" You have a list orders  of PurchaseOrder objects, each with a date, a Customer  and a state. You want filter list in various ways".

Which of the following  in built functional interface you are going to use for above?
(chose best option):





A. Consumer< T >			

B. UnaryOperator< T >

C. Supplier< T >

D. Predicate< T >    	< --- what you know is D






Correct answer is D



This is exam question for Programmer 1 so you shoud know what is it functional interface in Java and which interfaces you coverd. That's the simply way to answer for that type of questions. 
You are not asked here about interfaces in answer A  C or Unary operator in B. 
What you know is Predicate
Predicate is a functional interface and can be used as the assignment target for a lambda expression or method reference.
Simple, it takes object and return true or false. To use predicates in your application you just have to implement this interface with your own logic 











 
Question 243 
You are writing a method that is declared not to return a value. Which two are permitted in the method body? 
(select two)



A. omission of the return statement

B. return; 
					
C. return null; 

D. return void;



Correct answer is A and B





You declare a method's return type in its method declaration. Inside the body of the method, you use the return statement to return the value.

Any method declared void doesn't return a value. It does not need to contain a return statement, but it may…
In this case, a return statement can be used to branch out of a control flow block and exit the method.

		( return; = exit )



Example:


		method void()                < --  declared to not return value
		{
			int x =0;
			if ( x == 1)
			     return;    	< -- exit method 
		}
			





 
Question 244
Given the code fragment:
 What is the best way to test that the values of h1 and h2 are thesame?



String h1 = "Bob";
String h2 = new String("Bob") ;


A. if (h1.equals(h2))

B. if (h1 = = h2)

C. if (h1.same(h2))

D. if (h1 = h2)





Correct answer is A



As you know equals() method is defined in Object class in Java and used for checking equality of two objects. We test the chars in two string objects. If all the characters are the same, equals() returns true. With equalsIgnoreCase, lowercase and uppercase are considered the same.
With the equality operator == only the references are compared, not the exact characters in two strings.

If we use equal() method (h1.equals(h2))  we get return true

If we use  == operator (h1==h2))  we get return false

=  that’s assigning operator (won't work)

same() method also won't work










 
Question 245
Given the code fragment: 


System.out.printIn("Result: " + 3 + 5);

System.out.printIn("Result: " + (3 + 5));



What is the result?



A. 	Result: 8
	Result: 35

B. 	R
	Result: 25

C.	Result: 235
	Result: 215

D. 	Result: 35
	Result: 8

E.	Compilation fails


Correct answer D


String Concatenation using + Operator
That's easiest way of joining multiple String and numeric values in Java.
Remember that, when you have two or more primitive type values e.g. char, short or int, in the beginning of your string concatenation, you need to explicitly convert first of them to a String.

Operand of + is a reference to a String object, the operator is the arithmetic addition operator, not the string concatenation operator. 
Java does not allow a program to define overloaded operators. However, the language defines the + operator to have a meaning that is fundamentally different from arithmetic addition if at least one of its operands is a String object.

System.out.println("Result: " + 3 + 5);

Result of this concatenation is :   Result:35


System.out.println("Result: "  + (3 + 5));

First 3 + 5 is calculated with result 8 and then is appended to string. Result of it is Result 8



Question 246
Given the code fragment: What is the result?



System.out.printIn("Result: " + 2 + 3 + 5);

System.out.printIn("Result: " + 2 + 3 * 5);



What is the result?



A. 	Result: 10
	Result: 30

B. 	Result: 10
	Result: 25

C.	Result: 235
	Result: 215

D. 	Result: 215
	Result: 215

E.	Compilation fails





Correct answer is  C



String Concatenation using + Operator
That's easiest way of joining multiple String and numeric values in Java.
Remember that, when you have two or more primitive type values e.g. char, short or int, in the beginning of your string concatenation, you need to explicitly convert first of them to a String.

System.out.println("Result: " + 2 + 3 + 5);

Result of this concatenation is :   Result: 235


System.out.println("Result: " + 2 + 3 * 5);

First 3 * 5 is calculated with result 15 and then is appended to 2. Result of it is Result 215
.




Question 247
Given the code fragment:?



	int b = 4;
	b--;
	System.out.println(b--);
	System.out.println(b);



What is the result?

A. 3 3

B. 2 3 

C. 3 4

D. 3 2			< -- correct

E. 0 0 


Correct answer is D


Increment and decrement operators are used to update a variable to a new value.
Both these operators have two forms each: pre and post. In pre form, the operand appears before the operand and in post form, the operand appears after the operand. 
Also referred to as pre increment, post increment, pre decrement and post decrement
(before/after)

b holds value 4, then b is decremented(after) by one.After first print statement b is = 3 and again is decremented by one(after)
In the second print statement System.out.println(b); b has value 2
Answer is 3 2










 
Question 248
Which two are valid declarations of a two-dimensional array?


A.	int [] [] array2D;	< -- correct

B. 	int [] [] array2D [];

C.	int [] array2D [];	< -- correct

D.	int [2] [2] array2D;

E.	int array2D [];




Correct answer is A and C



Array is an object the contains elements of similar data type. It is a data structure where we store similar elements. We can store only fixed set of elements in a java array.
Two-dimensional (2D) arrays are indexed by two subscripts, one for the row and one for the column. Each element in the 2D array must by the same type,either a primitive type or object type.

Here is the syntax for declaring a two-dimensional array:

dataType [][] arrayRefVar;
or
dataType arrayRefVar[][];  
or        
dataType []arrayRefVar[]; 













 
Question 249 

Given this code(with line numbers at left), which is a fragment of larger method body:


14:	StringBuilder[] sba = {
15:		new StringBuilder("Fred"),
16:		new StringBuilder("Jim"),
17:		new StringBuilder("Sheilaa")
18: };
19:
20:	System.out.println("sba[2] is " + sba[2])
21:



Which two of the following are true?

A. The array refered to by sba might be eligible for garbage collection at line 19

B. The array refered to by sba might be eligible for garbage collection at line 21

C. Assigning sba = null : at line 21 would make the array refered to by sba and the three 
            StringBuilder objects definitely eligible for garbage collection.

D. The array reffered to by sba and the three StringBuilder objects definitely eligible for garbage        	collection when the method returns to its caller

E. The array reffered to by sba and the three StringBuilder objects might not be eligible for
	 garbage collection even after the method returns to its caller.


Answer is C,E
A is not correct as we can refer to the array sba and the object contained within the array
B is not correct as we can refer to the array sba and the objects contained withing the array
C is correct, as if we assign the value of null to sba it means we no longer have access to the object created at line 14 and the only way we can access the string objects is through the array object sba
D is not correct as the method could be returning the array object, with the string objects contained within or it could be returning one of the strings contained within as well, so we can’t make any DEFINATE statements about what this method may or may not return
E this is correct as the array and/or the three stringBuilder objects might be returned by this method
 
Question 250
Given:
class A { }
class B { }
interface X { }
interface Y { }
Which two definitions of class C are valid?
A. class C extends A implements X { }
B. class C implements Y extends B { }
C. class C extends A, B { }
D. class C implements X, Y extends B { }
E. class C extends B implements X, Y { }
Answer is A and E.
The order of extending classes and implementing interfaces always is:
class B extends A implements C { }
B and D is wrong because order is reversed.
C is wrong because you cannot extends two classes













 
Question 251
Given:

public static void main(String[] args) {
		StringBuilder message = new StringBuilder("hello java!");
		int pos = 0;
		try {
			for (pos = 0; pos < 12; pos++) {
				switch (message.charAt(pos)) {
				case 'a':
				case 'e':
				case 'o':
					String uc = Character.toString(message.charAt(pos)).toUpperCase();
					message.replace(pos, pos + 1, uc);
				}
			}

		} catch (Exception e) {
			System.out.println("Out of limits");
		}
		System.out.println(message);

	}
}
What is the result?
A. hEllOjAvA!
B. Hello java!
C. Out of limits
  hEllO jAvA!
D. Out of limits
Answer is C.
	Out of limits
hEllO jAvA!
StringBuilder message has 11 characters and statement message.replace(pos, pos + 1, uc); increments number of characters. That’s why Exception is thrown.
And,
swich statement is changing characters a, e and o to upper cases and:
hEllO jAvA! Message is printed.


 
Question 252
Given:
public class Test3 {

	public static void main(String[] args) {
		String[][] arra = new String[3][];
		arra[0]= new String[]{"rosse","lilly"};
		arra[1]= new String[]{"apple","berry","cherry","grapes"};
		arra[2]= new String[]{"beans","carrot","potato"};
		//insert code fragment here
	}
}
Which code fragment when inserted at line //insert code fragment here enables the code to successfully change arra elements to uppercase? 
A.  for (int i = 0; i < arra.length; i++) {
			for (int j = 0; j < arra[i].length; j++) {
				arra[i][j] = arra[i][j].toUpperCase();
			}
		}
B.  for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				arra[i][j] = arra[i][j].toUpperCase();
			}
		}
C.  for (String a[]: arra[][]) {
			for (String x : a[]) {
				x.toUpperCase();
			}
		}

D.  for (String a[]: arra[][]) {
			for (String x : a[]) {
				x.toUpperCase();
			}
		}


Answer is A and:
ROSSE
LILLY
APPLE
BERRY
CHERRY
GRAPES
BEANS
CARROT
POTATO
 
will be printed after code:
for (int i = 0; i < arra.length; i++) {
	for (int j = 0; j < arra[i].length; j++) {
	System.out.println(arra[i][j]);
	}
}
B is wrong and: 
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 2
	at Test3.main(Test3.java:13) 
is thrown because:  arra[i][j] = arra[i][j].toUpperCase(); excess number of columns in arra[0] array which is 2.
C is wrong and:
Exception in thread "main" java.lang.Error: Unresolved compilation problems: 
	arra cannot be resolved to a type
	Can only iterate over an array or an instance of java.lang.Iterable
	Syntax error, insert ". class" to complete Expression
	a cannot be resolved to a type
	Can only iterate over an array or an instance of java.lang.Iterable
	Syntax error, insert ". class" to complete Expression

	at Test3.main(Test3.java:11)
is thrown.
D is wrong and:
Exception in thread "main" java.lang.Error: Unresolved compilation problems: 
	Can only iterate over an array or an instance of java.lang.Iterable
	Type mismatch: cannot convert from element type String[] to String
	Cannot invoke toUpperCase() on the array type String[]

	at Test3.main(Test3.java:11)
is thrown.





 
Question 253

Given:

public static void main(String[] args) {
		int numbers[];
		numbers = new int[2];
		numbers[0] = 10;
		numbers[1] = 20;

		numbers = new int[4];
		numbers[2] = 30;
		numbers[3] = 40;
		for (int x : numbers) {
			System.out.println(" " + x);
		}
	}
}
What is the result?
A. 10 20 30 40
B. 0 0 30 40
C. Compilation fails.
D. An exception is thrown at runtime.
Answer is B and: 0 0 30 40 will be printed.













 
Question 254
Given:
class MarksOutOfBoundsException extends IndexOutOfBoundsException {
}

public class GradingProcess {

	void verify(int marks) throws IndexOutOfBoundsException {
		if (marks > 100) {
			throw new MarksOutOfBoundsException();
		}
		if (marks > 50) {
			System.out.println("Pass");
		} else {
			System.out.println("Fail");
		}
	}

	public static void main(String[] args) {
		int marks = Integer.parseInt(args[2]);
		try {
			new GradingProcess().verify(marks);
		} catch (Exception e) {
			System.out.println(e.getClass());
		}
	}

}
And command line invocation:
java GradingProcess 89 50 104
What is the result?
A. Pass
B. Fail
C. Class MarksOutOfBoundsException
D. Class IndexOutOfBoundsException
E. Class Exception

Answer is C.

 
Question 255
Given: 

public class Test { 
} 

From which class does Java compiler implicitly derive Test?
A. Objects
B. Class
C. an anonymous class
D. Object

Answer D

The Object class is the root of the entire Java class hierarchy

 
Question 256
Which two packages are automatically imported into the java source file by the java compiler?

A. Java.lang
B. Java.awt
C. Java.util
D. Javax.net
E. E. Java.*
F. The package with no name

Answser A,F
The java compiler automatically imports three classes, java.lang package, the current package and the package with no name if no package statement is defined for the current class






 
Question 257
Which two may precede the word ‘class’ in a class declaration?

static
volatile
public
local
synchronized 

Answer is static, public
 
Question 258
Which declaration initializes a boolean variable?

A. boolean h = 1;
B. boolean k = 0;
C. boolean m = null;
D. boolean j = (1 < 5);

Answer is D
This is the only one that evaluates to true or false
 

Question 259
Identify two benefits of using ArrayList over array in software development.

A. reduces memory footprint
B. implements the Collection API
C. is multi.thread safe
D.dynamically resizes based on the number of elements in the list

Answer is A,C but as already stated in previous iteration of this question it is debateable if this reduces the memory footprint 
Question 260
Which three of the following are valid types for a switch statement.


A. int
B. float
C. double
D. integer
E. String
F. Float


Answer: A, D and E.


The variable used in a switch statement can only be integers, Integers, byte, short, char, strings and enums.


Floats and doubles cannot be used.

 

Question 261
Which of the following lines will compile without warning or error? 

A.    float f=1.3; 
B.    char ch="a"; 
C.    boolean b=0; 
D.    int y = 2.3;
E.    char c=65; 


Answer: E


A.	The number 1.3 is not cast as a float, either (float)1.3; or suffixed with f, 1.3; Without the cast it is treated as a double and cannot be assigned to a float which is a smaller data type.
B.	A char data type requires single quotes ‘ ‘  not double quotes “ “ around the character.
C.	The primitive type boolean only takes true or false. The default is false.
D.	The number 2.3 is treated as a double and cannot be assigned to an int.
E.	Characters have an equivalent number value.

 
Question 262
Consdier the following code snippet:
Public class Welcome{
	String title;
	Int value;
	Public Welcome(){
Title+=” Planet”;
}
Public Welcome(int value){
this.value=value;title=”welcome”;
Welcome();
}
Public static void main(String args[]){
Welcome t= new Welcome();
System.out.println(t.title);
}
}

Which of the following options will be the output for the above code snippet

A Welcome
B Welcome Planet
C Compilation fails
D The code runs with no output
E Welcome Planet 5

Answer is C

The constructor in the Welcome class that takes an int assigns values to both value and title. However the line
Welcome() is the wrong way to call a constructor in the same class that takes no variables, if we want to call the other constructor in the Welcome class that takes no variables we have to go this(), or if we had a method in the class with the method signaturte
Void Welcome(){
}
Then we could have called our Welcome() method by typing Welcome(), so this will NOT compile

 
Question 263
Consider the following code snippet:
Class MyClass{
	Int myValue;

@Override
Public Boolean equals(Object o1, Object o2)
{
	MyClass mc1=(MyClass)o1;
	MyClass mc1=(MyClass)o2;
	
	If(mc1.myValue==mc2.myValue)
		Return true;
		Return false;
}
What is the correct output of the the above code snippet
A ClassCastExcetpion will be thrown
B @Override cannot be used for equals() method
C compile error: clas does’nt override a method from it’s superclass @Override
D Progrma compiles successfully and executes

Answer is A 
You can have a superclass reference to a subclass object but you can’t have a sub class reference to a superclass object, you can try and cast it, and it will compile, but it will throw a ClassCastException.
In this example we have o1 and o2, which are OBJECTS, which are a superclass of every object that you create in java. We then have mc1, which is user defined class, so this is a sub class of object. 
The line 
MyClass mc1=(MyClass)o1; 
Is a sub class refrence (mc1) to a super class object (o1), which you can’t have as explained above, you can try and cast it and it will compile, but it will throw a classCastException


 
Question 264
Consider the following program
Import java.io.*;

Public class SteppedTryCatch{
Public static void main(String[]args){
Try
{
	Try
		{
			Try
				{
				//line 1
				}
				 Catch(Exception e3)
				{
					System.out.println(“Exception 1”);
					//line 2
				}
		}
		Catch(IOException e2)
		{
			System.out.println(“Exception 2”);
			//line 3
		}
}
Catch(FileNotFoundException e1)
{
	System.out.println(“ Exception 3”);
}

}
}
Which option will compile
 
Answer is B
Option A is incorrect as we these are NESTED try catch blocks (we have a try/catch block in a try block). If they were all in the same level, then you would have to the catch blocks with the lowest precedence exceptions caught first ie.
Try{
}
Catch(ClassCastException c){}//right order
Catch(RunTimeException r){}//none nested
Catch(Exception e){}//all same level
When you nest a try/catch block inside a catch block, the nested block can throw any exception you want if the code correctly deals with it, which it does here.
Option B is correct as the most important rule of checked exceptions is that it does not matter where you deal with them, they must be dealt with somewhere in your code or your code will not compile
 At line1 an exception is generated and is caught by the matching catch block and print out “Exception 1”, at line 2 an IOException is generated which is caught by the outer catch block catch(IOException) and prints out “Exception 2”, at line 3 a FileNotFoundException is generated and caught by the outer catch(IOException e1) and prints out “Exception 3”.
Option C is incorrect as a catch block can catch the exception in the catch method signature or a subclass of that exception, .ie
Try{
	Throw new ClassCastException()
Catch(Exception e){
	}
The above will work as we are catching an exception, and classCastException is a sublclass of exception.
 For option C, at line 1 an IOException is generated then the catch(Exception e) catches this exception as IOException is a subclass of Exception. At line 2 an FileNotFoundException is generated which is caught by catch(IOException e2) as IOException is a superclass of FileNotFoundException. At line3 a Exception is thrown, however the catch(FileNotFoundException) does not deal with this exception as FileNotFoundException is a subclass of Exception. So the checked exception will not be dealt with and this will result in our code not compile.
Option D is incorrect as at line 3 an IOException is generated so only a catch block that deals with the same excpetion or a superclass(exception) can deal with this exception. However the catch(FileNotFoundException) is a subclass of IOException so this does not deal with the excpetion generated.
Option E is incorrect for the same reason as option D, in that the catch(FileNotFoundException) does not deal with the Exception generated on line 3

 
Question 265
Consider the following code:

public class SwitchCase{
public static void main(String args[]) {

int x = 10;

switch(x){

case 10: System.out.println(“10”);
case 10: System.out.println(“10”);

case 10: System.out.println(“10”);
default: System.out.println(“30”);

Which of the following will be the output for the above program?

A.	101020
B.	1020
C.	1010
D.	Compilation Error
E.	3014


Answer: D


There will be a compilation error as you can’t have duplicate case identifiers in a switch statement

 
Question 266
Given the code fragment:


public class MarkList{


int num;
public static void graceMarks(MarkList obj4){
obj4.num += 10;
}
public static void graceMarks(String args[]){


MarkList obj1 = new MarkList()      //line 1
MarkList obj2 = obj1; //line 2 
MarkList obj1 = null; //line 3
obj1.num = 60; //line 4
graceMarks(obj2); //line 5


How many objects are created at runtime?


A.	1
B.	2
C.	3
D.	4



Answer: A


The object obj1 is created at  line l using the ‘new’ keyword.


At line 2 obj1 is assigned to obj2 but we still only have one object.


At line 3 null is assigned to obj1. However, null is not a subclass of the Object class, therefore the null object obj 1 is not actually an object.


So, we only have one object created at runtime.






 
Question 267
Consider the following code:

package com.java.test:
public class A{
	public void m1(){
		System.out.print(“A.m1, ”);
}
protected void m2(){
		System.out.print(“A.m2, ”);
}
private void m3(){
		System.out.print(“A.m1, ”);
}
void m4(){
		System.out.print(“A.m4, ”);
}
}
class B{
	public static void main(String[]args){
		A a = new A();
a.m1(); //1
a.m2(); //2
a.m3(); //3
a.m4(); //4
}
}
Assume that both of the above classes are stored in a single source file called ‘A.Java’
Which of the following gives the valid output of the above code?
A.	Prints: A.m1, A.m2, A.m3, A.m4,
B.	Complie-time error at 3.
C.	Compile-time error at 4.
D.	Compile-time error at 2.
E.	Complie-time error at 1. 

Answer B
You can’t access a private member (method , variable, inner class, etc) from another class. So here
we have the method m3 which has the method signature Private void m3(){}
This means that this method can ONLY be accessed inside it’s own class so the line a.m3() is trying to access a private method outside of it’s own class which you can’t do.

 
Question 268
Consider the following code:

Public class Code{
	Public static void main(String args[]){
		new Code();
}
{
	System.out.print(“Planet ”);
}
{
	System.out.print(“ Welcome”);
}
}

Which of the following will be the valid output for the above code?

A Compiles and executes with no output
B Welcome Planet
C Planet Welcome
D Planet
E Compilation Error

Answer is C
It is valid to put in just blocks of code anywhere within a class surrounding by curly brackets {}. When this is done outside a method they are called INITIALISERS, and these blocks of code always run JUST BEFORE a constructor creates an object. If there is more than one initialser in a class then we just go in the order they are in the class. In this example we have two Initialisers, which are both called in the order they are in the class, so it prints out
Planet Welcome

 
Question 269
Consider the following code:
Class A
{
	Public void method(Object object){
			System.out.println(“Object”);
	}
	Public void method(String string){
			System.out.println(“String”);
	}
	Public static void main(String args[]){
			New A().method(null);
}
}

Which of the following options will be output for the above code
A.	Compilation Error ‘Cannot pass null as method arguments’
B.	Prints “String”
C.	Throws NullPointerException at runtime
D.	Print Object
Answer is B
Null can be passed to any method that takes an object, and both of these methods take objects, as strings are objects. In this sort of situation Java will always pick the more specific method, which is method(String string)

 
Question 270
Given 
Public class TestLoop{
		Public static void main(String  args[]){
		Int array[]={0,1,2,3,4};
		Int key=3;

		for(int pos=0;pos<array.length;++pos){
		If(array[pos]==key){
		break;
		}
		}
		System.out.println(“Found “+key+”at”+pos)
	}
}

A.	Found 3 at 2
B.	Found 3 at 3
C.	Compilation fails
D.	An exception is thrown at runtime
Answer is C
Be very careful with questions with opening and closing brackets, as in this
Question we see the line
For(int pos=0;pos<array.length;++pos){
This declares a for loop and in the definition of the for loop it declares a LOCAL variable “pos”. This means that this variables is ONLY avaialbe within this loop. The line
System.out.println(“Found “+key+”at”+pos)
Is attempting to access the “pos” variable outside of the for loop (note the bracketing)

 
Question 271
Consider:

Integer number = Integer.valueOf( “808.1"); 

Which is true about the above statement?

A. The value of the variable number will be 808.1 
B. The value of the variable number will be 808 
C. The value of the variable number will be 0. 
D. A NumberFormatException will be thrown
E. It will not compile
Answer is D, 
Each of the wrapper class has a valueOf methods that take a string that contains a primitive version of the wrapper object I.e Integer.valueOf(“234”), Double.valueOf(“12.456”). This will compile, however it will throw a NumberFormatException as this is a double and you can’t get an Integer from a double.
D    is the answer 
Question 272
Given the code fragment
System.out.println(28+5<=4+29)
System.out.println((28+5)<=(4+29))
What is the result


A 	28false29
	True

B 	285<429
	True

C	true
	True

D	Compilation Fails

Answer is C

The relational operators (>,<.<=,=>) have lower preceducne than addition
So we have 28+5 = 33
4+29=33
33<=33 which is true
And the next line does the exact same calculation as brackets come first

 
Question 273
Given

Import java.util.ArrayList;
Import java.util.List;
Public class javaSETest {
	Public static void main(String[]args){
		List<Integer>elements=new ArrayList<>();
		Elements.add(10);
		Int firstElmnt=elements.get(1);
		System.out.println(firstElmnt);
	}
}
What is the result
A.	Null
B.	10
C.	0
D.	An IndexOutOfBoundsException is thrown at runtime.
Answer is D
Array and arraylist numbering starts at 0, and in this example we only have one number in our arraylist of Integers. So there is only ONE element in the list, so the line
Elements.get(1) will throw an IndexOutOfBoundsExcetion
If it was Elements.get(0) this would work as there is only one number in our arraylist, which is at positon 0

 
Question 274
Given the code Fragment

//line n1
Switch(cardVal){
	Case 4:case 5:case 6:
	Case 7:case 8:
		System.out.println(“Hit”);
		Break;
	Break;
	Case 9:case 10:case 11:
		System.out.println(“Double”);
		Break;
	Case 15:case 16:
		System.out.println(“Surrender”);
		Break;
	Default:
		System.out.println(“Stand”);
}

Which code fragments can be inserted at line n1, independently, to print Stand?
A.	Int cardVal=6;
B.	Int cardVal=10;
C.	Int cardVal=14;
D.	Int cardVAl=18;
Answer is C,D
When you have a case statement without a break, it will keep hitting the case statements after it until it gets to a break and exits.
i.e
int num=2;
Switch(num)
	Case 2:
		Some code
	Case 3:
		Some more code
	Case 4:
		Even more code
		Break;
So in the above example num is 2, so the code in case 2 executes, and the code in case 3 executes followed by the code in case 4, then and only then does our switch statement exit.
If our question if we have cardval=6, it will hit on case 6: and continue until it hits a break. So it contines to case 7, case 8 and prints out “Hit” and then exits.
For cardval=10, it will hit case 10, case 11 and print out “Double” and then exit
For cardval=14, there is NO case 14: so there is no on any case statement, so it goes the the default case which prints “stand”
Similarily for cardval=18, the is NO case 18, so it goes to the default case which prints “Stand”

Question 275
Given
Abstract class Writer{
	Public static void write(){
		System.out.println(“writing…”);
	}
}
Class Author extends Writer{
	Public static void write(){
		System.out.println(“Writing book”);
	}
}
Public class Programmer extends Writer{
	Public static void write(){
		System.out.println(“Writing code2);
}
Public static void main(String[]args){
	Writer w=new programmer();
	w.write();
}
}

What is the result

A.	Writing 
B.	Writing Book
C.	Writing code
D.	Compilation fails
Answer is A
Static methods are not overridden but are “Hidden”, and are totally dependent on the REFERENCE of the object. So in this example we have a superclass Writer reference to a sub class Programmer object. When it’s a static method, and you are calling a static method in a non static way, as you are here, then it looks at the reference of the object, which is writer, and then calls the write() static method in the writer class.
It is not recommended you call static methods in a non static way, as we are doing here. To call the same method in a non static way we would go
Writer.write()

 
Question 276
Class SuperClass{
	SuperClass(int x){
		System.out.println(“Super”);
		}
}
Public class SubClass extends SuperClass{
	SubClass(){
	//Line n1
	System.out.println(“Sub 2”);
	}
}
Which statement, when inserted at line n1, enables the code to compile
A.	this(10);
B.	Super(10);
C.	superclass(10);
D.	super.superClass(10);

Answer is B
Answer A is incorrect as this(10) is attempting to call a constructor in it’s own class that takes an int, there is no such constructor.
Answer B is correct, as every object in a sub class has to have a call to a constructor of the super class. We do this by the keyword “super”. In this example, super(10) is calling a constructor in the SuperClass that takes an int, and there is such a constructor which is SuperClass(int x){
Answer C is incorrect as this is NOT how to call a constructor in the superclass, this is attempting to call a method called superclass(int num) in the same class
Answer D is incorrect as you cannot go super.super.

 
Question 277
Given the code fragment
Public class TestClass{
	Public static void main(String[]args){
		List<String>items=new ArrayList<>();
		Items.add(“Pen”);
		Items.add(“Pencil”);
		Items.add(“Box”);
		For(String i:items){
			If(i.indexOf(“P”)==0){
				Continue;
				}
			Else{
				System.out.print(i+” “);
				}
			}
		}
	}
What is the result
A.	Pen Pencil Box
B.	Pen Pencil
C.	Box 
D.	Compilation Fails
Answer is C
In this question we create an arraylist of strings and add the string “pen”, “Pencil” and “Box”. We then have an enhanced for loop that will go through all of the strings in the list. 
indexOf() gets the index of a particular character, so i.indexOf(“P”) gets the index of where the letter capital “P” is. So the line
If(i.indexOf(“P”)==0){
Checks if the first letter of the word is capial “P” then the loop continues, which means that the rest of current iteration of the loops is skipped. If a word does not begin with capital “P” then it will print the word. So the effect of this is that “Pen” and “Pencil” are NOT printed but “Box” is printed as it does not begin with the capital letter “P”
 
Quesiton 278
Given the code fragment
Public class Test{
Public static void main(String[]args){
	Int x=10;
	Int y=2;
	Try{
		For(int zz=2;z>=0;z--){
			Int ans=x/z;
			System.out.print(ans+” “);
			}
		}catch(Exception e1){
			System.out.println(“E1);
		}catch(ArithmeticException e1){
			System.out.println(“E2”);
		}
	}
}

What is the result

A.	E1
B.	E2
C.	5 10 E1
D.	Compilation fails
Answer is D
Sub exceptions must come before the super class when you have multiple catches for a try block. In this question we have the super class Exception BEFORE the sub exception ArithmeticException, which you cannot have. The hierarchy for ArithmeticException is
Exception
RuntimeException extends Exception
ArithmeticException extends RuntimeExeption

 
Question 279
Given the code fragment
StringBuilder s1=new StringBuilder(“java”);
String s2=”Love”;
S1.append(s2)
S1.substring(4);
Int foundAt=s1.indexOf(s2);
System.out.println(foundAt);

What is the result
A.	-1
B.	3
C.	4
D.	A StringOutOfBoundsException is thrown at runtime
Answer is C
S1.append(s2) produces 
javaLove
s1.substring(4) does’nt actually change the stringBuilder object, to change stringBuilder object you would have to do something like this
s1=new StringBuilder(s1.substring(4)); as substring returns a String, not a stringBuilder.
So the line
Int foundat=s1.indeof(s2) is returning the index of where the string “love” appears in the string “javaLove”, which is position 4. So foundAt is 4.

 
Question 280
Consider the following interface
Interface Multi{
Public int multiply(int p1,int p2);
}

Which of the following will create instance of the above interface type? Choose 2
A.	Multi mul=(x,y)->return x*y;
B.	Multi mul=(x,y)->{return x*y;};
C.	Mutli mul=()->{return x*y;};
D.	Multi mul=(int x,int y)->{return x*y;};
E.	Multi mul=(int x,int y)->return x*y;
F.	Multi mul=()->return*y;
Answer is B, D
Answer A is incorrect as when you use the keyword “return” in a lambda it has to be surrounded by curly brackets {}, which is actually a method body.
Answer B is correct as you are sending two variables to the multiply method and this is returning an int, and the return statement is withing curly brackets. As the method in the Multi interface takes two ints and returns an int. 
Answer C is incorrect as this is not sending any variables to the multiply method
Andwer D is correct, you do not have to state what variable types x and y are, but it is not an error to do so. This is returning an int which is a correct implementation of the functional interface Multi. A functional interface is an interface with only ONE abstract method in them.
Answer E is incorrect as the return keyword is not within the curly brackets (method body).
Answer F is incorrect as this takes no arguments and the syntax retrun*y is invalid

 
Question 281
Which of the following is a checked Excpetion
A.	FileNotFoundException
B.	ArithmeticException
C.	classCastException
D.	NullPointerException
E.	IllegalArgumentException
Answer is A
All the others are runtimeExceptions

 
Question 282
Given the code fragment:

Int a=0;a++;
System.out.print(a++);
System.out.print(a);

What is the result

A.	12
B.	01
C.	11
D.	22
Answer is A
A is given the value of 0, then is incremented by 1 with a++
The line
System.out.println(a++);
Will first print out the value of a, which is 1 and then increment by 1, so a is now 2
So the line 
System.out.println(a)
Will print 2

 
Question 283
public class Test {
public static void main(String[] args) {
boolean isChecked = false;
int arry[] = {1,3,5,7,8,9};
int index = arry.length;
while ( <code1> ) {
if (arry[index-1] % 2 ==0) {
isChecked = true;
}
<code2>
}
System.out.print(arry[index]+”, “+isChecked);
}
}
Which set of changes enable the code to print 1, true?
A.Replacing <code1> with index > 0 and replacing <code2> with index–;
B. Replacing <code1> with index > 0 and replacing <code2> with –index;
C. Replacing <code1> with index > 5 and replacing <code2> with –index ;
D. Replacing <code1> with index and replacing <code2> with –index ; 

Answer is A,B
arry.length is 6 so that means that index is 6. 
Answer A is correct as when we go while(index>0), index is 6 and will enter the loop. Inside the loop each time it checks to see if each number has a modulus of 0 when divided by 2. If for any numbers in the list this is true, then isChecked is changed to true, and it does not matter what happens after that, but isChecked will then always be TRUE. if we have either - - index or index - - then this will keep decrementing until we get down to the first element of our list, which was 1.
Answer B is correct for the above reason
Answer c is incorrect as index only decrements once, so that is array[index-1], which is arry[5], which is 9, so this prints 9, true
Answer D is incorrect as this will not compile as a while loop needs a Boolean, so while(index), is wrong as index is NOT a Boolean


 
Question 284
Given the code in a file Traveler.java
public class Tours {
	public static void main(String[] args) {
	System.out.println("Happy Journey!" + args[1]);
	}
}
public class Traveler {
	public static void main(String[] args) {
		Tours main(args);
	}
}
And the commands:
Javac Traveler.java
Java Traveler Java Duke

What is the result?
A.	Happy Journey!Duke
B.	Happy Journey!Java
C.	An exception is thrown at runtime
D.	The program fails to execute due to a compilation error
Answer is D
You can only have one public class per file and that has to be the same name as the file. Here we have two public classes in the same file, which you can’t have
 
Question 285
import java.util.ArrayList;

public class Values {
	public static void main(String[] args) {
	ArrayList <String>list = new ArrayList();	
	list.add("SE");
	list.add("EE");
	list.add("ME");
	list.add("SE");
	list.add("EE");
	list.remove("SE");	
	System.out.println(list);	
	}
}
When run it prints out 
E is the correct answer
[EE, ME, SE, EE]
a)	Values are: [EE, ME]
b)	Values are: [EE,EE, ME]
c)	Values are: [EE, ME, EE]
d)	Values are: [SE, EE, ME, EE]
e)	Values are: [EE, ME, SE, EE]
The remove() method of the arrayList class, returns a Boolean that returns true if it finds a particular object it is searching for and removes it from where it first finds it on the list. So in this example it finds the String “SE” in the first

 
Question 286
Which of the following are correct regarding instance block? (Choose 3)

a)	A class can have more than one instance block
b)	An instance block cannot initialise the class member
c)	Instance blocks are executed only, when the instance are created from main () method of that class
d)	Instance blocks are executed before constructors
e)	Instance blocks are executed for every created instance

Answer: a,d,e
An instance block is an initializer, an example of which is
Class Dog{
	Int age;
	String name;
	{//initializer block
		Age=234;
		Name=”spot”;
	}
A is correct, a class can have as many initializer blocks as you want, and they are called in the order they are in the class. 
B is incorrect as a class member is a static member and a instance block CAN access static members, both static variables and static methods
C is incorrect instance blocks are exexcuted whenever an instance of a class is created, and you can create an object anywhere inside a class
D is correct as instance blocks are always executed before a constructor when an object is created.
E is correct as every time a object is created, the instance blocks are executed in the order they are in the class, followed by the constructor
Note static initiizer block first in order they are in class, followed by instance block, followed by constructors

 
Question 287
Consider the following program:
Class joy extends Exception{}
Class smile extends joy{}
Interface happy{
Void a()throws smile;
Void z()throws smile;
}
Class one extends Exception{}
Class two extends one{}
Abstract class test{
Public void a()throws one{}
Public void z()throws one{}
}
class check extends test{
Public void a() throws smile{
System.out.println(“Welcome”);
Throw new smile();
}
Public void z() throws smile{
Throw new smile();
}
Public static void main(String args[]){
Try{
Check obj=new check();
Obj.b();
Obj.a();
Obj.z();
}
Catch(smile s){
System.out.println(s);
}
Catch(two t){
System.out.println(t.getClass());
}
Catch(one o){
 System.out.println(s);

Catch(Exception e){
System.out.println(e);

}
}
}
What will be the output of the above program?
a)	Throws a compile time exception as overridden method a() does not throw exception smile.
b)	Welcome class two
c)	Two
d)	Throws a compile time exception as overridden method z() does not throw exception smile
e)	Class two
Answer A
Class Check extends Test, which means the method
Public void a()throws smile 
in the check class is overriding the method
Public void a()throws one{} 
in the Test class which you cannot do as they are different branches. If the base class method had thrown an Exception, then this would compile as the overridden method can throw the same exception or a sub class of that exception, but smile is NOT the same exception or sub class of ONE, there is no direct relationship between these two exception classes

 
Question 288
Which usage represents a valid way of compiling java source file with the name “main”
A.	Javac Main.java
B.	Java Main.class
C.	Java Main
D.	Javac Main
E.	Java Main
Answer is A
The command is Javac followed by the name of the file, followed by the file extension which will be java.  When you compile a file you produce what is called a Class file, which will have the same name as the file but have the file extension .class. so our above file would produce a class file with the full name
Main.Class

 
Question 289
Given class App{
//insert code here
System.out.println(“Welcome to the world of java”);
}
}

Which two code fragments, when inserted indepdently at line “//insert code here”, enable the program to execute and print the welcome message on the screen.

A.	static public void main(String[]args){
B.	static void main(String[]args){
C.	public static void Main(String[]args){
D.	public static void main(String[]args){
E.	public void main(String[]args){

Answer is A,D

The main() method offers us a jumping off point from where we can start our program. The method has to be first “public”, “static”, and both of these keywords can either be in the first or second position. It must return “void”, which has to be in the third position. The name of a method has to come before the method body, and with a main() method it MUST be the  lower case “main”.
A is correct
B is incorrect at there is no “public”
C is incorrect as this is “Main” and not “main”.
D is correct
E is incorrect as there is no “static”

 
Question 290
Given 
Public class Calcluator{
	public class Calculator{
		public static void main(String[]args){
			int num=5;
			int sum;
			
			do{
				sum+=num;
			}
			While(num--)>1);
			System.out.println(“The sum is “+sum+” . “);
		}
	}
What is the result?
A.	The sum is 2
B.	The sum is 14
C.	The sum is 15
D.	The loop executes infinite times
E.	Compilation fails
Answer is E
Sum is a LOCAL variable, which means it is not given any initial value by default. 
So the line, 
Sum+=num
Will not compile as sum has no initial value so you can’t add num onto something that does not have any value

 
Question 291
Given
public class Test22{
	int fvar;
	static int cvar;
public static void main(String[]args){
		Test22 t=new Test22();
//insert code here to write field variables
	}
}
Which code fragmetns, inserted independently, enable the code to compile
A	t.fvar=200;
B	cvar=400;
C	fvar=200;
	cvar=400;
D	this.fvar=200;
	this.cvar=400;
E	t.fvar=200;
	Test22.cvar=400;
F	this.fvar=200;
	Test22.cvar=400;
Answer is A,B,E
A is correct as when you are inside a static method the only way to access a field/instance variable of an object is to create an object of that class.  The object t is an instance of the Test22 class so we can then access the fields of this object through t. 
B is correct as we are inside a static method and you can access static variables directly when inside a static method of the class
C is incorrect as we can’t access the filed fvar this way, we would have to access it by t.fvar
D is incorrect as you can’t use the keyword “this” inside a static method
E this is correct as we are accessing the fvar variable through the object t, and we are accessing the static variable cvar in a static way, which is the name of the class followed by the variable  name
F is incorrect as you can’t use “this” inside a static method

 
Question 292
Given 
public class CharToStr{
	public static void main(String[]args){
		String str1=”Java”;
		char str2[]={‘j’,’a’,’v’,’a’};
		String str3=null;
		For(char c:str2){
			str3=str3+c;
		}
		If(str1.equals(str3))
			System.out.println(“Sucessful”);
		Else
			System.out.println(“Unsucessful”);
	}
}
What is the result
A.	Sucessful
B.	Unsucessful
C.	Compilation fails
D.	An exception is thrown at runtime
Answer Is B
The for loop produces str3=”nullJava”, and str1 is “java” and the equals() checks if they are the same string and they are NOT, so it will print out “Unsucessful”

 
Question 293
The protected modifier on a field declaration within a public class means that the field?
A.	Cannot be modified
B.	Can be read but not written from outside the class
C.	Can be read and written from this class and its subclasses only within the same package
D.	Can be read and written from this class and its subclasses defined in any package
Answer = D
A.	 Incorrect. Modifiers that are declared as protected are accessible to all classes in the package and to all subclasses of its class in any package where this class is visible.
B.	Incorrect. Subclasses of the protected base class can access a protected modifier
C.	Incorrect. This would be true if it was private instead of protected
D.	Correct. A protected modifier on a field declaration within a public class can be read and written from this class and its subclasses defined in any package
 
Question 294
Which two actions will improve the encapsulation of a class?
A.	Changing the access modifier of a field from public to private
B.	Removing the public modifier from a class declaration 
C.	Changing the return type of method to void
D.	Returning a copy of the contents of an array or ArrayList instead of a direct reference
Answer = A and D
A.	Correct. Making the access modifier private improves the encapsulation greatly as the variables in the class will be hidden from other classes
B.	Incorrect. removing the public modifier without replacing it with a private modifier will not improve the encapsulation  
C.	Incorrect. Void just means that it has no return value and does nothing to improve encapsulation
D.	Correct. Copying an array or ArrayList prevents other classes from interfering with the original array or ArrayList.
 
Question 295
Which statement is/are true?
I.	Default constructor only contains “super();” call
II.	We can’t use any access modifier with a constructor
III.	A constructor should not have a return type

A.	Only I 
B.	Only II
C.	Only I and II
D.	Only I and III
E.	All
Answer is D
A.	False, as both I and III are true statements
B.	False. Incorrect. Any access modifier can be used with a constructor
C.	False. This is incorrect. Yes the default constructor contains “super();” call, but any access modifier can be used with a constructor
D.	True. This is correct as the default constructor contains “super();” call and a constructor should not have a return type
E.	False. Incorrect. as option II is incorrect, all options are not true  
Question 296
Given 
public class CheckIt{
	public static void main(String[] args){
		if (doCheck()){
			System.out.print(“square”);
		}
		System.out.print(“…”);                  // line 6
	}
	public static int doCheck(){
	return 0;
	}
}

What should be inserted in the print statement on line 6?
A.	square…  
B.	….. 
C.	Compilation fails
D.	An exception is thrown at runtime

Answer = C
the method doCheck() returns an int, and the condition in an if statement MUST evaluate to a Boolean. So if(doCheck()) DOES NOT evaluate to a boolean, so this will not compile
A.	Incorrect.  This has already been checked
B.	Incorrect. This would return no value
C.	Correct. The program fails to compile
D.	Incorrect. No exception will be thrown as the code fails to compile

 
Question 297
Code:
1.	public class A{
2.	       int y;
3.	       public A(int x){
4.	                 y=x;
5.	       }
6.	       public void print(){
7.	                 System.out.println(y);
8.	       }
9.	}
10.	public class B extends A{
11.	       //constructor for this class
12.	}

Which of the following can be used as the constructor for the class B?
Select any one of given answer :
Choice A	public B(){ super(); }
Choice B	public B(int x){ this(x); }
Choice C	public B(int x){ System.out.println(x); super(x); }
Choice D	public B(int x){ super(x); }
Choice E	 public A(){ super(); }

Answer D
Choice D is the only valid option. It creates a constructor for class B which takes an int and calls the constructor in the super class A that takes an int.
Choice A tries to call a constructor in the super class A that takes no arguments. There is no such constructor in class A.
The constructor defined in Choice B calls itself recursively, giving a compilation error. 
Choice C won’t compile as the call to the constructor in the super class A must be the first line in the constructor in class B.
Choice E gives a compilation error. A constructor of a class must have the same name as the class.

 
Question 298
Which of the following can be considered as enhancements in java 8?
I.	Support for the Lambda Expression.
II.	Multiple inheritances.
III.	Default methods in abstract classes.
IV.	Date and Time API

Select any one of given answer :
Choice A	Only I
Choice B	Only III
Choice C	Only I and II
Choice D	Only I and IV
Choice E	Only I, III and IV

Answer E
Java 8 includes support for lambda expressions, default methods in abstract classes and a new Date and Time API.


 
Question 299
Which code fragment correctly assigns a numeric literal
A byte b1=b1011;
B byte b2=101b;
C byte b3 = 0b1001;
D byte b4=0xb001;

Answer is C
0b at the start of a number denotes that this number is in binary format and can have the numbers “1” and “0” (base 2)
0x at the start of number denotes hexadecimal, which can use the characters 0123456789abcdef (base 16)
0 at the start of  number denotes octal, which can use only the numbers 01234567 (base 8)
A is incorrect as this is not a valid binary, it has to be 0b at start of number
B is incorrect as this is also not a valid binary as it has to be 0b at start of number
C is correct as this has the correct suffix and also only has the numbers 1 and 0
D is incorrect as 0x is the hexadecimal suffix and then we have a b after that suffix which is incorrect syntax


 
Question 300
Consider following interface

interface Runnable{
     public void run();
}

Which of the following will create instance of Runnable type?

Select any one of given answer :
Choice A	Runnable run = () -> System.out.println(“1Z0-808”);
Choice B	Runnable run = () -> { System.out.println(“1Z0-808”);}
Choice C	Runnable run = new () -> System.out.println(“1Z0-808”);
Choice D	Runnable run = > System.out.println(“1Z0-808”);
Choice E	None of above

Answer A
Answer A is correct as this correctly creates a lambda for the functional interface Runnable
Answer B is incorrect as there is a missing semi colon at the end of the statement, it should be 
{ System.out.println(“1Z0-808”);};
Answer C is incorrect as you can’t use the new keyword in that way
Answer D is incorrect as that is equals and greater than symbol=> 
Answer E is incorrect as A is correct
 
Question 301
Given
1.	interface A{
2.	 
3.	      int groupID = 10;
4.	
5.	      default boolean equals( Object obj ){
6.	             return this.groupID == ((A)obj).groupID;
7.	      }
8.	
9.	      static void print(){
10.	             System.out.println(“A”);
11.	      }
12.	}

Which is true about above code?

Select any one of given answer :
Choice A	Above code compiles fine
Choice B 	Code fails to compile since interface can’t have any default methods
Choice C	Compilation fails due to error at line 5
Choice D	Compilation fails due to error at line 6

Answer C
Compilation fails due to error at line 5. A default method cannot override a method from java.lang.Object 


 
Question 302
Given the following method from the java.util.Arrays
Method Summary: static void sort(long [] a)
And given,
1.	public class Sorter{
2.	      public static void main(String []args){
3.	              int[] a = {3, 1, 22, 5, 11, 2};
4.	              sort(a);
5.	      }
6.	}

Which of the following will make this code works?
A.	By adding the import statements “import static java.util.Arrays.sort;”
B.	By adding the import statement “static import java.util.Arrays.*;”
C.	By adding the import statement “import java.util.Arrays.*;”
D.	By adding the import statement “import java.util.Arrays.sort;”
E.	By adding the import statement “import static java.util.*;”

Answer A
Option A is the correct way of importing the static method sort.
Option B will not work as the import keyword has to come before the static keyword.
Options C, D and E will not import the static method sort.
If we wanted to import all of the static methods we would go
Import static java.util.Arrays.*;
 
Question 303
Identify two benefits of using ArrayList over array in software development.
A.	reduces memory footprint
B.	implements the Collection API
C.	is multi-thread safe
D.	dynamically resizes based on the number of elements in the list

Answer A and D
Option D is an advantage of using an ArrayList over an array, as an ArrayList does dynamically resize based on the number of elements in the list.
Option A is debatable as in the background new arrays are being created every time we add an element to an arraylist. For example, we have an arraylist of one billion items, we add one item to the arraylist, in the background a new array of a billion and one is created, the old array of one billion items is now liable for garbage collection, but crucially it could still be taking up memory on the system.
Answer B is just a statement of fact, yes Arraylist implements the Collection interface, but a statement of fact is not a advantage or disadvantage. i.e I am a man, is not an advantage or disadvantage is just a fact
C is incorrect
Threads are not covered for this exam, but a simple explanation of threads is they are “flows of control”. All the programming we have done has one flow of control, it does one thing after another in a specific order. With threads you can have multiple processes happening at the same time (i.e calculating paye tax and prsi tax at the same time). Issues  arise with threads are that one thread can affect another thread in an applications, when this happens we say that this process is “not thread safe” or the process of making an application safe is called “synchronization”. ArrayLists are NOT thread safe as they are NOT synchronized.
D is the only one with certainty we can say is right

 
Question 304
The catch clause argument is always of type.
A.	Exception
B.	Exception but NOT including RuntimeException
C.	Throwable
D.	RuntimeException
E.	CheckedException
F.	Error

Answer C
Throwable is a super class of all exception and error classes. Therefore the catch clause argument is always of type Throwable.  

 
Question 305
Which two packages are automatically imported into the java source file by the java compiler?
A.	Java.lang
B.	Java.awt
C.	Java.util
D.	Javax.net
E.	E.Java.*
F.	The package with no name

Answer A and F
The package java.lang is automatically imported into the java source file by the java compiler.
The default package (the package with no name) is also imported.
A java.lang is always imported as this contains classes such as the Object class and all the wrapper classes, also contains the system class which has all of the print methods
B java.awt is used for created GUI’s
C java.util has all the collections including ArrayLists and methods for manipulating arrays
D javax.net has classes for dealing with networks
E have no idea what this is
F the package with no name is the default package and this is always imported, but remember you can’t import from this package
 
Question 306
Which two may precede the word ‘class’ in a class declaration?
static
volatile
public
local
synchronized

Answer public and static
The keyword public may precede the word ‘class’ in a class declaration.  
Note you can’t prefix the definition of a top-level class with the keyword static. static classes are types of nested classes.  



 
Question 307
Given the code fragment:


public void print( ){

	System.out.println( "default" );

}

Which of the following correctly overload above method?


A. private int print(int x ){  return x; }

B. public String print( ){ return "default"; }

C. public abstract void print( ){ System.out.println("default");}

D. void print( ){ System.out.println("Non public");}

E. None of the above



Correct answer is A
Whenever same method name is exiting multiple times in the same class with different number of parameter or different order of parameters or different types of parameters is known as method overloading. Method overloading is also known as Static Polymorphism - compile time binding.
.Method B is seen by compiler like duplicate of method also like method from option e. Option c abstract method has no body and should bbe use in abstract class. 
Ths answer to this question is more likely to be A, as this method is indeed overloading the print() method as it does have a different parameter list which does meet the strict defnation of overloading. It does not matter if the overloading method is public, private, etc as all that matters when you overloading a method is that they have the same name and different parameter list.














 
Question 308
Which three are bad practices? 



A.Checking for ArrayIndexOutOfBoundsException when iterating through an array to determine when all elements have been visited

B.Checking for Error and if necessary, restarting the program to ensure that users are unaware problems

C.Checking for FileNotFoundException to inform a user that a filename entered is not valid

D.Checking for ArrayIndexOutOfBoundsExcepcion and ensuring that the program can recover if 
one occur

E.Checking for an IOException and ensuring that the program can recover if one occurs



Correct answers : A B D



Checked Exceptions:
Checked Exceptions are exceptional scenarios that we can anticipate in a program and try to recover from it, for example FileNotFoundException. We should catch this exception and provide useful message to user and log it properly for debugging purpose. Exception is the parent class of all Checked Exceptions and if we are throwing a checked exception, we must catch it in the same method or we have to propagate it to the caller using throws keyword. The compiler requires a throws clause or a try-catch statement for any call to a method that may cause a checked exception to occur.
If a checked exception occurs and is not caught before it reaches the main method of the application, the program will crash

Runtime Exception: 
Runtime Exceptions are cause by bad programming, for example trying to retrieve an element from the Array. We should check the length of array first before trying to retrieve the element otherwise it might throw ArrayIndexOutOfBoundException at runtime. RuntimeException is the parent class of all runtime exceptions. If we are throwing any runtime exception in a method, it’s not required to specify them in the method signature throws clause. Runtime exceptions can be avoided with better programming.

.
Option A – Better to check if the index is within bounds.

Option B – restarting is a last possibility that should be done.

Option D – Better to check if the index is within bounds










Question 309
Given:



public interface MyInt {
    public void method1() {	< -- ordinary method not allowed in interface
        System.out.println("method1");
    }
    public default void method2() {	< -- default method
        System.out.println("method2");
    }
    public static void method3() {	< -- static method
        System.out.println("method3");
    }
    public abstract void method4();	< -- abstract method
}



Which statement is true?

A.  Only method4() compiles
B.  Only method2() and method4() compiles.
C. Only method2(), method3(), and method4() compiles.
D. MyInt.java compiles.


Correct Answer C



The interface body can contain abstract methods, default methods, and static methods. 
An abstract method within an interface is followed by a semicolon, but no braces (an abstract method does not contain an implementation).
Default methods are defined with the default modifier, and static methods with the static keyword. All abstract, default, and static methods in an interface are implicitly public, so you can omit the public modifier.

An interface can extend other interfaces. Class can extend only one other class, an interface can extend any number of interfaces. 
If you do not specify that the interface is public, then your interface is accessible only to classes defined in the same package as the interface.
public access specifier indicates that the interface can be used by any class in any package







Question 310
Given the fragment:



public class MathFun {
    public static void main(String[] args) {
        int number1 = 0b0111;			< -- decimal number 7
        int number2 = 0111_000;			< -- not used 
        System.out.println("Number1: " + number1);
        System.out.println("Number2: " + number1);
    }
}



What is the result?


A.  Number1: 7   
      Number2: 7

B  Number1: 7
     Number2: 111_000

C   Number1: 0b0111
      Number2: 0111000

D   Compilation fails.



Correct answer is A


Public class MathFun, inside main method you declaring two int variables called number1 and number2.
Both numbers holds value : number1 =  0b0111 (binary), and number2 = 0111_000(octal)
In next two lines of code which are print statements you printing out value only belong to number1. JVM will convert binary or octal to decimal value !
That is the  result: 

 System.out.println("Number1: " + number1)  = Number1 : 7
 System.out.println("Number2: " + number1)  = Number1 : 7
		
Notice the number2 is not used, so you saving bit of time .
That’s calculation to convert octal to decimal:

(your octal value)
      0111000 = (0 * 8^6)+(1 * 8^5)+(1 * 8^4)+(1 * 8^3)+(0 * 8^2)+( 0 * 8^1)+(0 * 8^0)
											(number2)
 0111000  =           0       + 32768 +  4096     +   512    +      0      +      0       +      0      =  37376

Binary to decimal:
			    6    4    2    1
(your binary value)  0b     0     1   1    1
			    0 + 4 + 2 + 1   = dec = 7 = number1	
 
Question 311
Given the code fragment:


LocalDate date1 = LocalDate.of(2016, Month.JANUARY, 1);
LocalDateTime date2 = LocalDateTime.of(2017, Month.JUNE, 1, 1, 1);
Period p = Period.between(date1, date2);				
System.out.print(p.getYears() + ":" + p.getMonths() + ":" + p.getDays());


What is the result?

A  1:5:0
B  1:6:0
C  0:0:0
D  Compilation fails.



Correct answer:  D




With the Java 8 Date API,you can use the Period class. Period class represents a date-based
amount in years, months, and days, like 2 years, 5 months, and 10 days. To work with a
time-based amount in seconds and nanoseconds, you can use the Duration class
In code above is used the static method between(LocalDate dateInclusive, LocalDate
dateExclusive) to instantiate Period. At this point compiler will complain because format date2 is LocalDateTime and that will cause compilation fails.When we change line 2 as follow:

	LocalDate date1 = LocalDate.of(2016, Month.JANUARY, 1);
	LocalDate date2 = LocalDate.of(2017, Month.JUNE, 1);

 then program will work fine and output should be like this: 1:5:0























Question 312
Given:



x = "abcedfghijklmnopqrstuvwxyz"
y = "lmno"



Which line of code will remove the y string from the x string, and store it in the z variable?

a  z = x - y 
b  z = x.remove(y) 
c  z = x.subtract(y) 
d  z = x.replace(y, "") 


Correct answer D

Answer A is incorrect
The mathematical operators -,/*,% do not work with strings, + will concatenate strings
Answer B is incorrect
There is no remove method in the string class, there is a remove() method in the ArrayList class
Answer C is incorrect
There is no subtract method in the string class, subtract() is a static method of the Math class.
D is correct
This is the only valid method of the String class in this question



















 
Question 313
Given


1.    public class Program{
2.        static int x = 20;
3.        public static void main(String[] args){
4.            Program pr = new Program();
5.            pr.x = 5;
6.            int y = x/pr.x;
7.            System.out.print("y = ");
8.            System.out.print(y);
9.         }
10.    } 



What will be the result?
       
A.    y = 3
B.    y = 2
C.    y = 1
D.    Compilation fails due to an error on line 6. 
E.    Compilation fails due to an error on line 8. 



Correct answer C


At line 2, we have defined static variable x with value 20, since it is static all instance of the class share same variable. So if any instance change value of x, that change will reflect on all instances. In this case changing value of x at line 5, so value of the variable x will be 5 for any instance, so the output would be y=1
















 
Question 314
Given


1.    public class Program{
2.        static int x = 20;
3.        public static void main(String[] args){
4.            Program pr = new Program();
5.            pr.x = 5;
6.            int y = x/pr.x;
7.            System.out.print("y =");
8.            System.out.print();
9.            System.out.print(y);
10.        }
11.    } 


What will be the result?       

A.    y = 3
B.    y = 2
C.    y = 1
D.    Compilation fails due to an error on line 6. 
E.    Compilation fails due to an error on line 8.


Correct answer E

There is no print() method that takes no arguments, so this will not compile (there is a println() that takes no arguments)















 
Question 315
Given:

public class DoBreak
{
       public static void main(String[] args) 
       {
	String[] table = {"aa", "bb", "cc", "dd"};
	for (String ss: table) 
	{
	      if ( "bb".equals(ss)) 
	      {
		continue;
	      }
	      System.out.println(ss);
	      if ( "cc".equals(ss)) 
	      {
		break;
	      }
	 }
        }
}
What is the result?

A. aacc
B. aabbcc
C. ccdd
D. cc


Correct answer A




We create String array named table with four elements. We have enhanced for loop which is iterating over an array. Next we have two if statements. When condition in first if statement is false, first element our table is printed which is "aa". Second if statement is never executed because condition is also false. Second iterating , condition in if statement become true, continue is reached. At this point for loop start iterating again from third element in our table which is "cc"
First if is false, "cc" is printed and second if statement condition is true. Here break is reached . Exit with output:  aa
		   cc







 
Question 316
Given the code fragment:

String name = "Spot";
int age = 4;
String str ="My dog " + name + " is " + age;
System.out.println(str);

And

StringBuilder sb = new StringBuilder();

Using StringBuilder, which code fragment is the best position to build and print the following string:
"My dog Spot is 4"


A. sb.append("My dog " + name + " is " + age);System.out.println(sb);

B. sb.insert("My dog ").append( name + " is " + age); System.out.println(sb);

C. sb.insert("My dog ").insert( name ).insert(" is " ).insert(age); System.out.println(sb);

D. sb.append("My dog ").append( name ).append(" is " ).append(age);    System.out.println(sb);



Correct Answer A and D


StringBuilder append(String s) - is used to append the specified string with this string. The append() method is overloaded like append(char), append(boolean), append(int), append(float), append(double).
StringBuilder insert(int offset, String s) - is used to insert the specified string with this string at the specified position. The insert() method is overloaded like insert(int, char), insert(int, boolean), insert(int, int), insert(int, float), insert(int, double) 












 
Question 317
Given the following code fragment:


//line n1
switch (x) { }


Which two of the following lines of code can be added successfully at line n1?
Assume that x has no decleration in scope at line n1 and assume that each line is added individually.


A. boolean x  = false;

B. short x = 99; 

C. int x = 0;

D. long x = 0;

E. StringBuilder x = new StringBuilder( "x" );



Correct answer B and C


The rules for switch statement require that the argument be assigment - compatible with int ( allowing for autoboxing ), String , enum. The type of expression "must be char, byte, short, int, Character, Byte, Short, Integer, String, or an enum type, or compile-time error occurs."
String is legal type for switch from Java 7. StringBuilder is assigment - compatible with String, but is not legal type for switch statement. 




 
Question 318
Given:

class X {				

	int x1, x2, x3;		
}
class Y extends X {

	int  y1;	

	Y ( ){		
		x1 = 1;
		x2 = 2;
		y1 = 10;
	}
}
class Z extends Y {

	int  z1;

	Z ( ){
		x1 = 3;
		y1 = 20;
		z1 = 100;
	}
}
public class Test3 {
	
	public static void main(String[] args) {
		
		Z obj = new Z();
		
		System.out.println(obj.x3 + ", " + obj.y1 + ", " + obj.z1);
	}
}

Which constructor initilise the variable x3?

A. Only the default constructor of class X

B. Only the no-argument  constructor of class Y

C. Only the no-argument  constructor of class Z

D. Only the default constructor of object class


Answer A


Inheritance…, Constructor Rules:
- the first statement of every constructor is a call to another constructor within the class using this(), or a call to a constructor in the direct parent class using super()

- super() call may not be used after the first statement of the constructor.

- if no super() call is declared in a constructor, Java will insert a no-argument super() as the first statement of the constructor.



… to question with XYZ or ZYX


-  in Java, the parent constructor is always executed before the child constructor. If the parent doesn’t have a no-argument constructor and the child doesn’t define any constructors, the compiler will throw an error and try to insert a default no-argument constructor into the child class.


- If the parent doesn’t have a no-argument constructor, the compiler requires an explicit call to a parent constructor in each child constructor.

The purpose of a constructor is to initialize fields

Here, you creating object class Z obj. Class Z extends Y and Y extends X. 
All classes have declared variables.
In the print statement:  reference obj.x3 will be initialise by default constructor given by Java to class X.
So, output will be like this : 0 20 100. 
x3 is getting default value for type int , y1 and z1 got it value given by constructor Z();




























 
Question 319
The protected modifier on a field class means that the field…?


A. cannot be modified

B. can be read but not written from outside the class

C. can be read and written from this class and its subclasses only whitin the same package

D. can be read and written from this class and its subclasses defined in any package



Answer D


A protected member is accessible in all classes in the same package, and by all subclasses
of its class in any package where this class is visible. In other words, non-subclasses in
other packages cannot access protected members from other packages. This kind of
accessibility is more restrictive than public member accessibility.























 
Question 320
Given:


public class Palindrome{

	public static int main(String[]  args ){
		System.out.print(args [1]);
		return 0;
	}
}

And the commands:

javac Palindrome. java
java Palindrome Wow Mom

What is the result?

A. Compilation fails

B. The code compile, but does not execute.

C. Palindrome

D. Wow

E. Mom



Answer B



Compile - time / Run - time
There are two ways to translate a program; interpreting and compiling. 
An interpreter is a program that reads a high-level program and does what it says. In effect, it translates the program line-by-line, alternately reading lines and carrying out commands. 
A compiler is a program that reads a high-level program and translates it all at once, before running any of the commands. Often you compile the program as a separate step, and then run the compiled code later. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable.
The compiler can only translate a program if the program is syntactically correct; otherwise, the compilation fails and you will not be able to run your program.

In code above, you compile program. When run it  you getting an Error:  "main" method must return a value of type void in class Palindrome.


Question 321
Given:

class Dog {

	Dog(){

	      try{
		    throw new Exception();
	      }
	       catch ( Exception e ){ }
	}
}
class Test {

	public static void main(String[]  args ){
	        Dog d1 = new Dog();
	        Dog d2 = new Dog();
	        Dog d3 = d2;

	      // do complex stuff
	}
}

How many object have been created when the line // do complex stuff is reached ?

A. Two

B. Three

C. Four

D. Five

E. Compilation fails.


Answer C


Creating instance
To create an instance (object) of a class, all you have to do is write new before it. Here, each time creating new puppy you creating new Exception and Exception is a object !









Question 322
Given the fragment code:



		float var1 = (12_345.01 >= 123_45.00) ? 12_456 : 124_56.02f ;
		float var2 = var1 + 1024 ;
		System.out.println( var2 );



What is the result?


A. 13480.0f

B. 1348.02

C. 13480.0

D. Compilation fails

E. An Exception is thrown at runtime



Answer C

This is a ternary operator that first checks if 12_345.01 >= 123_45.00, this will return either true or false. If true var1 will be given the value 12456, which is an int and can be assigned to the float var1. If this is false, then it var 1 will be given the value 124_56.02. the equate returns true which means var1 is the value 12456, which is then added to 1024 which gives us the value 
13480







 
Question 323
Given:

public abstract class Shape {
	private int x;
	private int y;
	public abstract void draw();
	public void setAnchor (int x, int y) {
		this.x = x;
		this.y = y;
	}
}
Which two classes use the Shape class correctly?

A.  public class Circle implements Shape {
	private int radius;
     }
B.  public abstract class Circle extends Shape {		
     	private int radius;			  
     }
C.  public class Circle extends Shape {
	private int radius;
	public void draw();
     }
D.  public abstract class Circle implements Shape {
	private int radius;
	public void draw();
      }
E.  public class Circle extends Shape {		 
	private int radius;
	public void draw() {/* code here */}
      }
F.   public abstract class Circle implements Shape {
	private int radius;
	public void draw() { /* code here */ }
      }


Answer B,E

Question is checking your knowledge about abstract classes and interfaces. What can be extend, what can be implemented, etc.
Here, is which class use the Shape class correctly:

B. abstract class can extends abstract class( Shape is define abstract ) Work fine("use correctly")
E. concrete class can extends abstract class, but has to override abstract methods in Shape, which is done . Work fine.

Here, what is not allowed:

A.  class can't implement abstract class. 
Class CAN implement Interface or extends abstract class( + override abstract methods)
C.  abstract method inside concrete class is not allowed
F.  abstract class can't implement abstract class. 

 
Question 324
Given the code fragment:



class Test{

	public static void main (String[] args) {

	        String [] arr = {“A”, “B”, “C”, “D”};

	        for (int i =0; i<arr.length; i++) {

		  System.out.print (arr[i]  + “ “);

		  if (arr[i] .equals (“C”)) {

			continue;
		  }
		  System.out.println (“Work done”);

		             break;	
	         }
	}
  }

What is the result?


A. ABC Work done

B. ABCD Work done

C. A Work done

D. None of these answers

E. Compilation fails



Answer C



We create String array with four strings called arr. 
for loop is starting iterating: first position arr [ i ] is 0 , so arr [0] = A and A is printed .
In the next line condition if statement is false 	("A".equals("C")) => false. 
After,  "Work done" is printed. Exit (break;)
Correct answer:  A Work done
 
Question 325
Given:

class X {

	String str = "default";

	X(String s) {
	    str = s;
	}
	void print() {

		System.out.println(str);
	}
	public static void main(String[] args) {

		new X("hello").print();
	}		 
}

What is the result?


A. hello

B. default

C. Cornpilation fails.

D. The program prints nothing.

E.  An exceptionis thrown at runtime.





Answer A




In main method we create new instance of class X , constructor call ( passing argument ). Inside constructor X str got it new value s ("hello"). Call to method print() will give us output hello.





 
Question 326
Given the code fragments:


public class TestA extends Root {

	public static void main (String[] args) {

	           Root r = new TestA();

		System.out.println(r.method1()); 		// line n1
                                                                                          	 
		        System.out.println(r.method2());   	// line n2
	}
}

class Root {

	private static final int MAX = 20000;

	private int method1 () {

		int a = 100 + MAX;   		// line n3
		return a;
	}
	protected int method2 () {

		int a = 200 + MAX;   		// line n4
		return a;
	}
}

Which line causes a compilation error?

A.  line n1

B.  line n2

C.  line n3

D.  line n4


Answer A


private: only accessible within the same class 

default (package private) access: private and other classes in the same package

protected: default access and child classes

public: protected and classes in the other packages

Question 327
Given:

public class Test {

	public static void doChange(String sb) {	

	              sb.concat(" Moliday");
	}
	public static void main(String[] args) {

	            StringBuilder sb = new StringBuilder("Sunday");

		doChange(sb);		

		System.out.println(sb);
	}
}

What is the result?


A.  Sunday Moliday

B.  Sunday 

C.  Compilation fails.

D  An exception is thrown at runtime.



Answer C




You create new StringBuilder object and you  try call static method doChange()  in Test class.
Such method is accepting String not StringBuilder. That willl cause compilation fails.

You can use any String method on a StringBuilder object by first converting the StringBuilder to a String with the toString() method of the StringBuilder class. Then convert the string back into a string builder using the StringBuilder(String str) constructor.

 
Question 328
Given
String color=”teal”

Switch(color){
	Case “Red”:
		System.out.println(“Found Red”);
	Case “Blue”:
		System.out.println(“Found Blue”);
		break;
	Case”Teal”:
		System.out.println(“found Teal”);
		break;
	default:
		system.out.println(“found default”);
}


What is the result?

A.	Found Red Found Default
B.	Found Teal
C.	Found Red Found Blue Found Teal
D.	Found Red Found Blue Found Teal Found Default
E.	Found Default

Answer is E
Java is CaSe SeNsItIvE so “teal” is different from “Teal”, there is no match in the switch statement for “teal”. So it triggers the default case and prints out 
“found Default”


 
Question 329
Public class Test{
	Static int count=0;
	Int i=0;
	Public void changeCount(){
			While(i<5){
				i++;
				Count++;
			}
	}
	Public static void main(){
			Test check1=new Test();
			Test check2=new Test();
			check1.changeCount();
			check2.changeCount();
			System.out.print(check1.count+” ; “+check2.count);
	}
}
What is the result
A.	10:10
B.	5:5
C.	5:10
D.	Compilation fails
Answer is A
Check1 and check2 are created and both have initial field value for count and I set to 0. Check1.changCount() increments the value of I and count by 1 five times with a loop. This is an non static method and a non static method can access both statics and non statics, so there is no issue with this method.
so the final values of I and count after this method is:
I=5, count=5
Then check2 calls on the changeCount()method, however remember that count is static variable, so it is a CLASS variable and this value is shared by INSTANCES of the class, so our initial starting value for count is 5. The method executes and increments I by 5, and 1 increments count by 5
So at the end of the method the values are as follows
I=5, count=10
So that means that check1.count and check2.count are the value 10, as static variables are SHARED across all insances of the class, so if you change it for member, you change it for every member.
.


 
Question 330
Given: 

package handy.dandy ;
public class Keystroke {
public void typeExlamation() {
System.out.println(" ! ");
}
}

And
package handy ;/* Line 1 */
public class Greet {/* Line 2 */
public static void main(String[] args) {/* Line 3 */
String greeting = "Hello";/* Line 4 */
System.out.println(greeting);/* Line 5 */
Keystroke stroke = new Keystroke() ; /* Line 6 */
stroke.typeExlamation();/* Line 7 */
}/* Line 8 */
}/* Line 9 */

What three modifications, made independently, made to class greet, enable the code 
to compile and run?

A Line 6 replaced with handy.dandy.keystroke stroke = new KeyStroke ( );
B.Line 6 replaced with handy.*.keyStroke = new KeyStroke ( );
C.Line 6 replaced with handy.dandy.Keystroke stroke = new handy.dandy.Keystroke();
D.import handy.*;    added before line 1
E.import handy.dandy.*;     added after line 1
F.import handy.dandy,keyStroke;    added after line 1
G.import handy.dandy.KeyStroke.typeException();    added before line 1
Answer is C,E,F
Answer A is incorrect as you have to have the full path name of both sides of the assignment operator, i.e. handy.dandy.Keystroke=new hand.dandy.Keystroke();
Answer B is incorrect as this is incorrect syntax
Answer C is correct as this is using the full path name
E is correct as this imports all the classes in this package (but not it’s subpackages)
F is correct, but we do not HAVE to import this class as the statement in option E imports all of the classes already in this package
G is incorrect you can’t import just an instance method of a class, you can import all the statics of a class as you don’t need an instance of a class to call a static 
Question 331
Given the code fragment: 



int[][] array2D = { { 0,1,2} , {3,4,5,6} };

System.out.println(array2D [0].length + " " );
System.out.println(array2D [1].getClass().isArray() + " " );
System.out.println(array2D [0] [1] );
A 4
false
2
B 4
true
1
C 3
false
3
D 3
true
1

Answer is D
This is a two dimensional array that has two rows like the following
0	1	2
3	4	5	6
Arra2D[0].length refers to the length of the first row, which is three
The isArray() method returns true if the object is an array, false if not an array so the line
array2D [1].getClass().isArray()
is checking if the second row is an array, it is, so it returns true.
The line
array2D [0] [1]
is checking the first row, second column, which is the number 1

 
Question 332
An unchecked exception occurs in a method dosomething() 

Should other code be added in the dosomething() method for it to compile and execute?
A. The Exception must be caught
B. The Exception must be declared to be thrown.
C. The Exception must be caught or declared to be thrown.
D. No other code needs to be added.

D. No other code needs to be added.
Unchecked is a runtime exception and a runtime exception does not have to be dealt with in order for the code to compile and execute, however this will cause your program to crash. 
Question 333
Which two are valid instantiations and initializations of a multi dimensional array?
A. int[][] array2D = { { 0,1,2,4} , {5,6} };

B. int[][]array2d=new int[2][2];
array2d[0][0]=1;
array2d[0][1]=2;
array2d[1][0]=3;
array2d[1][1]=4;

C. int[][][] array3D =  { { 0, 1 } , { 2, 3 } , { 4, 5 } }; 

D.int[][][]array3d=new int[2][2][2];
array3d[0][0]=array;
array3d[0][1]=array;
array3d[1][0]=array;
array3d[1][1]=array;

E.      int [][]   array2D = { 0, 1 };
Answer A & B
Instantiate means we are giving values to every position in our array
•Option A is correct as this is a valid instantiation and initialization of an asymmetric multi dimensional array.
•Option B is correct as this is a valid instantiation and initialization of a symmetric multi dimensional array.
•Option C is incorrect as array3D is a three dimensional array and this option tries to initialize it as a two dimensional array.
•Option D is incorrect as array is undefined.
•Option E is incorrect as array2D is a two dimensional array and this option tries to initialize it as a one dimensional array.
 
Question 334
A method doSomething () that has no exception handling code is modified to trail a method
that throws a checked exception. 

Which two modifications, made independently, will allow the program to compile?
A. Catch the exception in the method that calls doSomething().
B. Cast the exception to a RunTimeException in the doSomething() method.
C. Declare the exception to be thrown in the doSomething() method signature
D. Catch the exception in the method doSomething().

Answer is C,D
The doSomething() is calling a method that throws a checked exception, so that means that either this method call has to be in a try catch/block or the method doSomething() has to have a throws clause in the method signature. Also the method that creates the exception has to also have a throws clause in its method signature if it wants the doSomething() method to handle the exception.
A is incorrect as in order for this to work the method doSomething would have to have throws in it’s method signature
B is incorrect you can’t cast exceptions
C is correct as this will throw the exception to whatever is calling the doSomething() method. 
D is correct, if the doSomething() method catchs the exception that will deal with the exception generated


 
Question 335
Which of the following will print current time?
A. System.out.print(new LocalTime()-now0);
B. System.out.print(new LocalTime());
C. System.out.print(LocalTime.now());
D. System.ouLprint(LocalTime.today());
E. None of the above.

Answer is C
You can’t directly create a localTime, localDate or localDateTime object directly you have to create a object via static method such as now() or of(). 
A is incorrect as this is the incorrect syntax
B is incorrect as you can’t create a LocalTime object directly
C is correct as this will get the current time
D there is no today() method in the LocalTime class, if you want to get todays date, we use
LocalDate.now()

 
Quesiton 336
Given the code fragment:


float x = 22.00f % 3.00f;
int y = 22 % 3;
System.out.print(x + ", " + y);


What is the result?
A. 1.0, 1
B. 1.0f, 1
C. 7.33, 7
D. Compilation fails
E. An Exception is thrown at runtime
Answer A
Float x=22.00f%3.00f
Is checking the 22.00 modulus 3.00, so we divide 22 by 3 and the remainder is the modulus, which is 1. This is a float so it prints out 1.0
Int y=22%3, is doing the same thing, but the final answer will be an int, so it prints out 1

 
Quesiton 337
class MyResource implements AutoCloseable {

    private String name;
    public MyResource(String name) {
    this.name = name;
    }
 @Override
    public void close() {
    System.out.println(name);
    }
}
public class ResourceHog {

    public static void main(String[] args) {
    
    try 
    {
    MyResource one = new MyResource("one");
    MyResource two = new MyResource("two"));
    }
    
    finally 
    {
    System.out.println("three");
    }

    }
}

What is the result? Choose one.
A one
two
three
B three
two
one
C three
one
two
D two
one
three
E.  The words one, two, and three are all output, but the order is not determined.
Answer is D
This question is more java 2 than java one
There is an built in interface called AutoClosaeable that has one of it’s method, close(). The close method is called automatically when exiting a try-with-resource. A try with resource is a try block in which we created a resource object. 
A resource is Any object that implementsjava.lang.AutoCloseable , which includes all objects which implement java.io.Closeable , can be used as a resource.
It closes them in the reverse order they were created in the try block, so we get 
“two,one”
The finally is then called, so we get
“two one three” 
Question 338
Given the code fragment:

package p1;
public interface DoInterface{
           void method1(int n);// line n1
           public void m2(int n);
}

package p3;
import p1.DoInterface;
public class DoClass implements DoInterface{
           int x1, x2;
          public DoClass(){
this.x1 = 0;
this.x2 = 10;
            }
            public void m1(int p1){ x1 += p1;  System.out.println(x1); }// line n2 
            public void m2(int p1){ x2 += p1;  System.out.println(x2); }
}

package p2;
import p1;
import p3;
class Test{
         public static void main(String[]  args){
DoInterface doi = new DoClass();// line n3
doi.method1(100);
doi.method2(200);
         }
}

What is the result?
A. 100210
B. Compilation fails due to an error in line n1
C. Compilation fails due to an error at line n2
D. Compilation fails due to an error at line n3

Answer is B 
This does not compile as the DoClass class implements the DoInterface interface, which means it has to implement all of the abstract methods in the interface. The DoClass class DOES NOT implement the abstract method method1 in the interface, so this will cause the compilation to fail. 
The code never gets to line n2 or n3

 
Quesiton 339
Given the code fragment:

package p1; 
public interface DoInterface { 
        void method1(int n1); // line n1 
        public void method2(int n1);
} 

package p3; 
import p1.DoInterface; 
public class DoClass implements DoInterface { 
        public DoClass(int p1) { } 
        public void method1(int p1) { } // line n2 
        private void method2(int p1) { } // line n3 
} 
public class Test { 
        public static void main(String[] args) { 
                  DoInterface doi= new DoClass(100); // line n4 
                  doi.method1(100); 
                  doi.method2(100); 
        } 
}
Which change will enable the code to compile
A. Adding the public modifier to the declaration of method1 at line n1  
B. Removing the public modifier from the definition of method1 at line n2
C. Changing the private modifier on the declaration of method 2 public at line n3
D. Changing the line n4 DoClass doi = new DoClass ( );

Answer is C
C. Changing the private modifier on the declaration of method 2 public at line n3

 
Question 340

Given: 

package pkg1; 
class Bb { } 
             public class Ee { 
             private Ee() { } 
             }
 
package pkg2; 
final class Ww{}

package pkg3; 
public abstract class Dd { void m() { } 
} 
And, 

1. package pkg4; 
2. import pkg1.*;	
3. import pkg2.*; 
4. import pkg3.*; 
5. // insert a class definition here 


Which two class definitions, when inserted independently at line 5, enable the code to compile?

A. class Cc extends Bb { } 

B. class Cc extends Ww { }      can't extends final

C. class Cc extends Ee { } 

D. class Cc extends Dd { } 

Class Bb is imported into the package with the line import pkg1.*; and we can extend this class So A is correct
B is incorrect as Ww is a final class and we can’t extend a final class
C is incorrect as Ee is an inner class of class Bb and we can’t extend an inner class in this way
D is correct as class Dd is imported into the package with the line import pkg3.*; and Dd is an abstract class but any class can extend and abstract class


















QUESTION 341

Given: 

1. public class Simple { 
2.    public float price; 
3.         public static void main (String [] args) { 
4.                  Simple price = new Simple(); 
5.                               price = 4; 
6.        } 
7. } 


Which will make this code compile and run?

Change line 5 to: 
price = 4f; 

Change line 5 to: 
price.price = 4; 

Change line 5 to: 
price = (float) 4; 

Change line 5 to: 
price = (Simple) 4; 

 


























Question 342

Given the code fragment:

class Student{
    String name;
    Int age;
}
public class Test{
    public static void  main(String[]  args){
       Student s1 = new Student();
      Student s2 = new Student();
       Student s3 = new Student();
 
	s1 = s3;		//6
	s3 = s2;		//7
	s2 = null;		//8
    }			//9
}			//10


Which statement is true?

A.	After line 8, three objects are eligible for garbage collection

B.	After line 8, two objects are eligible for garbage collection

C.	After line 8, one object is eligible for garbage collection

D.	After line 8, none of the objects are eligible for garbage collection

Answer: C
An object becomes eligible for garbage collection when there are no longer any references to it.
The object that s1 originally referred to is dereferenced by reassignment on lines //6, so after that point it is not accessible by any reference and becomes eligible for garbage collection.

















Question 343

Given: 

public class Test { 

            public static void main (String[] args) { 

                        char[] arr = {97, '\t', 'e', '\n', 'i', '\t', 'o'}; 

		for (char var: arr) { 

	                         System.out.print(var); 
		} 
		System.out.print("\nThe length is :" + arr.length); 
             } 
} 

What is the result?
A
a e 
The length is : 2 
B
a e 
i o 
The length is : 4 
C
aeio 
The length is : 4 
D
a e 
i o 
The length is : 7 
E
Compilation fails. 
Answer: D
This question is testing two things:
1.	If you know that you can assign a number to a char variable for its corresponding ASCII key value. (You can, compilation will not fail and 97 corresponds to ‘a’)
2.	Your knowledge of escape sequences.
•	Escape sequences are certain series of characters that; if placed inside a string/char, will represent something other than their literal value.
•	E.g. ‘\t’ is a tab, and ‘\n’ creates a new line.
•	So even though they are more than one character, java treats them as if they are single characters they are allowed in an array of chars.
•	Also, they are still counted towards the length of the array, so the length is 7.
•	Full list here: https://docs.oracle.com/javase/tutorial/java/data/characters.html









 
Question 344

Given the class definitions: 

class Shape { } 
class Square extends Shape { } 

Given the variable declarations: 

Shape shape1 = null; 
Square square1 = null; 


Which four compile?

A. shape1 = (Square) new Square(); 

B. shape1 = new Square(); 

C. square1 = (Square) new Shape();
 
D. square1 = new Shape(); 

E. square1 = new Square(); 
    shape1 = square1; 

F. shape1 = new Shape(); 
    square1 = shape1; 
Answers: A, B, C, E
You can have a super-class reference to a sub-class object, so B and E are fine
A and C use casting. A would work even without the cast, but C requires it; as otherwise it would be a sub-class reference to a super-class object which will not compile.
When the code in C is run, you will get a “ClassCastException”, which is a type of runtime exception, but it will compile in the first place, which is what the question asks.

Note that casting only changes the reference, not the object.

















 
Question 345

Given the code fragment:

class Student {
 
    int rollnumber;
    String name;
    List cources = new ArrayList();
    
    // insert code here
 
    public String toString() {
        return rollnumber + " : " + name + " : " + cources;
    }
}
And,
public class Test {
    public static void main(String[] args) {
        List cs = new ArrayList();
        cs.add("Java");
        cs.add("C");
        Student s = new Student(123, "Fred", cs);
        System.out.println(s);
    }
}
Which code fragment, when inserted at line // insert code here, enables class Test to print 123 :   Fred : [Java, C] ?
A
private Student(int i, String name, List cs) {
/* initialization code goes here */
}
B
public void Student(int i, String name, List cs) {
/* initialization code goes here */
}
C
Student(int i, String name, List cs) {
/* initialization code goes here */
}
D
Student(int i, String name, ArrayList cs) {
/* initialization code goes here */
}

Answer: C
A is a private constructor, which means you cannot create a Student, at least from another class.
B is a method, not a constructor
C works, it is a default constructor that takes the 3 variables that are passed in in the main method
D takes an ArrayList instead of a List. The line “List cs – new ArrayList();” creates a List reference to an ArrayList, the reference is what determines what is passed into methods. 




 
Question 346

Given:

public class Test{
        public static void main(String[] args) {
	int ar1[] = {2, 4, 6, 8};
	int ar2[] = {1, 3, 5, 7, 9};
	ar2 = ar1;
	for (int e2 : ar2) {
	System.out.println("  " + e2);
	}
         }
}

What is the result?
 
A.		2 4 6 8

B.		2 4 6 8 9

C.		1 3 5 7

D.		1 3 5 7 9


Answer: A
Ar2 is set to refer to the ar1 array, and then it is printed out using an enhanced for loop. Simple as that. I guess they expect you to wonder if the different number of elements in the arrays is a factor but it isn’t.













 
QUESTION 347

Given: 

public class Test2
{ 
	public static void doChange(int[] arr)
	 { 
		for (int pos=0; pos < arr.length; pos++)
		 { 
			arr[pos] = arr[pos] + 1; 
		 } 
	} 
	public static void main (String[] args) 
	{ 
		int[] arr = {10, 20, 30}; 

		doChange(arr); 

		for (int x : arr) 
		{ 
			System.out.print(x + ", "); 
		} 
		doChange(arr); 

			System.out.print( arr[0] + ", " + arr[1] + ", " + arr[2]);
	 } 
} 

What is the result?

11, 21, 31, 11, 21, 31 

11, 21, 31, 12, 22, 32 

12, 22, 32, 12, 22, 32 

10, 20, 30, 10, 20, 30 

Answer is B

When you pass an object to a method you can’t change what the object refers to but you can change the instance variables of the object (i.e the age of a dog). With arrays you can’t change that it will stay refer to the same array, but you can change the individual elements of the array. 
So in this example we pass our list of numbers, 10, 20, 30 to the doChange() method that adds one onto each one of these numbers, in main it now prints out the updated list, which will be
11, 21, 31
doChange() again takes this list and adds one onto each number in out list, then we print out each element of this list in main and we get
12,22,32
 
QUESTION 348

Given:

 public class Natural{

        private int I;				//!
         void disp(){
	while (i <= 5){
	         for (int i=1; i <=5;) {
                                   System.out.print(i + ” “);
                                    i++;
                           }
                           i++;
                   }
       }
        public static void main(String[] args) {
                    new Natural().disp();
        }
 }
 
What is the result?
 
A.	Prints 1 2 3 4 5 once

B.	Prints 1 3 5 once

C.	Prints 1 2 3 4 5 five times

D.	Prints 1 2 3 4 5 six times

E.	Compilation fails

Answer: D
In the main method a new Natural object is created and the disp() method is immediately called. (You can do this.)
The disp() method contains a while loop, which contains a for loop that prints 1 to 5. The while loop uses the private variable “i” to iterate itself. This variable is not given a value initially, so its default value is 0. The while loop then loops 6 times, as it iterates by 1 from 0 to 5 untill i is 6, at which point it stops.









 
Question 349

Given:

public class CheckIt { 
      public static void main (String[] args) { 
          if (doCheck()) { 
                        System.out.print("square "); 
          } 
          System.out.print("..."); 
      } 
      public static int doCheck() { 
      return 0; 
      } 
}

What is the result?

A. square ... 

B. …..

C. Compilation fails. 

D. An exception is through at runtime. 

Answer: C
The “if” statement in the main method tries to use the docheck() method as a boolean, but it returns an int, so it won’t compile
















 
Question 350

Given: 

public class Test { 
         public static void main(String[] args) { 
	int day = 1; 
	switch (day) { 
		case "7": System.out.print("Uranus"); 
		case "6": System.out.print("Saturn"); 
		case "1": System.out.print("Mercury"); 
		case "2": System.out.print("Venus"); 
		case "3": System.out.print("Earth"); 
		case "4": System.out.print("Mars"); 
		case "5": System.out.print("Jupiter"); 
	} 
          } 
} 

Which two modifications, made independently, enable the code to compile and run?
 
A. Adding a break statement after each print statement 

B. Adding a default section within the switch code-block 

C. Changing the string literals in each case label to integer 

D. Changing the type of the variable day to String 

E.	Arranging the case labels in ascending order 

Answers: C, D
The code will not run as is because the cause statement is looking for Strings, as indicated by double quotes “”.
C probably means to change every number in the cases from “x” to x, which will then be treated as ints and can be compared to the day variable.
D Would also work as then the variable will be a String and can be used to compare to the cases.

 
Question 351
Given:
Public static void main(String[]args){
String color = “Red”;
switch (color) {
		case “Red”:
			System.out.println(“Found Red”);
		case “Blue”:
			System.out.println(“Found Blue”);
			break;
		case “White”:
			System.out.println(“Found White”);
			break;
		default:
			System.out.println(“Found Default”);
}
}
Which of the following gives the valid output of the above code?
A.	Found Red
B.	Found Red Found Blue
C.	Found Default
D.	Compilation error
Answer B
Without a break statement after each switch case the proceeding cases are executed until it meets a break or there are no more case statements to execute.
 
QUESTION 352 
Given: 

public class Test { 
} 

From which class does Java compiler implicitly derive Test? 

A. Objects 

B. Class 

C. an anonymous class 

D. Object

Answer is D. Every class ultimately is derived from the object class. In this example we can see that class Test does not extend any class, which means that class directly extends the object class, so in effect this class looks like this
Public class Test extends Object{
}
Any class that does not explicitly extend another class always extends/inherits from the object class.
The hidden default constructor inside class Test also looks like this
Test(){
	Super();
}
This constructor is calling the no args constructor in the Object class













 
Question 353

Which access modifier makes a member available only to classes within the same package or subclasses?

A. private

B. protected

C.  public

D. package-private

Answer is B
Protected is within the same package or in subclasses



 
Question 354 

Given:


class Caller{
	public static void call() {
		System.out.println("Called");
	}
}
public class TestCall {

	public static void main(String[] args) {
	        // insert code here
	}
}

Which two snippets,inserted independently at // insert code here, enable the code to compile and run?

A. new Caller().call();

B. call();

C. Caller.call();

D. Caller c;
     c.call();

E. Caller().call();

A is correct, you can create a object and then call a method at the same time

B is trying to call a method from a different, unrelated class without using a fully qualified name (Caller.call()), or accessing it through an object (which would be ill advised since it is a static method)

C works. call() is a static method so it can be called through the class directly.

D The caller object is not initialized, we have to initialise the Caller object to call any methods of the class

E doesn’t work, You need to use the new keyword to use the constructor in another class.









 
Question 355

Given the code fragment:

class DBConfiguration {

	String user;
	String password;
}

And:

 public class DBHandler {

     	 DBConfiguration configureDB ( String uname, String password ) {

         		 // insert code here
     	}
 	 public static void main(String[] args) {

         		DBHandler r = new DBHandler();

        	 	DBConfiguration dbConf = r.configureDB( "manager", "manager" );
   	 }
 }

Which code fragment must be inserted at line 6 to enable the code to compile?


A.  DBConfiguration f;
	return f;

B.  return DBConfiguration;

C.  return new DBConfiguration();

D.  return 0;


Answer C
In A, the DBConfiguration it tries to return is never initialized, so it can’t be returned.
B is nonsense, you have to create an instance of the class, you can’t just return the class.
C works, it creates a new DBConfiguration object and returns it.
D doesn’t work, you can’t have an object with a value of 0. The closest thing would be null













Question 356

Given:

public class X {

	public static void main(String[] args) {

	      String theString = "Hello World";

		System.out.println(theString.charAt(11));  11/12
	}
}

What is the result?

A. The program prints nothing.

B.  d

C.  A StringIndexOutOfBoundsException is thrown at runtime.

D.  An ArrayIndexOutOfBoundsException is thrown at runtime.

E.  A NullPointerException is thrown at runtime.


Answer C

The String theString contains 11 characters, so trying to access the 12th character will give you a StringIndexOutOfBoundsException. Note that indexing starts at 0, but even if it didn’t this would still be the answer in this case.











 
Question 357

Given:

Given:
class X {
public void nX() {
System.out.println("Xn1");
}
}
class Y extends X {
public void nX() {
System.out.println("Xn2");
   	}
public void nY() {
System.out.println("Yn");
}
}
public class Test {
public static void main(String[] args) {
X xRef = new Y();
Y yRef = (Y)xRef;
yRef.nY();
xRef.nX();
}
}
What is the result?
A.	Yn Xn2
B.	Yn Xn1
C.	Compilation fails
D.	A ClassCastException is thrown at runtime
Answer A
xRef is a Y object with a X reference. When xRef.nX is called it looks to the Y class for it implementation. yRef is xRef(Y object with X Reference) cast to a Y reference allowing it to call yRef.nY








 
Question 358

Given:

1. import java.ib.Error;
2. public class TestApp {
3. 	public static void main(String[] args) {
4.		TestApp t = new TestApp();
5.		        	try {
6.				t.doPrint();
7. 				t.doList();
8.
9. 			} catch (Exception eZ) {
10.				System.out.println("Caught " + eZ);
11. 			   }
12.		 }
13.		public void doList() throws Exception {
14. 			throw new Error("Error");
15.		}
16. 		public void doPrint() throws Exception {
17. 			throw new RuntimeException("Exception");
18. 		}
19. }


What is the result?

A. 	Caught java.lang.RuntimeException: Exception
	Exception in thread "main" java.lang.Error: Error
		at TestApp.doList(TestApp.java: 14)
		at TestApp.mainJ(TestApp.java: 6)

B. 	Exception in thread "main" java.lang.Error: Error
		at TestApp.doList(TestApp.java: 14)
		at TestApp.main(TestApp.jave: 6)

C.	Caught java.lang.RuntimeException: Exception
	Caught java.lang.Error: Error

D.	Caught java.lang.RuntimeException: Exception


Answer D

Line 6  t.doPrint() cause exception. At line 16-17 method throw RuntimeException which is caught by catch statement. Output is : Caught java.lang.RuntimeException: Exception 
If method at line 13-14 will throw new Error program will crash, because catch(Exception e) is not for catching Errors.



 
Question 359

Given:

public class Access {

	private int x = 0;
	private int y = 0;

	public static void main(String[] arge) {

	            Access accApp = new Access();
		accApp.printThis(1, 2);
		accApp.printThat(3, 4);
	}
	public void printThis(int x, int y) {

		x = x;
		y = y;		default values

		System.out.println("x:" + this.x + "y:" + this.y);
	}
	public void printThat(int x, int y) {

		this.x = x;
		this.y = y;

		System.out.println("x:" + this.x + "y:" + this.y);
	}
}

What is the result?

A.  x:1 y:2
      x:3 y:4

B.  x:0 y:0
      x:3 y:4

C.  x:1 y:2
      x:0 y:0

D.  x:0 y:0
      x:0 y:0

Answer B
The printThis() method does not do anything with the instance variables of the object calling it, it just sets the local variables that were passed in to themselves, so x to x and y to y, effectively doing nothing. Since the x and y instance variables both have default values of 0, that is what is printed out on the first line.
printThis() uses the “this” keyword to assign the values of the variables that were passed in to the instance variables of the object calling it. Since 3 and 4 are passed in this is printed out later


 
Question 360

Given:

public class Test2 {

	public static void doChange(int[] arr) {

		for (int pos = 0; pos < arr.length; pos++) {

			arr[pos] = arr[pos] + 1;
		}
	}
	public static void main(String[] args) {

		int[] arr = {10, 20, 30};

		doChange(arr);

		for (int x : arr) {

			 System.out.print(x + ", ");
		}
		doChange(arr[0], arr[1], arr[2]);			< -- call to Test2 with different arguments

			  System.out.print(arr[0] + ", " + arr[1] + ", " + arr[2]);
	}
}

What is the result?

A.  11, 21, 31, 11, 21, 31

B.  11, 21,31, 12, 22, 32

C.  12, 22, 32, 12, 22, 32

D.  10, 20, 30, 10, 20, 30

E.  Compilation fails.


Answer E
The method doChange takes an array of ints, so if we attempt to send it anything else will result in a compliation error. The line 
doChange(arr[0], arr[1], arr[2]);	
is attempting to call the doChange method, but it is NOT sending an array of ints to the method, it is trying to send three ints to the method, and there is no method that takes three ints in this code.




 
Question 361

Given:

public class Jump {

	static String args[] = { "lazy", "lion", "is", "always" };

		public static void main(String[] args) {

			System.out.println( args[1] + " " + args[2] + " " + args[3] + " jumping");
	}
}
And the commands:

javac Jump.java
java Jump crazy elephant is always

What is the result?


A. lazy lion is jumping

B. lion is always jumping 

C. crazy elephant is jumping 

D.elephant is always jumping

E. Compilation fails.


Answer D

Program compile and run with output:  "elephant is always jumping"
In the commands we passing to main method four Strings. Declared  String args[ ] is not even touched.
Position args [0] = "crazy", args [1] = "elephant", args [2] = "is" , args [3] = "always"












 
Question 362

Given:

public class MyFor{

	public static void main(String[] args) {

		int[] x = { 6, 7, 8 };

		for (int i : x) {

		       System.out.print( i + " " );
		       i++;
		}
	}
}

What is the result?

A.  6 7 8

B.  7 8 9 

C.  0 1 2

D.  6 8 10

E.  Compilation fails.


Answer A


An array is an indexed collection of elements of a single type that is specified when the array is declared.
Enhance for loop  iterate on elements from the collection (array) x. The current element will be referenced by the int i.   You don't need to determine how many elements are in the array before looping. There is also no need to specify how to increment the current position.















 
Question 363

Given:

class Testa {

	int sum = 0;

	public void doCheck(int number) {

		if (number % 2 == 0) {
	  	     break;					< -- cannot be used outside 
		}
		 else {
	    	               for (int i = 0; i < number; i++) {
			     sum += i;
		               }
		}
	}
	public static void main(String[] args) {

		Test obj = new Test();
		System.out.println("Red " + obj.sum);
		obj.doCheck(2);
		System.out.println("Orange " + obj.sum);
		obj.doCheck(3);
		System.out.println("Green " + obj.sum);
	}
}

What is the result?

A.   Red 0 
       Orange 0
       Green 3

B.   Red 0 
       Orange 0
       Green 6

C.   Red 0 
      Orange 1
      Green 4

D.  Compilation fails.


Answer D
A Break statement cannot be used outside of a switch statement or a loop. Here it is used only inside a if statement, however if the “if” statement was inside a loop then it could be used here, but it would be breaking out of the loop not the “if” statement.

 
QUESTION 364

Given the code fragment? 

public class Test { 

public static void main(String[] args) { 

             Test t = new Test(); 
              int[] arr = new int[10]; 
              arr = t.subArray(arr,0,2); 

} 

  // insert code here 
} 

Which method can be inserted at line // insert code here to enable the code to compile? What is the result?


A public int[]subarray(int[]src,int start,int end){
	Return src;
}
B. public int subarray(int src,int start,int end){
	Return src;
}
C. public int[]subarray(int src,int start,int end){
	Return src;
}
D. public int subarray(int[]src,int start,int end){
	Return src;
}

Answer is A
From this line of code
arr = t.subArray(arr,0,2); 
we can see that this method returns an array on ints, and takes a array of ints, a int and a int. 
A is correct as this is returning an array and is taking the right amount of arguments and argument type
B is incorrect as this is returning an int and it’s first argument is an int not an array
C is incorrect as the first argument is an int not an array
D is incorrect as this is returning an int, not an array of ints






 
Question 365
Given the code fragment:

public class App {
            void calcBill() {

                   // Line n1

                new Invoice().print();
             }
}
Which code fragment can be inserted at Line n1 to enable the class compile?

A. private class Invoice{
	Void print(){System.out.println(“invoice Printed”);}
}
B. public class Invoice{
	Void print(){System.out.println(“invoice Printed”);}
}
C. class Invoice{
	Void print(){System.out.println(“invoice Printed”);}
}
D. protected class Invoice{
	Void print(){System.out.println(“invoice Printed”);}
}

Inner classes are not on this exam, however access modifers are, which is what this question is about.
There is one basic rule that applies to inner classes as well as variables inside a method. Variables inside a method cannot have any access modifiers (public, private, protected) and the same rule applies to inner classes that are defined inside a method. So we are trying to define an inner class that is inside the calcBill() method, so in order for this to compile the class CANNOT have any access modifier, so the only one that will work is 
C.   class Invoice {
      void print() { System.out.println("Invoice Printed"); }no modifires
      }
As this has not access modifier









 
Question 366

Which of the following will return the position of the first letter a where the string s contains "banana"?


A. lastIndexOf(2,s);

B. s.indexOf('a');

C. s.charAt(2);

D. Of(a,'v');

A is incorrect 
There is no overloaded method lasIndexOf() that takes a int and string, there is a lastIndexOf() that takes a String and an int.
B is correct
This will get the first position of “a” in the word “banana”
C is incorrect
This will return the character at index postion 2 in the word “banana”, which is “n”
D is incorrect
of() methods are methods of the locatDate, localTime and localDateTime classes not of the String class



































 
Question 367

Which of the following statements will compile without an error?


A. int myArray[];

B. int myArray[5];

C. int myArray[5] = {1,2,3,4,5};

D. int myArray[] = {1,2,3,4,5};

A is correct
This is just creating an array reference
B is incorrect
You can’t give a length to an array without assigning it to an array reference.
C is incorrect
Length of an array can only be given in the right hand side of an assignment statement.
D is correct
This is creating an array reference and then assigning 5 numbers to this array which gives it a length of 5.

























 
Question 368

Given: 

public class Test1 { 
      static void doubling (Integer ref, int pv) { 
                 ref =20; 
                 pv = 20; 
} 
public static void main(String[] args) { 
       Integer iObj = new Integer(10); 
                 int iVar = 10; 
                 doubling(iObj++, iVar++); 
System.out.println(iObj+ ", "+iVar); 
}

What is the result? 

A. 11, 11 

B. 10, 10 

C. 21, 11 

D. 20, 20 

E. 11, 12


Answer: A (Assuming that missing “}” are included)
In the main method an Integer wrapper object, iObj, is declared and assigned an initial value of 10. This wrapper object is passed as an argument to the method doubling, along with a primitive integer variable, iVar. The doubling method does not change the value of either iObj or iVar in the main method. The values of iObj and iVar are incremented in the main method. The code then prints out the values of iObj and iVar which are 11 and 11. Therefore the correct answer is A.  











 
Question 369

Given:

public class TestStudent {			field
         public static void main(String[] args) {
                Student bob = new Student ();
                         bob.name = "Bob";
                         bob.age = 33;
                         bob.year = 1982;
}
}

What is the result?

A. year is set to 1982.

B. bob.year is set to 1982

C. A runtime error is generated.

D. A compile time error is generated.

Answer is D
The name of the class is TestStudent, not Student, so in order to create a object of this class we would have to go
TestStudent bob = new TestStudent().
Also this class has no attributes called name, age or year.





















 
Question 370

Given:

public class Two {
	public static void main(String[] args) {
	try {
1		doStuff();
		System.out.println("1");
	}
	catch(Exception re) {
		System.out.println("2");	2
	
	}
	}
	public static void doStuff()
	{
		if (Math.random() > 0.5) throw new RuntimeException();  
3			doMoreStuff();
			System.out.println("3 ");
	}
4	public static void doMoreStuff() {
		System.out.println("4");
	}
}

Which two are possible outputs?

A. 2

B. 431

C. 1

D. 12

A is correct
If Math.random() produces a number greater than 0.5,then a RunTimeException is generated, which means the rest of the doStuff() method is not called and doMoreStuff() is not called either.
The code in the try block after doStuff is not executed, the RuntimeException generated is caught in the catch block and prints out “2”
B is correct
If Math.random() produces a number less than 0.5, no RuntimeException is generated. The doMoreStuff() method is called, and 
4 
is printed.
Then the rest of code in doStuff is printed, and
3 
Is printed.
The rest of the try block is excuted in the and 
1 
Is printed.
C is incorrect
D is incorrect
 
Question 371
Given:
package p1;
public class Test {
static double dvalue;
static Test ref;
public static void main(String[] args) {
System.out.println(ref);
System.out.println(dvalue);
}
}

What is the result?

A. p1.Test.class
0.0
B<Summary addressreferenced by ref>
0.000000
C. Null
0.0
D Compilation Fails
E. NullPointerException is thrown at Runtime

Answer is C
Instance variables are given default values. For all numeric data type the default value is always 0. For objects the default data type is always null. This holds true for both static and non static instance variables
 
Question 372
Which statement is true about the default constructor of a top-level class?

A. It can take arguments
B. It has private access modifier in its declaration.
C. It can be overloaded 
D. The default constructor of a subclass always invokes the no-argument constructor of its superclass.
The answer is D
The default constructor of a class is a hidden constructor that takes no arguments, and it always calls at Least the no args constructor in the object class as all objects in java ultimately are inheritied from the object class.

 
Question 373
Given the following code
int var1 = -5;
int var2 = var1--;
int var3 = 0;
if (var2 < 0) {
var3 = var2++;
} else {
var3 = --var2;
}
System.out.println(var3);
What will print out?
A. 6
B. 4
C. -5
D. 5
E. -4
F. Compilation Fails

The answer is C
Var1is set to -5
Var2=var1--, which sets Var2=-5 and THEN decrements var1 by one
So var2=-5
Var2<0 is true
So var3=var2++, sets the value of var3=-5 and THEN increments var2 by one
So var3 is now -5

 
Question 374
Given the code fragment:
String[] cartoons = {"tom","jerry","micky","tom"};
int counter =0;
if ("tom".equals(cartoons[0])) {
counter++;
} else if ("tom".equals(cartoons[1])) {
counter++;
} else if ("tom".equals(cartoons[2])) {
counter++;
} else if ("tom".equals(cartoons[3])) {
counter++;
}
System.out.print(counter);
What is the result?

A. 1
B. 2
C. 4
D. 0

Correct Answer A
We have an array of strings, and we are using the int counter to check each string in this array. The statement 
if ("tom".equals(cartoons[0])) {
calls the equals method on the string “tom”, it then checks the first string in the cartoon array, which is “tom”, so this returns true and then increments our counter by 1, so counter becomes 1.

 
Question 375
Given:
public class TestLoop1 {
public static void main(String[] args) {
int a = 0, z=10;
while (a < z) {
a++;
--z;
}
System.out.print(a + " : " + z);
}
}
What is the result?
A. 5:5
B. 6:4
C. 6:5
D. 5:4

Correct Answer: A
Our loop produces the following during each loop
While(0<10)
(1<9)true
(2<8)true
(3<7)true
(4<6)true
(5<5) false
So final value of a and z is 5,5

 
Question 376
Given:
public class Painting {
private String type;
public String getType() {
return type;
}
public void setType(String type) {
this.type = type;
}
public static void main(String[] args) {

Painting obj1 = new Painting();
Painting obj2 = new Painting();
obj1.setType(null);
obj2.setType("Fresco");
System.out.print(obj1.getType() + " : " + obj2.getType());
}
}

What is the result?
A. : Fresco
B. null : Fresco
C. Fresco : Fresco
D. A NullPointerException is thrown at runtime
Correct Answer: B
The painting object has a instance variable/field String variable called type. We then have two methods, one of which sets the String variable type(setType()) and another that gets the String variable  type (getType()). 
We create two painting objects we then set the type variable  to null for the first object, which we can do as a string is an object and any object can be set to null. The second objects type variable is set to “Fresco”. The getType method is called for both objects, the type for obj1 is null, the type for obj2 is “Fresco”.

 
Question 377
Given
Int row=10;
for(;row>0;){
Int col=row;
While(col>=0){
System.out.println(col+” “);
col-=2;
}
Row=row/col;
}

What is the result?
A. 10 8 6 4 2 0
B. 10 8 6 4 2
C. An ArithmeticException is thrown at runtime
D. The program goes into an infinite loop outputting: 10 8 6 4 2 0. . .
E. Compilation fails

Correct Answer: A
It is valid not to have any parameters in a for loop, like the following for(;;), so there is nothing wrong with this for loop. Inside the for loop col=row, sets col=10, and while col is greater than or equal to zero it will print out col. It decrements by 2 each time, so this will print 10,8,6,4,2,0. When col is 0, col>=0 is still true, so this will print out 0, and then decrements col by 2 so col then becomes -2. 
So -2>=0 is false and the while loop exits at this point. 
Then we have row=row/col
Which is row=10/-2 which is -5 and this causes the for loop to exit as
For(;-5>0;) is true. 
If this question was in the while loop 
While(col>0) this cause a arithmetic exception as the final value of col would be 0 and then the line 
Row=10/0 would generate the exception.

 
Question 378
Given
public class Series{
public static void main (String [] args) {
int arr[] = {1,2,3};
for (int var : arr) {
int I = 1;
while (I <= var);
System.out.println (i++);
}
}
}
What is the result?

A. 1
B. 3
C. 2
D. Compilation fails
E. Loop executes infinite times

Correct Answer: E
Normally we deal with while loops like the following:
While(num<5)
{
Int num2=++num;
}
However there is nothing wrong with something like
while (I <= var);
but the “;” finishes the while loop at that point, so this loop is doing nothing inside it, which also means that there is not way for it to exit the loop, so this will be a infinite loop.

 
Question 379
Given 
Public class Test{
Public static void main(String[] args){
Integer num=Integer.parseInt(args[1]);
System.out.println(“Number is “+num);
}
}
And the commands 
Javac Test.Java
Java Test 12345 the result
What is?

A. Number us : 12345
B. A NullPointerException is thrown at runtime
C. A NumberFormatException is thrown at runtime
D. AnArrayIndexOutOfBoundException is thrown at runtime.

Correct Answer: D
The command javac Test.java first compiles the file correctly
The command Java Test 12345, passes the string “12345” into the string array args, and places it at index position 0 on the array, args[0]=”12345”.
It then attempts to assign a value to num by the following line of code
Integer num=Integer.parseInt(args[1]);
This will call an arrayIndexOutOfBounds as our array args, as it only has a length of 1, and you can only access args[0], not args[1] like here

 
Question 380
View the exhibit:
public class Student {
public String name = "";
public int age = 0;
public String major = "Undeclared";
public boolean fulltime = true;
public void display() {
System.out.println("Name: " + name + " Major: " + major); }
public boolean isFullTime() {
return fulltime;
}
}
Given:
Public class TestStudent {
public static void main(String[] args) {
Student bob = new Student ();
bob.name = "Bob";
bob.age = 18;
bob.year = 1982;
}
}
What is the result?

A. year is set to 1982.
B. bob.year is set to 1982
C. A runtime error is generated.
D. A compile time error is generated.

Correct Answer: D

There is NO year field in the student class, so this will cause a compilation error

 
Question 381
. class StaticMethods {
2. static void one() {
3. two();
4. StaticMethods.two();
5. three();
6. StaticMethods.four();
7. }
8. static void two() { }
9. void three() {
10. one();
11. StaticMethods.two();
12. four();
13. StaticMethods.four();
14. }
15. void four() { }
16. }
Which three lines are illegal?

A. line 3
B. line4
C. line 5
D. line 6
E. line 10
F. line 11
G. line 12
H. line 13
Correct Answer: CDH
A is incorrect as two()is a static method and we are inside a static method and you can call a static method from inside another static method
B is incorrect as you can call a static method by using the class name in front of the static method name and we are also inside a static method when calling this method
C is correct as three() is not a static method as you can’t call a non static method from a static method
D is correct as four()is not a static method and you are trying to call a instance method by using a method that can only call a static method (class name+static method name)
E is incorrect as you can call both static and non static method from inside a instance method
F is incorrect as you can call a static method this way and also you can call static methods inside a instance method
G is incorrect as four() is an instance method and  you can call an instance method from a instance method
H is correct for the exact same reason as D

 
Question 382
Given:
public class MyFor {
public static void main(String[] args) {
for (int ii = 0; ii < 4; ii++) {
System.out.println("ii = "+ ii);
ii = ii +1;
}
}
}
What is the result?
A. ii=0
Ii=2
B. ii=0
Ii=1
Ii=2
Ii=3
C. ii=
D. Compilation Fails

Correct Answer: A
This for loop adds one to ii twice, once as one of the arguments of the for loop, and once inside the for loop itself. So the first value of I =0, then iterates by 2 for the above reasons, 1=2, then iterates by 2, i=4. So I is now greater than 4 and our for loop exits
 
Question 383
Given
Class X{
Static void m(int i){
I+=7;
}

Public static void main(String[]args){
Int j=12;
m(j);
system.out.println(j);
}
}

What is the result?

A. 7
B. 12
C. 19
E. An exception is thrown at runtime

Answer is B
Remember that when you pass a primitive variable to a method it is passed by value, so its value will not be changed in the calling method. So the value stays the same, 12.

 
Question 384
Given
Public abstract class Wow{

Private int wow;
Public wow(int wow){
this.wow=wow;
}
Public void wow(){}
Public void wowza(){}
}

What is true about the class Wow?
A. It compiles without error.
B. It does not compile because an abstract class cannot have private methods.
C. It does not compile because an abstract class cannot have instance variables.
D. It does not compile because an abstract class must have at least one abstract method.
E. It does not compile because an abstract class must have a constructor with no arguments.

A is correct
You have a abstract class called Wow, inside the class you have a attribute of the class an int called wow. You have a public constructor for the Wow class, where you assgning a value sent to it to the attribute wow. You have a method called wow that returns void

 
Question 385
Given
public class SampleClass {
public static void main(String[]args){
SampleClass sc,scA,scB;
sc=new SampleClass();
scA=new SampleClassA();
scB=new SampleClassB();
System.out.println();
}

public int getHash(){
return 11111111;
}
}

class SampleClassA extends SampleClass{

public long getHash(){
return 44444444;
}

}
class SampleClassB extends SampleClass{
public long getHash(){
return 999999999;
}
}
What is the result?

A. Compilation fails
B. An exception is thrown at runtime
C. There is no result because this is not correct way to determine the hash code
D. Hash is: 111111, 44444444, 999999999
Answer is A
The method getHash is overridden in both of the extended classes, however in overridden methods the method signatures have to match exactly when the return type is a primitive type (if the return type is an object, the overridden method can be sub class of the base method return type). Here the return type in the base method is “int” and in the overridden method it is “long”. So it is not the same method signature for a overridden method, so it will NOT compile

 
Question 386
Given the code fragment
Public class X implements Z{
Public String toString(){
Return “I am X”;
}
Public static void main(String[] args){
Y myY=new Y();
X myX=myY;
Z myZ=myX;
System.out.println(myZ);
}
}
Class Y extends X{
Public String toString(){
Return “I am Y”;
}
}
Interface Z{ }
What is the reference type of myZ and what is the type of the object it references?
A. Reference type is Z; object type is Z.
B. Reference type is Y; object type is Y.
C. Reference type is Z; object type is Y.
D. Reference type is X; object type is Z.

Answer is C
Reference is on the left, object type in on the right. 
The reference is the easy part, we just go to the myZ reference and we see that it is a Z reference
Z myZ
The object is the more difficult part, the line
Z myZ=myX;
Tells you myZ references the object myX, we then go to see what type of object myX is and the line
X myX=myY;
Tells you myX references the object myY, we then go to see what type of object myY is and the line 
Y myY=new Y() tells me that this is a Y Object, which is our final answer.

 
Question 387
Given the code fragment:
Boolean b1 = true;
Boolean b2 = false;
int i = 0;
while (foo) { }

Which one is valid as a replacement for foo?
A. b1.compareTo(b2)
B. i = 1
C. i == 2? -1 : 0
D. "foo".equals("bar")

Answer is D
while loop clause has to evaluate to a boolean, which is true or false
A is incorrect as the compareTo() method returns 1 if they match, 0 if they don’t’
B is incorrect as this is not a boolean
C is incorrect as this ternary operator will equate to either a -1 or 0 which is an int, and not a boolean.
D is correct as this will return false, which is a boolean.

 
Question 388
Public class MyFive{
Public static void main(String[] args){
short ii;
short jj=0;
for(ii=kk;ii>6;ii-=1){ //line x
jj++;
}
System.out.println(“jj = “ + jj);
}
}
What value should replace kk in line x to cause jj=5 to be output?
A. -1
B. 1
C. 5
D. 8
E. 11

Answer is E
Options A,B,C are incorrect as they are all less than 6, so this mean the loop will never be entered.
D is incorrect as the value of jj will be 2 after this loop
E is correct as the value of jj will be 5 after the loop

 
Question 389
Given
Public class DoWhile1{
Public static void main(String[]args){
Int ii=2;
do{
system.out.println(ii);
}while(--ii);
}
}
What is the result?

A. 2
B. 2
C. null
D. an infinite loop
E. compilation fails

Answer is E
A do while has to evaluate to a boolean and here (while—ii) is NOT a boolean so this will not compile.

 
Question 390
Given
Public class Simple{
Public float price;//line 2
Public static void main(String[]args){
Simple price=new Simple();//line 4
price=4;//line 5
}
}

What will make this code compile and run?
A. change line 2 to the following:
public int price
B. change line 4 to the following:
Int price=new Simple();
C. Change line 4 to the following:
float price=new Simle();
D. Change line 5 to the following:
price=4f
E. Change line 5 to the following:
price.price=4
F. Change line 5 to the following:
price=(float)4
G. Change line 5 to the following:
price=(simple)4
H. the code compiles and runs properly, no changes are necessary

Answer is E
In this code price=4 is trying to assign the int 4 to the Simple object price, as inside the main method price refers to this object, NOT the instance variable price of type float. So to access the instance variable price of the Simple object price we have to go
price.price=4
important to note, this is not recommended practise to give a objects variable name the same as a field/instance variable as it is confusing.

 
Question 391
Given
public class Basic{
private static int letter;
public static int getLetter();
public static void Main(String[]args){
system.out.println(getLetter());
}
}

Why will the code not compile

A. A static field cannot be private.
B. The getLetter method has no body.
C. There is no setLetter method.
D. The letter field is uninitialized.
E. It contains a method named Main instead of main

Answer is B
A non-abstract method MUST have a body, even an empty body will suffice, and the getLetter method in this example has no body {}.
A is incorrect a static method CAN be private
C is incorrect, you do not HAVE to have a setter() method, in fact you can have a class without any methods at all
D is incorrect as all attributes of a class are given default values, 0 for all numbers, false for booleans, blank space for char and null for all objects. This applies to both static and non static attributes.
E is incorrect
There is nothing wrong with this method, it is NOT the main method we use to run all of our programs as it has a different case (“Main” instead of “main”), but there is nothing wrong with creating a method called “Main”, just that this will not run our programs and output to the screen.

 
Question 392
Given the code fragment:
If(value>=0){
If(value!=0)
System.out.print(“the “);
Else
System.out.print(“quick “);
If(value<10)
System.out.print(“brown “);
If(value>30)
System.out.print(“fox “);
else if(value<50)
system.out.print(“jumps “);
else if(value<10)
system.out.print(“over “);
else
system.out.print(“the “);
if(value>10)
system.out.print(“lazy “);
}
else{
system.out.print(“dog “);
}
System.out.println(“…”);

What is the result if the integer value is 33?

A. the fox jump lazy ...
B. the fox lazy ...
C. Quick fox over lazy ...
D. Quick fox the ....
Answer is B
You have a series of if’s and else and else/if statements inside an if statement, so the key here is to know what else and else if belongs to what if.
Value is greater than 0 so it enters at if(value>=0){
The value is NOT 0 so it prints out “the”
The next if triggered is the if(value>30), so it prints out “fox”
The two-following else if and the else all belong to this if, so they are not triggered
The if(value>10) is triggered as value is greater than 10, so it prints out “lazy”.
The outer if block is exited and the else that belongs to it is NOT triggered.
Finally the “…” string is printed

 
Question 393
Given
Int[]array={1,2,3,4,5};
system.arraycopy(array,2,array,1,2);
system.out.print(array[1]);
system.out.print(array[4]);
What will print out

A 1 2
B 2 3
C will not compile
D ArrayIndexOutOfBounds exception
E 4 4
F 3 5

Answer is F
the line
system.arraycopy(array,2,array,1,2);
is copying the numbers starting at index position 2 (3,4,5) to start at index position 1 and go as far as index position 2, so only two numbers will be copied 
1,2,3,4,5
And we end up with
1,3,4,4,5
We then are printing out at index position 1, which is 3
And at index position 4, which is 5

 
Question 394
Which statement initializes a stringBuilder to a capacity of 128?

A. StringBuilder sb = new String ("128");
B. StringBuilder sb = StringBuilder.setCapacity (128);
C. StringBuilder sb = StringBuilder.getInstance (128);
D. StringBuilder sb = new StringBuilder (128);

Answer is D
A is incorrect as you directly assign a string to a stringBuilder object reference, this is how you do it
StringBuilder sb=new StringBuilder(“myString”); 
B is incorrect at there is no static method in the StringBuilder class called setCapacity, there is a NON static method called ensureCapacity()
C is incorrect as there is no static method in the StringBuilder class called getInstance()
D is the correct way to initialise a stringBuilder object with an initial capacity of 128

 
Question 395
//line 5 insert code here
public abstract void bark();
}

//line 9 insert code here
public void bark(){
system.out.println(“woof”);
}
}

What code should be inserted at line 5 and line 9 to enable the code to compile?
A
5.class Dog{
9.public class Poodle extends Dog{
B
5.abstract Dog{
9.public class Poodle extends Dog{
C
5.abstract class Dog{
9.public class Poodle extends Dog{
D
5.class Dog{
9.public class Poodle implements Dog{
E
5.abstract Dog{
9.public class Dog implements Poodle{
F
5.abstract class Dog{
9.public class Poodle implements Dog{

Answer is C
This code is the layout of a super abstract class and a inherited class that overrides a method from the abstract class.
The code public abstract void bark(); tells us that this has to be inside an abstract class or an interface, as a abstract method can only exist inside a abstract class or an interface. You have to use the keywords “abstract class” to make Dog both a class and abstract.
We have two bark() methods that have the same method signature, which you cannot have, so that means these have to be in two different classes. The only options we are given means that this class extends the Dog class. A class can ONLY EXTEND another class, NOT IMPLEMENTS. The only option the fulfils all these criteria is C.

 
Question 396
Given
public class Main{
public static void main(String[]args)throws Exception{
doSomething();
}
Private static void doSomething()throws Exception{
System.out.println(“Before if clause”);
If(Math.random()>0.5){
Throw new Exception();
}
System.out.println(“After if clause”);
}
}

Which two are possible outputs?

A
Before if clause
Exception in thread “main” java.lang.Exception
At Main.doSomething(main.java:8)
At Main.main(Main.java:3)
B
Before if clause
Exception in thread “main” java.lang.Exception
At Main.doSomething(main.java:8)
At Main.main(Main.java:3)
After if clause
C
Exception in thread “main” java.lang.Exception
At Main.doSomething(main.java:8)
At Main.main(Main.java:3)
D
Before if clause
After if clause

Answer A,D
If a exception is thrown it either has to be caught or handled by a throws clause in the method signature. It ultimately has to get handled somewhere, so if you keep throwing it and get back to main and have a throws clause there, it will throw it back to the compiler and your program will generate an exception and crash. Nothing after this happens can happen with your program. So in this example a new Exception MAY be thrown, it is dependant on this line of code
If(Math.random()>0.5){
Throw new Exception();
}
Math.random produces a random number between 0 and 1.0, so if this number is greater than 0.5 and exception is produced, so the line
(“After if clause”);
Can never be reached as a exception is generated. So only “Before if Clause” is printed and then an exception generated
If no exception is generated, and even if your method has a throws exception clause in the method signature, then your program will compile and run fully. As it will if the random number generated is less than 0.5. In this case the print out will be Before if clause and After if clause.

 
Question 397
Given
public class Speak{
public static void main(String[]args){
Speak speakIt=new Tell();
Tell tellIt=new Tell();
speakIt.tellItLikeItIs();//line 5
(Truth)speakIt.tellItLikeItIs();//line 6
((Truth)speakIt).tellItLikeItIs();//line 7
tellIt.tellItLikeItIs();//line 8
(Truth)tellIt.tellItLikeItIs();//line 9
((Truth)tellIt).tellItLikeItIs();//line 10
}
}
class Tell extends Speak implements Truth{
public void tellItLIkeItIs(){
system.out.println(“Right on”);
}
}
Interface Truth{public void tellItLikeItIs();}

Which three lines will compile and output "right on!"?

A. Line 5
B. Line 6
C. Line 7
D. Line 8
E. Line 9
F. Line 10

Correct Answer: CDF
A will not compile as the speakIt object is a superclass Speak reference to a subclass Tell object, so it only has access to methods FIRST defined in the Speak class, and would take it’s implementation from the sub class Tell object, if there was any implementation of the method in the Tell class.
B will not compile as it is trying to cast the WHOLE METHOD CALL speakIt.tellItLikeItIs to be of type Truth, and this method return void 
C is correct as you are casting the speakIt object to be of type “Truth”, this will have the effect of changing the reference of this object, so it will now look like.
Truth speakIt=new Tell();
You can have an interface reference to a class that implements that interface and the Tell class does indeed implement the Truth Interface. This is the correct way to cast an object to be of reference type “Truth” and THEN call the method tellItLikeItIs
D is correct as tellIt is a Tell reference to a Tell object and the tell class does have a tellItLikeItIs() method which will print out “right on”
E is incorrect as you are trying to again cast an entire method to be of type Truth
F is correct as the tellIt object already can call this method as it already does implement the Truth interface, so this casting is doing nothing new and not changing the object, but it is not an error to do this.
Question 398
Given: 
class X 
static void m (int[] i) {
 i[0] += 7;
 }
 public static void main (String[] args) {
 int[] j = new int[1]; 
j[0] = 12; 
m(j); 
System.out.println(j[0]); 
} }
 What is the result?

A.7
B.  12
C. 19
D. Compilation fails.
E. An exception is thrown at runtime

Answer is C
When you pass a object to a method, you cannot change what object this reference points to. I.e when you pass spot the dog to a method, you can’t change that it will always return the same Dog. You can change the instance variables/fields of object, i.e the age of a Dog. Similarly when you pass an array to a method, as an array is an object, you can’t change the array (in other words you pass it a list called nameList, you can’t change that fact that this object will be still nameList when it returns a value). However, you can change each of the individual items on the list if you pass an array to a method. So in this example we pass our array to the method m() and it adds 7 onto the number held in index postion 0, which is the number 12
So it’s 12+7 and the answer then is 19

 
Question 399
Given
// insert code here 

arr[0] = new int[3]; 
arr[0][0] = 1; 
arr[0][1] = 2; 
arr[0][2] = 3; 

arr[1] = new int[4]; 

arr[1][0] = 10; 
arr[1][1] = 20; 
arr[1][2] = 30; 
arr[1][3] = 40; 

Which two statements, when inserted independently at line // insert code here, enable the code to compile?

A. int [] [] arr = null;
B. int [] [] arr = new int [2];
C. int [] [] arr = new int [2] [ ];
D. int [] [] arr = new int [] [4];
E. int [] [] arr = new int [2] [0];
F. int [] [] arr = new int [0] [4];

Answer C, E
From line 3 to 12 of the program, it can be concluded that array size is of 2 x 4: 

int[][] arr = new int[2][4];
int rows = arr .length;
int columns = arr[0].length;
System.out.println(rows);// 2
System.out.println(columns);// 4

Option A, without a initilsed two-dimensional array object, will throw a NullPointerException when the array element is accessed later
Option B, which produces a one-dimensional array of objects, uses a two-dimensional array of patterns to store a compile error.
Option C, the correct use two-dimensional array , size also meet the needs
Option D, the wrong two-dimensional array of materialized way.
Option E, the correct two-dimensional array of physical way, size also meet the demand.
Option F, the correct two-dimensional array of materialized, but the size does not meet the demand.

 
Question 400
Consider:

Integer number = Integer.valueOf("808.1"); 

Which is true about the above statement?

A. The value of the variable number will be 808.1
B. The value of the variable number will be 808
C. The value of the variable number will be 0.
D. A NumberFormatException will be thrown
E. It will not compile

Answer D
Integer is an integer Wrapper class, if you want to convert an integer string into an Integer object, it throws a NumberFormatException exception.

 
Quesiton 401
Given:

class Base {
    // insert code here
}
 public class Derived extends Base {
    public static void main(String[] args) {
        Derived obj = new Derived();
        obj.setNum(3);
        System.out.println( "Square = " + obj.getNum() * obj.getNum());
    }
}
Which two options, when inserted independently inside class Base, ensure that the class is being properly encapsulated and allow the program to execute and print the square of the number?

A. 
private int num;
public int getNum(){
return num
}
public void setNum(int num){
this.num=num;
}
B
public int num;
protected public int getNum(){
return num
}
protected public void setNum(int num){
this.num=num;
}
C
private int num;
public int getNum(){
return num
}
private void setNum(int num){
this.num=num;
}
D
protected int num;
public int getNum(){
return num
}
public void setNum(int num){
this.num=num;
}
E
protected int num;
private int getNum(){
return num
}
public void setNum(int num){
this.num=num
}

Answer A, D

Option A is correct, private variables, public getter and setter method
Option B is incorrect, public variables, protected getter and setter
Option C is incorrect, setter method is private
Option D is correct, but I would argue that is is not

Option E, the setter method is private

 
Question 402
Given:

int array[] = new int[-2];

Which of the following exception will be thrown due to the statement given here?

A. NullPointerException
B. NegativeArraySizeException
C. ArrayIndexOutofboundsException
D. IndexOutofboundsException
E. This statement does not cause any exception.

Answer B
The NegativeArraySizeException exception is thrown because the array length defined in the array is less than 0

 
Question 403
Given:

public class CheckingAccount {
 
    public int amount;
 
    public CheckingAccount(int amount) {
        this.amount = amount;
    }
   public int getAmount() {
        return amount;
    }
   public void changeAmount(int x) {
        amount += x;
    }
}
And given the following main method, located in another class:

public static void main(String[] args){
    CheckingAccount acct = new CheckingAccount((int)(Math.random() * 1000));
    //line n1
    System.out.println(acct.getAmount());
}

Which three lines, when inserted independently at line n1, cause the program to print a 0 balance?

A. this.amount = 0;
B. amount = 0;
C. acct(0);
D. acct.amount = 0;
E. acct.getAmount() = 0;
F. acct.changeAmount(0)
G. acct.changeAmount(-acct.amount);
H. acct.changeAmount(-acct.getAmount());

Answer D, G, H
Option A, the main method is in a different category, so using "this"  cannot access to the acct object, will cause compilation errors.
Option B, amount because there is no declaration, it will cause compilation errors.
Option C, acct is an object variable, not a method that can not be used as such.
Option D, direct access to the acct variable reference to the object of the field, is feasible.
Option E, the method cannot be used, will cause compilation errors.
Option F, it can not guarantee the amount of the beginning is 0
Option G, amount = amount - amount, so the result will be 0.
Option H, same reason as option G.
Question 404
Given:

public class Test {// 1

    public static void main(String[] args) {
        try {
            Double number = Double.valueOf("120D");
        } catch (NumberFormatException ex) {
        }
        System.out.println(number);// 8
    }
}

What is the result?

A. 120
B. 120D
C. A NumberFormatException will be thrown
D. Compilation fails due to error at line 5
E. Compilation fails due to error at line 8

Answer E
"120D" or "120d" in Java is the correct numerical representation, expressed as double type 120.
If it is "120F" or "120f", it is represented as 120 for float. If it is "120" or "120", it means 120 for int type. 
Examples of code are as follows:  int a = 120 , float c = 120f , double c = 120d ;
So the fifth line of the program will execute and produce the Double object without throwing an exception. However, in line 8 of the program, the number variable is used, but the number variable is only defined in the try block starting at line 4, and the valid range is only in the try block, also  the second  line of the program, because there is no definition number,  The compile error occur at line 8.

 
Question 405
Which of the following can fill in the blank in this code to make it compile? (Select 2 options)

public void method() ˍˍˍˍ Exception{
    ˍˍˍˍˍ Exception();
}

A. On line 1, fill in throws
B. On line 1, fill in throws new
C. On line 2, fill in throw new
D. On line 2, fill in throws
E. On line 2, fill in throws new

Answer A, C

To throw the exception out of the method, use the "throws" keyword. To throw a new exception, use the "throw" keyword. To implement an exception, use the "new" operator.

 
Question 406
Given:

public class Whizlabs {
 
    private String name;
    private boolean pass;
 
    public static void main(String[] args) {

        Whizlabs wb = new Whizlabs();
        System.out.print("name = " + wb.name);
        System.out.print(",pass = " + wb.pass);
    }
}

What would be the output, if it is executed as a program?

A. name =, pass =
B. name = null, pass = null
C. name = null, pass = false
D. name = null, pass = true
E. Compilation error.

Answer C

Java class or object field will automatically set the initial value according to different data types.

 
Question 407
Given:

public class Whizlabs {
 
    public static void main(String[] args) {
         String s = "A";
        switch (s) {
            case "a":
                       System.out.println("simple A ");
            default:
                        System.out.print("default ");
                   case "A":
                        System.out.print("Capital A ");
         }
    }
}
What is the result ?

A. simple A
B. Capital A
C. simple A default Capital A
D. simple A default
E. Compilation fails

Answer B

In a switch statement, java always looks for a match first and if it cannot find a match then it will use the default case (if one exists). Java searches the case statements in the order they are in the code and the default option last, regardless of where it is in the code. So in this case it checks case “a”, and no match, then case “A” which is a match and prints out 
Capital A
If the string was any “b”, then java would see there is no match for case “a” or case “A” and then go to the default case. As there is no break after the default case then it would also trigger case “A”

 
Question 408
Given
public class Whizlabs {
 
    public static void main(String[] args) {
        LocalDate date = LocalDate.of(2015, 3, 26);
        Period p = Period.ofDays(1);
        System.out.println(date.plus(p));
    }
}
What is the result?

A. 2015-03-27
B. 2015-04-27
C. 2015-02-27
D. Compilation fails due to error at line 6
E. Compilation fails due to error at line 8

Answer A

Program line 4, established a date on March 26, 2015, the LocalDate object date. Program line 5, established a day of the Period object p. In the sixth line of the program, the "day" of the date object p represented by the date object "26 March 2015" will be returned to the LocalDate object representing "March 27, 2015".

 
Question 409
View the exhibit.

class MissingInfoException extends Exception {  }
class AgeOutofRangeException extends Exception {  }
 class Candidate {
   String name;
    int age;
   Candidate(String name, int age) throws Exception {
        if (name == null) {
            throw new MissingInfoException();
        } else if (age <= 10 || age >= 150) {
            throw new AgeOutofRangeException();
        } else {
            this.name = name;
            this.age = age;
        }
    }
    public String toString() {
        return name + " age: " + age;
    }
}
Given the code fragment:

public class Test {
  public static void main(String[] args) {// line 5
        Candidate c = new Candidate("James", 20);//line 6
        Candidate c1 = new Candidate("Williams", 32);//line 7
        System.out.println(c);
        System.out.println(c1);
    }
}
Which change enables the code to print the following? 
James age: 20
Williams age: 32

A. Replacing line 5 with: public static void main (String [] args) throws MissingInfoException, AgeOutofRangeException{
B. Replacing line 5 with: public static void main (String [] args) throws.Exception {
C. Enclosing line 6 and 7 in a try block and adding
catch (MissingInffoException e1){
//code goes here }
catch (AgeOutofRangeException e2){
//code goes here}
catch (Exception e3){
//code goes here}
D. Enclosing line 6 and 7 in a try block and adding
catch (MissingInffoException e2){
//code goes here }
catch (AgeOutofRangeException e3){
//code goes here}

Answer C
The program provided in the original question will compile errors in lines 6 and 7 because Candidate's object throws an Exception. Since Exception is a checked exception, you must write a program to handle it.
Option A, only the main method to throw MissingInfoException and AgeOutofRangeException is not enough, you must throw the Exception line.
Option B, throws usage error.
Option C, catch to Exception, the correct option.
Option D, just try-catch catch MissingInfoException and AgeOutofRangeException is not enough, you must catch the Exception.

 
Question 410
Which of the following can fill in the blank in this code to make it compile?

public class Exam {
 
    void method() {
    }
}

public class OCAJP extends Exam{

    _____ void method(){}
}

A. abstract
B. final
C. private
D. default
E. int

Answer B


In Java, subcategories to override the parent's method, the method's visibility can only be equal to or greater than the parent's method. Therefore, when the method to be overridden is not using the default modifier, the same cannot be used when the view is not used or the visibility is higher. But in this topic, there is no suitable visibility option available, so it should be retained without using the visibility modifier. So the option B, the use of the method can no longer be overwritten by the final modifier word.

 
Question 411

Given the code fragment:

public class App {
            void calcBill() {

                   // Line n1

                new Invoice().print();
             }
}

Which code fragment can be inserted at Line n1 to enable the class compile?

A.  private class Invoice {
      void print() { System.out.println("Invoice Printed"); }
      }

B.   public class Invoice {
      void print() { System.out.println("Invoice Printed"); }
      }

C.   class Invoice {
      void print() { System.out.println("Invoice Printed"); }
      }

D.  protected class Invoice {
      void print() { System.out.println("Invoice Printed"); }
      }

Answer is C 
These are inner classes and inner classes are not on this exam, however access modifers are which is probably what they are asking here.
You can create a class inside a method, as they are suggesting here, however the rule that applies to variables inside a method also apply to inner classes inside a method, in that they cannot have any access modifiers (private, public, protected). That means that A,B or D cannot be correct as the inner classes here have access modifers. C can only be the only one that is correct as this inner class has no access modifier.
Just as an aside if you care a inner class like the following
class Dog{

	private class Heart{
	}
}
This is an inner class created as an attribute of the Dog class, so like any other attribute of a class, this can have any access modifier.



 
Question 412

Given the code fragment? 

public class Test { 

	public static void main(String[] args) { 

	             Test t = new Test(); 
	              int[] arr = new int[10]; 
	              arr = t.subArray(arr,0,2); 

	} 

	  // insert code here 
} 

Which method can be inserted at line // insert code here to enable the code to compile? 



A. public int[] subArray(int[] src, int start, int end) { 
	return src; 
     } 

B. public int subArray(int src, int start, int end) { 
	return src; 
    } 

C. public int[] subArray(int src, int start, int end) { 
	return src; 
     } 

D. public int subArray(int[] src, int start, int end) { 
    	return src; 
     }

Answer is A
From the code
arr = t.subArray(arr,0,2); 
we can see that this method returns an array. This method takes an array, a int and a int as it’s three arguments
A is correct
B is incorrect
This returns an int, and takes three arguments, an int, a int and a int.
C is incorrect
This takes three ints as arguments
D is incorrect 
This returns an int





 
Question 413

Which code fragment correctly assign a numeric literal?

A. byte b1 = b1011;		?

B.  byte b2 = 1011b;	b?

C.  byte b3 = 0b1001;	sound

D.  byte b4 = 0xb001;	byte < - int 


Answer is C

A is incorrect
Binary is 0b not b
B is incorrect
No number format that just has a b at the end of the digits
C is correct
Binary numbers starte with 0b in java
D is incorrect
0x is hexadecimal, not 0xb



 
Question 414

Consider:

Integer number = Integer.valueOf( “808.1"); 

Which is true about the above statement? 


A. The value of the variable number will be 808.1 

B. The value of the variable number will be 808 

C. The value of the variable number will be 0. 

D. A NumberFormatException will be throw. 

E. It will not compile


Each wrapper class has a valueOf() method that can take a string that contains a wrapper of the type that is called the method (general name for these methods is parsers). 
i.e
Double.valueOf(“2.34”);
Integer.valueOf(“123”);
Boolean.valueOf(“true”);
If our parser takes a string that does not contain a wrapper than we will get an exception, if we have a string that contains the wrong data type for a numeric wrapper then we get a numberFormatException. So if we go
Integer.valueOf(“801.1”);
This will generate a NumberFormatException


 
Question 415

Given: 

public class MyClass { 
	public static void main(String[] args) { 
	       while (int ii = 0; ii < 2) { 
		ii++; 
		System.out.println("ii = " + ii); 
	       } 
                  } 
} 

What is the result? 

A. ii = 1 ii = 2 

B. Compilation fails 

C. The program prints nothing 

D. The program goes into an infinite loop with no output 

E. The program goes to an infinite loop outputting: ii = 1 ii = 1 



Answer is B
Compilation fails, while loop has to evaluate to boolean and this syntax does not

while (int ii = 0; ii < 2)
















 
Question 416

Given:

abstract class A1 {
     public abstract void m1();
     public void m2() { 
                System.out.println(“Green”); 
      }
 }
 abstract class A2 extends A1 {
       public abstract void m3();
       public void m1() { 
                 System.out.println(“Cyan”); 
       }
       public void m2() { 
                 System.out.println(“Blue”);
       }
 }
 public class A3 extends A2 {
       public void m1() { 
                 System.out.println(“Yellow”); 
       }
       public void m2() { 
                 System.out.println(“Pink”);
        }
         public void m3() {
                 System.out.println(“Red”);
        }
        public static void main(String[] args) {
                  A2 tp = new A3();
                  tp.m1(); 
                  tp.m2();
                  tp.m3();
         } 
}

 What is the result?
 
A.	Yellow
Pink
Red

B.	Cyan
Blue
Red

C.	Cyan
Green
Red

D.	Compilation Fails


Answer is A
Abstract class A1 is a superclass of abstract class A2 which is a superclass of the concrete class A3. All of the abstract methods ARE implemented somewhere in the chain of inheritance so this code will compile. 
The code A2 tp=new A3()
Is a abstract superclass reference to a concrente subclass object, which you can do and will compile (the other way around would not work as you can’t have an abstract object or a sub class reference to a superclass object).
The object tp can only call methods that were first created in super class, or a super class  thais and all the way up the inheritance chain all the way to object class
So 
Tp.m1()
M1() method was first created as a abstract method in the A1 class, and this is a superclass of A3, so tp can call this method and it has an implementation in the A3 class and prints
Yellow
given
Tp.m2()
M2() method was first created as a concrete method in the A1 class, and this is a superclass of A3, so tp can call this method and it has an implementation in the A3 class and prints
Pink
Given
Tp.m3()
M2() method was first created as a abstract method in the A2 class, and this is a superclass of A3, so tp can call this method and it has an implementation in the A3 class and prints
Red

Question 417

Given: 

String message1 = "Wham bam!" ;
	String message2 = new String( "Wham bam!" );
	
	if ( message1 ==  message2 )
		System.out.println("They match") ;
	
	if (message1 . equals(message2))
		System.out.println("They really match");



What is the result?

A. They match

B. Wham bam!

C. They really match

D. Compilation fails

Answer is C
String message1=”Wham bam!”
This line of code places the string that contains the phrase “Wham bam!” in the string pool. So if we declare
String str2="Wham bam!" ;
String str3="Wham bam!" ;
Message1,str2,str3 now are all the same string object, as every time a string is declared and given a value the string pool is checked and if the string exists in the pool that string is assigned to the reference.
Whenever we use the “new” keyword when declaring a string object, the string pool is NOT used, so in this case message2 is a different string object, with the same phrase contained within.
So 
Message1==message2 is false as they are different string objects
Message1.equals(message2) is true as equals checks the contents of the string and they both have the same contents.



















 
Question 418

Given: 

	package handy.dandy ;
	public class Keystroke {
		public void typeExlamation() {
			System.out.println(" ! ");
		}
	}

And
	package handy ;						/* Line 1 */
	public class Greet {						/* Line 2 */
			public static void main(String[] args) {		/* Line 3 */		
			String greeting = "Hello";			/* Line 4 */
			System.out.println(greeting);			/* Line 5 */
			Keystroke stroke = new Keystroke() ; 		/* Line 6 */
			stroke.typeExlamation();			/* Line 7 */
		}						/* Line 8 */
	}							/* Line 9 */

What three modifications, made independently, made to class greet, enable the code 
to compile and run?

A 	Line 6 replaced with handy.dandy.keystroke stroke = new KeyStroke ( );

B.	Line 6 replaced with handy.*.KeyStroke = new KeyStroke ( );

C.	Line 6 replaced with handy.dandy.Keystroke stroke = new handy.dandy.Keystroke();

D.	import handy.*;    added before line 1

E.	import handy.dandy.*;     added after line 1

F.	import handy.dandy.KeyStroke;    added after line 1

G.	import handy.dandy.KeyStroke.typeException();    added before line 1

Answer is C,E,F

Answer A is incorrect
If using the full qualified name, you have use the full qualified name on both the reference and object (left and right of the assignment statement)
Answer B is incorrect
This is incorrect syntax
Answer C is correct
This has the fully qualified name on both the reference and object (left and right of the assignment statement)
Answer E is correct
This will import all the classes and non static method of the handy.dandy package
Answer F is correct
This will import the KeyStroke class
Answer G is incorrect
You can import a single static method from a class, but you can’t import a single non static method from a class (as you can’t call a non static method without being able to create an object of that class first)








 
Question 419

Given the code fragment: 



		int[][] array2D = { { 0,1,2} , {3,4,5,6} };
		
		System.out.println(array2D [0].length + " " );		3	
		System.out.println(array2D [1].getClass().isArray() + " " );	true
		System.out.println(array2D [0] [1] );			one


What is the result?


A.	 4
	false
	 2

B. 	4
	true
	1

C.	3
	false
	3

D.	3
	true
	1

Answer is D
Array2d[0].length is looking for the length of the first row of our two dimensional array, so this prints out
3
Array2d[1].getClass().isArray()
isArray() will return true if array2d[1] is an array. Array2d[1] is the second row in a two dimensional array, and each row is an array in itself so this will print out
true
array2d[0][1] is the number at index position [0][1], which is the number on the first row, second column, which is the number 1 so this will print out
1
















 
Question 420

An unchecked exception occurs in a method dosomething() 

Should other code be added in the dosomething() method for it to compile and execute?


A. The Exception must be caught 

B. The Exception must be declared to be thrown.

C. The Exception must be caught or declared to be thrown.

D. No other code needs to be added.


Answer is D
When an unchecked exception is generated this exception does not have to be in a try/catch block or does not have to be thrown. It will generate an exception that will cause your program to crash but the code will compile and execute. Unchecked exceptions are usually some error in the logic of your code and are something that can be rectified by the coder (i.e arrayIndexOutOfBoundsException when you are trying to access a array postion that does not exist).




























 
Question 421

Which two are valid instantiations and initializations of a multi dimensional array?

A. int[][] array2D = { { 0,1,2,4} , {5,6} };

B. int[][] array2D = new int [2][2];
	array2D [0][0] = 1;
	array2D [0][1] = 2;
	array2D [1][0] = 3;
	array2D [1][1] = 4;

C. int[][][] array3D =  { { 0, 1 } , { 2, 3 } , { 4, 5 } };

D.  int[][][] array3D = new int [2][2][2];
	 array3D [0][0] = array;
	 array3D [0][1] = array;
	 array3D [1][0] = array;
	 array3D [1][1] = array;

   E.      int [][]   array2D = { 0, 1 };

A is correct
We have a two dimensional array reference and on the right we assign 0,1,2,4 to first row and 5,6 to second row
B is correct
We have a two dimensional array refrence and on the right we create a two dimensional array object of 2 rows and 2 columns. 
On the next four lines we assign values directly to each postion in the 2d array.
C is incorrect
We have a three dimensional array reference and then attempting to create and populate a two dimensional array on the right hand side, array reference dimensions and object array dimensions must match.
D is incorrect
We are creating a three dimensional array reference to a three dimensional array object, which is correct. 
On the next four lines we are trying to use a variable called array, however there is no variable called array our code. There is an Array class with which you can call static methods, but his “array” is not that.
Array3d[0][0] is a one dimensional array as all a three d array is a array of two dimensional arrays which are themselves arrays of one dimensional arrays. 
So we can assign a two dimensional array to
Array3d[0]
We can assign a one dimensional array to 
Array3d[0][0]
E is incorrect
This is creating a two dimensional array and on the right we are creating and populating a one dimensional array, and again the dimesions of reference and object do not match.

















 
Question 422

A method doSomething () that has no exception handling code is modified to trail a method
that throws a checked exception. 

Which two modifications, made independently, will allow the program to compile?


A. Catch the exception in the method that calls doSomething().

B. Cast the exception to a RunTimeException in the doSomething() method.

C. Declare the exception to be thrown in the doSomething() method signature.

D. Catch the exception in the method doSomething().

Answer is C,D
The doSomething() is calling a method that throws a checked exception, so that means that either this method call has to be in a try catch/block or the method doSomething() has to have a throws clause in the method signature. Also the method that creates the exception has to also have a throws clause in its method signature if it wants the doSomething() method to handle the exception.
A is incorrect as in order for this to work the method doSomething would have to have throws in it’s method signature
B is incorrect you can’t cast exceptions
C is correct as this will throw the exception to whatever is calling the doSomething() method. 
D is correct, if the doSomething() method catchs the exception that will deal with the exception generated



























 
Question 423

Which of the following will print current time? 


A. System.out.print(new LocalTime()-now0); 

B. System.out.print(new LocalTime()); 

C. System.out.print(LocalTime.now()); 

D. System.ouLprint(LocalTime.today()); 

E. None of the above.

You can’t directly create a localtime, localDate or localdate time object. You have to use one of the methods of each of those classes to create a time object. 
A is incorrect
Can’t directly create a localTime object, and the -now() syntax is incorrect
B is incorrect
Can’t directly create a LocalTime object
C is correct
This will get the current time based on your computer’s clock
D is incorrect
No such method as today (localDate.now() will get todays date based on computer clock)
E is incorrect because C is correct




































 
Question 424

Given the code fragment:


float x = 22.00f % 3.00f;		
int y = 22 % 3;
System.out.print(x + ", " + y);


What is the result?

A. 1.0, 1

B. 1.0f, 1

C. 7.33, 7

D. Compilation fails

E. An Exception is thrown at runtime

Answer is A
A is correct
Modlus (%) produces an integer as it does only integer division. So 
float x = 22.00f % 3.00f;
here we divide 22 by 3 and get the remainder 1. We can assign an integer to a float, but if we print this out we will get 
1.0
With 
int y = 22 % 3;
we are doing the exact same calculation and assign this to the int y, and this will dislay
1




















 
Question 425

class MyResource implements AutoCloseable {
	
    	private String name;
    	public MyResource(String name) {
    		this.name = name;
    	}
 	@Override
    	public void close() {
    		System.out.println(name);
    	}
}
public class ResourceHog {
	
    public static void main(String[] args) {
    	
    	try 
    	( 
    		MyResource one = new MyResource("one");
    		MyResource two = new MyResource("two"))
    	{
    			
    } 
    	finally 
    	{
    		System.out.println("three");			
    	}

    }
}

What is the result? Choose one.

A.  one
      two
      three

B. three
    two
    one

C. three
    one
    two

D. two
     one
     three

E.  The words one, two, and three are all output, but the order is not determined.

Answer is D
This question is more java 2 than java one
There is an built in interface called AutoClosaeable that has one of it’s method, close(). The close method is called automatically when exiting a try-with-resource. A try with resource is a try block in which we created a resource object. 
A resource is Any object that implementsjava.lang.AutoCloseable , which includes all objects which implement java.io.Closeable , can be used as a resource.
It closes them in the reverse order they were created in the try block, so we get 
“two,one”
The finally is then called, so we get
“two one three”
 
Question 426

Given the code fragment:

package p1;
public interface DoInterface{
           void method1(int n);		// line n1
           public void m2(int n);
}

package p3;
import p1.DoInterface;
public class DoClass implements DoInterface{
           int x1, x2;
          public DoClass(){
	this.x1 = 0;
	this.x2 = 10;
            }
            public void m1(int p1){ x1 += p1;  System.out.println(x1); }		// line n2 
            public void m2(int p1){ x2 += p1;  System.out.println(x2); }
}

package p2;
import p1;
import p3;
class Test{
         public static void main(String[]  args){
	DoInterface doi = new DoClass();		// line n3
	doi.method1(100);
	doi.method2(200);
         }
}

What is the result?

A. 100210

B. Compilation fails due to an error in line n1

C. Compilation fails due to an error at line n2

D. Compilation fails due to an error at line n3

Answer is B
The interface DoInterface has two abstract methods 
void method1(int n);		
           public void m2(int n);
any class that implements this interface has to provide implementation for both of these methods. The class DoClass implements DoInterface however it does not provide implementation for method1(). The rest of the code will not compile because of line n1.




 
Question 427

Given the code fragment:

package p1; 
public interface DoInterface { 
        void method1(int n1); 				// line n1 
        public void method2(int n1);
} 

package p3; 
import p1.DoInterface; 
public class DoClass implements DoInterface { 
        public DoClass(int p1) { } 
        public void method1(int p1) { } 			// line n2 
        private void method2(int p1) { } 			// line n3 
} 
public class Test { 
        public static void main(String[] args) { 
                  DoInterface doi= new DoClass(100);		 // line n4 
                  doi.method1(100); 
                  doi.method2(100); 
        } 
} 

Which change will enable the code to compile? 

A. Adding the public modifier to the declaration of method1 at line n1  

B. Removing the public modifier from the definition of method1 at line n2 

C. Changing the private modifier on the declaration of method 2 public at line n3 

D. Changing the line n4 DoClass doi = new DoClass ( );

E. Will not compile

Answer is E
Can’t have two public classes in the one file

 
Question 428

Given:

public static void main(String[]  args){
	
	int a, b, c = 0;		
	int a, b, c;			
	int g, int  h, int I = 0;	
	int d, e, F;		
	Int k, l, m; = 0;		
}

Which two declarations will compile?

A. int a, b, c = 0;

B. int a, b, c;

C. int g, int h, int i = 0;

D. int d, e, F;

E. Int k, l, m; = 0;

A is correct
You can declare several variables of the same type on the one line and give values to some of those variables.
B is incorrect
As you already created variables a,b,c on line a, you cannot declare variables of the same name a second time.
C is incorrect
You can’t declare the variable type more than once per line of code (INT a,b,INT c), even if it is the same variable type, as it is here as we are using “int”
D is correct
You can have multiple variable declaration of the same type on the one line and you can use capital letters
E is incorrect
You can’t go m;=0;
This will not compile





















 
Question 429

Given:

public class ScopeTest1{
          public static void main (String[]  args){
	doStuff();		// line x1		
	int x1 = x2;	// line x2	
	int x2 =j;		// line x3
          }
          static void doStuff(){
                  System.out.println(j);	// line x4
          }
          static int j;
}

Which line causes a compilation error?

A. line x1

B. line x2

C. line x3

D. line x4

A is incorrect
We are inside the static method main() and we are calling the static method in the same class doStuff() which you can do
B is correct
We declare a variable reference x1 and then try to assign the variable x2 to this. However we have not defined x2 by this point, so we cannot use x2 and this will cause a compilation error.
C is incorrect
We are declaring a int reference x2 and assigning the static int j to x2. We can access static variables directly from inside a static method and as j is a attribute of a class it will also have a default value of 0.
D is incorrect
We are in the static method doStuff() and printing out the static variable j, and you can access static variables directly from a static method.


















 
Question 430

Given the code fragment:

int j = 0, k = 0;

for ( int i =0; i < x; i++ ) {
        do {							
	k = 0;						
	while ( k  <  z ) {					
	        k++;						
	        System.out.print( k + "  " );		
	}
	System.out.println( "  " );
	j++;
        } while ( j < y );				
          System.out.println( "---" );
}

What values of x, y, z will produce the following result? 
1 2 3 4
1 2 3 4
1 2 3 4
---
1 2 3 4
---

A. X = 4, Y = 3, Z = 2

B. X = 3, Y = 2, Z = 3

C. X = 2, Y = 3, Z = 3

D. X = 4, Y = 2, Z = 3

E. X = 2, Y = 3, Z = 4

Answer is E
We have a while loop inside a do while loop inside a for loop.
The inner while loop is what prints out the 4 numbers, one each iteration of the loop,and the numbering starts at 0 (as k is 0) and it increments by one each time. We have four numbers, so that means that our while loop has to loop 4 times. So that means z HAS to be 4.
So k<z is actually k<4
There is only one answer where z=4 and that is answer E
The four numbers are first printed out 3 times, and the do while loop controls how many times the four numbers are printed out. Each iteration of the Do while loop the line “1234” is printed out, so our do while loop has to loop 3 times, so that means Y has to be 3.
So j<y is actually j<3
We exit the do While loop and the final value of j is 3, note that j is declared outside of all the loops, so that means the next time we come to use the do while loop, j =3
“---”
Is printed
And we go into the second iteration of the outer for loop. The do while loop is always executed at least ONCE so we do not initially care for the value of j. The while loop executes and produces one row of 
1234
J++ means that j is now 4, which is NOT less than 3, so our do while loop will exit and then 
---
Will be printed. This finishes the second iteration of our for loop and this matches what we want out final printout to look like so that means that the outer for loop will have to iteratate 2 times. So that mean that x HAS to be 2
So for ( int i =0; i < x; i++ )
Is actually for(int i=0;i<2;i++)





 
Question 431
Given
Int x=5;
Int y=0;
For(int i=0;i<x;i++,x--){
	While(x>i){
		System.out.print(x+”+”+”+i+”=”+(x+y))
	}
}
A this will print 5+0=5 infinite times
B this will print 5+1=6
4+2=6
C this will print 5+1=6
4+2=6 
five times
D None of the above
E. this will not compile

Answer is A
The while loop is not given any exit condition (x or I does not increment or decrement inside the while loop). So this will keep printing out the original value of x, which is 5, plus original value of I, which is 0, and add the two of them up and display them which is 5.
Or in original question Y was not declared, and was then used in the print statement. If this was not a typo then the answer would be E, this will not compile

 
Question 432
Given:

class Alpha {
 
    public String[] main = new String[2];
 
    Alpha(String[] main) {
        for (int ii = 0; ii < main.length; ii++) {
            this.main[ii] = main[ii] + 5;
        }
    }
    public void main() {
        System.out.print(main[0] + main[1]);
    }
}

 public class Test {
 
    public static void main(String[] args) {
        Alpha main = new Alpha(args);
        main.main();
    }
}
And the commands:

javac Test.java
java Test 1 2

What is the result?

A. 1525

B. 13

C. Compilation fails

D. An exception is thrown at runtime

E. The program fails to execute due to runtime error

Correct answer A


Option A: correct, output is 1525.  position main[0] = "1" + 5 => 15,  main[1] = "2" + 5 => 25
Option B: is not correct, wrong output
Option C: is not correct, there is no problem with the code.
Option D: is not correct , there is no exception generated with above commands. If we add one more 	 		argument to commands ( java Test 1 2 3 ), then we get   						 ArrayIndexOutOfBoundException.
Option E: is not correct, program compile and run with no problems


Question 433
Given:

public class Test {
       public static void main(String[] args) {
        Cake c = new Cake();
        c.bake1(c);
        System.out.println(c.model + " " + c.flavor);
        c.bake2(c);
        System.out.println(c.model + " " + c.flavor);
    }
}
class Cake{
        String flavor;
        int model;
        public Cake bake1(Cake c) {
                 c.flavor = "Strawberry";
                 c.model = 1200;
                 return c;
        }
        public Cake bake2(Cake c) {
                c.flavor = "Chocolate";
                c.model = 1230;
                return c;
        }
}
What is the result?

A. 0 unknown
     0 unknown

B. 1200 Strawberry
    1200 Strawberry

C. 1200 Strawberry
     1230 Chocolate

D. Cmpilation fails


Correct answer C



Option A : is not corect Wrong output
Option B:  is not correct. Only first part is correct, second part are not correct 
Option C   CORRECT program produce output: 1200 Strawberry, 1230 Chocolate
Option D:  is not correct. There is no problem with code






Question 434

Given:

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class TestRemIf
 {
	public static void main(String[] 	args) 
	{ 
		List<Integer> list = new ArrayList<>();
		list.add(21); list.add(13);
		list.add(30); list.add(11);
		list.add(2);

		// insert here	

		
								
		System.out.println(list);    				
	}
}		

Which inserted  at line (insert here) WILL PROVIDE following output:   [ 21, 13, 11 ]  ?
							
	A		list.removelf(e > e%2 != 0);
	B		list.removelf(e -> e%2 != 0);
	C		list.removelf(e -> e%2 == 0);
	D		list.remove(e -> e%2 = 0);
	E		None of the above											
	
 
Answer is C 
There is a new method in java se 8 for the list interface calls removeIf(). Remove if takes a predicate lambda, which is implementation of a the test method that takes an object and returns true or false. we want this implementation to only return the odd numbers from out list of numbers 21,13,30,11,2
So we want to exclude all even numbers
A is incorrect as we have the greater than symbol “>”,not the arrow “->” which we need for a lambda
B is incorrect
This will remove all numbers that have a modulus 2 other than 0, (in other words remove all odd numbers
C is correct
This will remove all numbers that have a moduls 2 of 0, in other words remove all even numbersD
D is incorrect
There is no remove() method for the list interface







Question 435

Which two will compile, and can be run successfully using the command: 
javac fred1.java
java fred1 hello walls


A. class fred1{
     public static void main(String  args){
     System.out.println( args[1]);}}
B. class fred1{
     public static void main(String[]  args){
     System.out.println( args[2] );}}
C. class fred1{
     public static void main(String[]  args){
     System.out.println(args);}}
D. class fred1{
     public static void main(String[]  args){
     System.out.println( args[1]);}}


A. Option A

B. Option B

C. Option C

D. Option D



Correct answer: C, D


Option A: not correct. There is missing [ ] in the “String args”
Option B: not correct. Try to access position args[2] cause ArrayIndexOutOfBoundsException
Option C: CORRECT. Class will compile and run with output [L java.lang.String:<hash>
		       We not accessing any element of the array Return is telling that’s Array of Strings
		       with address. Similar to method getClass();
Option D: CORRECT. Class compile and run with output walls. Position args[1] is walls




 
Question 436


Which statement will empty the contents of a StringBuilder variable named sb? 
A. sb.deleteAll(); 
B. sb.delete(0, sb.size()); 
C. sb.delete(0, sb.length()); 
D. sb.removeAll(); 
Answer is C

Exaplanation
Option A is incorrect, there is no deleteAll() method in the StringBuilder class
Option B is incorrect, there is a delete method in the StringBuilder, which takes two ints, one the start point and the other the end point. Sb.size() is wrong as there is no method size() in the StringBuilder class
Option C is correct
This will delete all characters in a stringBuilder object, starting at the first postion and up to length of the StringBuilder object. If you want to find the amount of characters in a StringBuilder object you use the length() method.
Option D is incorre, there is no removeAll() method in the StringBuilder class

 
Question 437
Given: 
class Base { 
// insert code here 
} 
public class Derived extends Base{ 
public static void main(String[] args) { 
Derived obj = new Derived(); 
obj.setNum(3); 
System.out.println("Square = " + obj.getNum() * obj.getNum()); 
} 
} 
Which two options, when inserted independently inside class Base, ensure that the class is being properly encapsulated and allow the program to execute and print the square of the number? 

Which two options, when inserted independently inside class Base, ensure that the class is being properly encapsulated and allow the program to execute and print the square of the number? 
A. private int num; public int getNum() { return num; }public void setNum(int num) { this.num = num;} 
B. public int num; protected public int getNum() { return num; }protected public void setNum(int num) { this.num = num;} 
C. private int num;public int getNum() {return num;} private void setNum(int num) { this.num = num;} 
D. protected int num; public int getNum() { return num; } public void setNum(int num) { this.num = num;} 
E. protected int num; private int getNum() { return num; } public void setNum(int num) { this.num = num;} 

Answer is A,D
To ensure a class is encapsulated the variables have to be private and provide access via public methods (getters and setters).
B is incorrect as we have non public getters and setters
C has only private variables in its class, however its setter is set to be private, which means it can’t be accessed outside of it’s own class (setter is private)
D is correct, but I would argue with this
E is incorrect as the getter is private

 
Question 438
Given the code fragment: 
LocalDate date1 = LocalDate.now();
LocalDate date2 = LocalDate.of(2014, 6, 20);
LocalDate date3 = LocalDate.parse("2014-06-20", DateTimeFormatter.ISO_DATE);
System.out.println("date1 = " + date1);
System.out.println("date2 = " + date2);
System.out.println("date3 = " + date3);

Assume that the system date is June 20, 2014. What is the result?
A.
date1=2014-06-20
date2=2014-06-20
date3 = 2014-06-20
B.
date1=06/20/2014
date2=2014-06-20
date3 = Jun 20, 2014
C Compilation fails
D. A DateParseException is thrown at runtime.

Answer is A 
LocalDate.now() will produce a date in the American format of yyyy-mm-dd, 
LocalDate.of(a date) will also produce in American format. 
The last option ISO_DATE() formatter is the default standard formatter so this will also be in the American format

 
Question 439
Given the following class:
public class CheckingAccount{
	public int amount;
	//line  n1
}
And given the following main method, located in another class:
public static void main(String[args]) {
	CheckingAccount acct=new CheckingAccount();
	//line n2
}

Which three pieces of code, when inserted independently, set the value of amount to 100?
 
Answer is C,D,E
A is incorrect
is incorrect as we can’t access the instance variable of another class by just the name of the variable, we have to first create a instance of the class and then access the variable that way, i.e
acct.amount=100
B is incorrect as it is trying to do the exact same thing as option a, this.amount is the exact same as “amount”
C is correct
We are using a member of the class to access one of it’s public instance variables, 
D is correct
This is a public constructor that sets the account attribute to 100
E is Correct
This is a public constructor that sets the account attribute to 100, inside the CheckingAccount class we can acess the account attribute by “account” or “this.account”, as all instance variables of a class implicitly have a “this” in front of them
F is incorrect
The variable acct is a local variable, that is only available in the method it was defined in.

 
Question 440
Given:
 
And given the commands:
javac Test.java
java Test
What is the result?

A.
Java SE
B.
Java EE
C.
Compilation fails at line n1.
D.
A NullPointerException is thrown at runtime.
Answer is B
Javac Test.java compiles the program
Java test runs the file called test, with no arguments passed to the main method.
Int x=args.length, as no arguments are passed into the String[]args array the length of the array is 0, so x=0.
 Min is a variable that is set to 1.
If(checkLimit(x)) sends x to the checkLimit method. The checkLimt method will return true if greater than or equal to 1, false if not. This returns FALSE.
If true, it will print Java SE, it is false so it will print Java EE

 
Question 441
Given the code fragment:
LocalDateTime dt=LocalDateTime.of(2014, 7,31,1,1);
		dt.plusDays(30);
		dt.plusMonths(1);
	System.out.print(dt.format(DateTimeFormatter.ISO_DATE));
What is the result?
A.
An exception is thrown at runtime.
B.
07-31-2014
C.
2014-07-31
D.
2014-09-30
Answer is C
This is a trick question as remember dates and times are immuatable and do not change, so when you go
dt.plusDays(), you are NOT CHANGING dt, you have to assign this to a variable if you wish to use this value. Ie
LocalDateTime newDateTime=dt.plusDays(30). 
So the answer is C, as the datetime does nto change

 
Question 442
Given the code fragment:
public static void main (String[] args) {
	int data[]= {2010,2013,2014,2015,2014};
	int key=2014;
	int count=0;
	for(int e:data) {
		if(e!=key) {
			continue;
			count++;
		}
	}
	System.out.print(count+"Found ");
}

What is the result?
A.
Compilation fails.
B.
0 Found
C.
1 Found
D.
3 Found
Answer is A
If code is unreachable and will not execute under any circumstances then it will not compile. If the variable e is Not the SAME as the variable key, then your loop will continue. What continue does it that it will exit the current iteration of the loop, which means that  if key is not 2014 it will always contine, and whatever comes after continue will NEVER execute, which means it has unreachable code so it will not compile because the line
Count++ 
Is unreachable code
 
Question 443
Which two statements are true?
A.
Error class is unextendable.
B.
Error class is extendable.
C.
Error is a RuntimeException.
D.
Error is an Exception.
E.
Error is a Throwable.
A is incorrect, error class is extendable, StackOverflowError extends Error for example
B is correct
C is incorrect, while it is true that error is treated the same as a RuntimeExeption in that they are both unchecked exceptions and  usually should not be caught, nor have to be caught. Strictly speaking is is not a RuntimeException as it does not extend the RunteimException class. 
D is incorrect as Error does not extend Exception, it extends Throwable
E is Correct as Error extends Throwable
 
Question 444
Given the code fragment:

 
What is the result?
A.
An exception is thrown at runtime.
B.
-1
C.
5
D.
0
Answer is C
myStr.trim() does nothing to our string as there are no spaces before or after our characters. So int i1=myStr.indexOf(“ “); will get the postion 5, which is answer C

 
Question 445
Given the code fragment: (ignore the typos)
 
Which code fragment, inserted at line n1, prints The Top element: 30?
 
Answer is C

We have our array
Int[]stack={10,20,30}
We want to print out the last element of our array so we wish to get to 
Stack[2], this is the last number in our array which is 30.
We are using as our counter the variable idx, so we need idx to have a value of 2 so that 
Stack[idx] will be stack[2]
Option A is incorrect, idx starts out at 0, goes into the while loop and increments by 1 so it is idx is then 1. However the while clause means the loop will only continue while idx is greater than size, which is 3. So out loop will exit only one iteration and idx will have a value of 1.
Option B is incorrect
The while loop checks the current value of idx is less than 3 and then increments by 1. So when the loop gets to idx=2, 2 is less than 3 and then it increments idx by 1, and then idx=3 and 3 is NOT less than 3, so the final value of idx will be 3. 
Option C is correct
While(idx<size-1)
This line of code means while ids is <2, as size is 3, and 3-1 is 2. So our loop will continue until idx has the value of 2, the loop will exit, the final value of idx is 2, which we can use to access the last number in our array.
Option D is incorrect
This option will still loop when idx is 3, as it is checking if idx<=size, which is idx<=3. So even when idx is three, the loop will be entered into and idx incremented once more. So the final value of idx will be 4
Option E is incorrect
When idx is 2, this loop will still be entered as idx<=size-1, is idx<=2. When idx is 2, it will be incremented once more and the final value of idx will be 2.
 
Question 446
Which three statements are true about exception handling?

A.
Only unchecked exceptions can be rethrown.
B.
All subclasses of the RuntimeException class are recoverable.
C.
The parameter in a catch block is of Throwable type.
D.
All subclasses of the RuntimeException class must be caught or declared to be thrown.
E.
All subclasses of the Exception class except the RuntimeException class are checked exceptions.
F.
All subclasses of the Error class are checked exceptions and are recoverable.
Answers: B,C,E
A is incorrect, both checked and unchecked exceptions can be rethrown
B is correct all subclasses of RuntimeException are recoverable (they are all usually errors in the logic of your code which  you can fix)
C is Correct, a catch block parameter can be a throwable type or subclass of type throwable
D is incorrect RuntimeExceptions do not have to be caught
E is true, anything that is dervived from the Exception class that is not a RuntimeException is checked exception.
F is incorrect, Errors are unchecked exceptions and have usually nothing to do with your code so are not recoverable

 
Question 447
Given the code fragment
Public static void main(String[]args){
	ArrayList<Integer> points=new ArrayList<>();
points.add(1);
points.add(2);
points.add(3);
points.add(4);
points.add(null);
points.remove(2);
points.remove(null);
System.out.println(points);
}
What is the result?
A.
A NullPointerException is thrown at runtime.
B.
[1, 2, 4]
C.
[1, 2, 4, null ]
D.
[1, 3, 4, null ]
E.
[1, 3, 4 ]
F.
Compilation fails.
Answer is B
Points.remove(2) removes the object (numbers in arraylists have to be wrapper objects) in positon 2, which is the number 3. The line points.remove(null), removes the null object. This would only remove the first null it comes across, it would not remove any subsequent null objects. The removeAll() method does not, for instance remove all instances of null in a an arraylist, removeAll() takes an list and remove all items on this list from the list that calls this method.
You can also remove objects by name (if you had an arraylist of dogs, called dogList, and one of the dogs in the array is called “spot”, we can remove spot by dogList.remove(spot), see code q408). When you have an arrayList of numbers you are removing by position, not by what the number actually is.



 
Question 448
Given:
 
What is the result?
A.
Compilation fails at line n3 and line n4.
B.
Compilation fails at line n1 and line n2.
C.
Welcome Visit Count:1 
Welcome Visit Count: 2
D.
Welcome Visit Count:1 
Welcome Visit Count: 2
Answer is B
You cannot access non static members in a static method. Int count is a non static variable which we try to directly access in the method displayMsg on line n1 and also in line n2 which we cannot do. 

 
Question 449
Given the code fragment:
 
What is the result?
 
A.
Option A
B.
Option B
C.
Option C
D.
Option D
Answer is C
As soon as a print statement encounters a string, all “+” after the string concatenates rather than do some addition. In effect numbers will be treated as strings, So the line
System.out.println(“Result A “+0+1)
Treats the 0 and 1 as strings, so this will print out
Result A 01
Putting brackets around individual numbers will not change how the concatenation operator treats the numbers as strings. So the line 
System.out.println(“Result B “+(1)+(2) 
Treats 1 and 2 as strings and will print out
Result B 12
If we did system.out.println(“print me “+(1+2), this will add up 1 and 2 to produce 
Print me 3
 
Question 450
You are asked to create a method that accepts an array of integers and returns the highest value from that
array.
Given the code fragment:
 
Which method signature do you use at line n1?
A.
public int findMax (int [] numbers)
B.
static int[] findMax (int max)
C.
static int findMax (int [] numbers)
D.
final int findMax (int [] )
Answer is C
We are inside a static method when we have the line of code
Int max=findMax(numbers).
From this line of code we can see that findMax HAS to be a static method, as static methods can only call other static methods. So we can eliminate all non static methods in the answers and we are left with B and C
Int max=findMax(numbers), tells us that the method is returning a int and assigning it to the int variable max, only C returns an int so the answer is C

 
Question 451
Given:
 
What is the result?
A.
A 
B
B.
A 
C
C.
C 
C
D.
A ClassCastException is thrown only at line n1.
E.
A ClassCastException is thrown only at line n2.
F
The code does not compile
Answer is F this will not compile as you have duplicate code on line n1 and n2
This is deliberately confusing in that is creates two variables called b1 and b2, neither of which are actually members of the B class. The key line of code is 
A b2=new C()
This will compile as this is a super class reference to sub class object. Class B extends A, and class C extends A, that means there is no direct relationship between class B and C, which also means that we can’t cast a B object to be of type C or vice Vearsa. 
The line n1
A b3= (B) b2;
Will cause a classCastException, as we are trying to cast a C object (b2) to be of B, and there is no relationship between class C and class B. 
However this code will not compile as line n2 is exactly the same as line n1 so you can’t declare the same variable twice. So the answer is F
The Code does not compile

 
Question 452
Given the code fragments:
 
Which modification enables the code to compile?
A.
Replace line n1 with: 
import p1.*; 
Replace line n2 with: 
import p1. p2.*;
B.
Replace line n1 with: 
import p1. A; 
Replace line n2 with: 
import p1.*;
C.
Replace line n1 with: 
import p1. A; 
Replace line n2 with: 
import p1. A; 
import p1. p2.B ;
D.
Replace line n1 with: 
import p1; 
Replace line n2 with: 
import p1; 
import p1. p2;

In class B we have to import either all the contents of package p1, or the class A in package p1. We have to do this because we are declaring a variable of type  A in the B class. 
In class c we have to have two imports, from both class A and class B as they are in two different packages and two different classes. 
A is incorrect as 
Import p1.*; 
Will import all the classes in p1, and there is only one, class A
However our second import statement has to import two classes and it only imports one class.
B is incorrect
Import p1.A; 
Will import the correct class
However our second import has to import two classes and it only imports one class
C is correct
import p1. A;  will import class A into Class B
import p1. A; 
import p1. p2.B ;
will import both class A and class B into class C
D is incorrect
import p1; 
is the wrong syntax if we want to import all the classes of a package.
N.b when you import all the contents of a package, you DO NOT import the sub packages


 
Question 453
Which statement best describes encapsulation?
A.
Encapsulation ensures that classes can be designed so that only certain fields and methods of an object 
are accessible from other objects.
B.
Encapsulation ensures that classes can be designed so that their methods are inheritable.
C.
Encapsulation ensures that classes can be designed with some fields and methods declared as abstract.
D.
Encapsulation ensures that classes can be designed so that if a method has an argument MyType x, any 
subclass of MyType can be passed to that method.

Answer is A
Encapsulation is making your attributes private and access them via public methods.
B is incorrect, has nothing to do with inheritance, in fact if your attributes of a class are private they cannot be inherited.
C is incorrect, fields cannot be abstract
D is incorrect as any method can take a subclass of any of its parameters, this is called covariance
So if we had a method 
Void eat(Animal andy){}
This method can take any subclass of Animal, this is a feature of java and has nothing to do with Encapsualtion.



 
Quesiton 454
Given the code fragment:
public static void main(String[]args) {
	String names[]= {"Thomas","Peter","Joseph"};
	String pwd[]=new String[3];
	int idx=0;
	try {
		for(String n:names) {
			pwd[idx]=n.substring(2,6);
			idx++;
		}
	}
	catch(Exception e) {
		System.out.println(e);
		System.out.println("Invalid Name");
	}
	for(String p:pwd) {
		System.out.println(p);
	}
}

What is the result?

A
Invalid Name
B.
Invalid Name 
omas
C.
Invalid Name 
omas 
null 
null
D.
omas 
ter 
seph
Answer is c
In our array we have three names, we then try populate an array called pwd with a sub striing of every name. the line
pwd[idx]=n.substring(2,6);
for the first name “Thomas”, gets a substring that begins at position 2 and goes UP TO but not including position 6, which is the word “omas”. This is now the first word in the array pwd. It attempts to do the same with our second word, “Peter”, but this will generate an StringIndexOutOfBoundsException as peter has 5 words, which means it’s last postion is postion 5. The loop exits at this point and the exception that is generated is caught by the catch block and the line 
“invalid name”
 is printed to screen. Our array pwd, now only has one word in it, “omas”, and the rest of postions in the array are null (as an array of objects, the default value given to every object in that array is null). So if we print out that array we will get 
“Omas 
null 
null”
 
Question 455
Given:
 
And given the code fragment:Which two modifications enable the code to print the following output?
 
Canine 60 Long
Feline 80 Short
A.
Replace line n1 with: 
super (); 
this.bounds = bounds;
B.
Replace line n1 with: 
this.bounds = bounds; 
super ();
C.
Replace line n2 with: 
super (type, maxSpeed); 
this (bounds);
D.
Replace line n1 with: 
this (“Canine”, 60); 
this.bounds = bounds
E.
Replace line n2 with: 
,String bounds)
super (type, maxSpeed); 
this.bounds = bounds;
Answer is A,E
Easiest way to do this question is to try out all the sample code

 
Question 456
Which statement is true about the switch statement?
A.
It must contain the default section.
B.
The break statement, at the end of each case block, is mandatory.
C.
Its case label literals can be changed at runtime.
D.
Its expression must evaluate to a single value.

Answer A is incorrect
A switch statement does not have to have a default statement, the default is equalivent to an else in an if else statement and is only there to provide a outcome if none of the case statements are true.
Answer B is incorrect
A switch statement does not have to have a break statement at the end of each case block, if there is not break statement at the end of the case statement the flow of control automatically goes to the next case statement and will keep triggering all case statements until it hits a break or the switch statement finishes. 
Answer C is incorrect
Case label literals cannot be changed at runtime, they have to be what are called compile time constants, they have to be an actual value as a opposed to a variable (i.e case 1, case “hello”)
D is correct
A switch statement has to evaluate to a single value and not, for instance, a range of values, i.e
Case(x>5)

 
Question 457
 “ 
Which code fragment can replace the if block?
A.
stuff.equals (“TV”) ? res= “Walter” : stuff.equals (“Movie”) ? res = “White” : 
res = “No Result”;
B.
res = stuff.equals (“TV”) ? “Walter” else stuff.equals (“Movie”)? “White” : “No 
Result”;
C.
res = stuff.equals (“TV”) ? stuff.equals (“Movie”)? “Walter” : “White” : “No 
Result”;
D.
res = stuff.equals (“TV”)? “Walter” : stuff.equals (“Movie”)? “White” : “No 
Result”;
(ignore the typo for with no closing quotation marks around the word “Movie”)
This questions is about trying to find a valid ternary operator that will replace the if/else if/else statement.
A is incorrect as we have to have a variable on the left hand side of the terany operator, and stuff.equals (“TV”) is just the boolean value “true”
B is incorrect as we are using the else in a ternary operator without an if, you cannot use an else without an if
C is incorrect as we have two semi conlons in a row without a ternary operator which is not allowed
D is correct as if stuff is TV, “Walter” will be assigned to res, if stuff is Movie, “White” will be assigned to res, and if it is neither, res will be “No Result”
 
Question 458
Given the code fragments:
 
Which modification enables the code to compile?
A.
Replace line n1 with: 
import p1.A; 
Replace line n2 with: 
import p1.A; 
import p1.p2.B;
B.
Replace line n1 with: 
import p1; 
Replace line n2 with: 
import p1; 
import p1.p2;
C.
Replace line n1 with: 
import p1.A; 
Replace line n2 with: 
import p1.*;
D.
Replace line n1 with: 
import p1.*; 
Replace line n2 with: 
import p1.p2.*;
A is correct
Import p1.A will import the A class that is in the p1 package, which will enable us to create a A class object
Import p1.p2.B will import class B that is in the p1.p2 pckage which will enable us to create a B class object
B is incorrect
This is incorrect syntax, if we wanted to import all classes in a package we would have to go imort p1.*
C is incorrect
B class is not imported so we will not be able to create a B class object
D is correct 
import.p1.* will import all classes from this package, so we will be able to create a A class object
import p1.p2.* will import all classes from the package, so we will be able to create a B class object 
Question 459
Given:
 
And given the commands:
javac Test.java
java Test TRUE null
What is the result?
A.
TRUE null
B.
true false
C.
false false
D.
true true
E.
A ClassCastException is thrown at runtime.
Answer is B true false
The line 
javac Test.java
will compile
the line 
java Test TRUE null
will run the main method in the Test class and pass in the STRINGS “TRUE” and “null” into the main method. So the args array now looks like
args[0]=”TRUE”
args[1]=”null”
the line
boolean a=new Boolean(Boolean.valueOf(args[0]));
will compile, and convert the text “TRUE” to a boolean true (case doesn not matter with valueOf() method in the boolean class).
The line
Boolean b=new Boolean(args[1])
Will compile, as the Boolean class has a constructor that takes a string, if the string is anything other than “true” or “false”(NOT CASE SENSITIVE), the resultant boolean will be false. args[1] is the string “null” so b will be false
 
Question 460
Given:
 
What is the result?
A.
100 0 : 100 200:
B.
100 0 : 100 0 :
C.
100 200 : 100 200 :
D.
100 200 : 100 0 :
Answer is D
MyField m1=new MyField()
Creates a new MyField object and we then give the x and y attributes of this object the values 100 and 200 respectively. so m1.x is 100, and m1.y is 200.
MyField m2= new MyField() creates a new object m2, m2 then calls the doStuff() method and sends the values 100 and 200 (m1.x and m1.y).
this.x=x;
Insdie the doStuff() method, the x variable of m2 is set to 100(x is the value 100)
y=this.y;
y is the variable sent to this method, this.y is the y variable of m2. this.y is 0, as if no value is given to a instance variable, then it defaults to 0 for numbers. 
So at the end of this we have the following
m1.x=100;
m1.y=200
m2.x=100;
m2.y=0.
m1.display() displays m1.x and m1.y
m2.display() displays m2.x and m2.y
 
Question 461
Given the code fragment:
 
What is the result? (ignore typo nim as there is no “does not compile” option
A.
Answer = 0
B.
Invalid calculation
C.
Compilation fails only at line n1.
D.
Compilation fails only at line n2.
E.
Compilation fails only at line n1 and line2.
Answer is E
Our three variables are declared inside the try block, that means that these variables are LOCAL and only available within the try blocks curly brackets. If we try to access the num,div or ans variable anywhere outside the brackets, the code will not compile 
Question 462
Given the code fragment:
 
What is the result?
A.
1324
B.
2413
C.
3142
D.
4231
E
2313
Answer is E
There may be a typo in this question as 2,3,1,3 did not exist in the original answers and all of the answers feature the number 4 which seems to suggest that the array should originally have the number 4 in it.
This is a two dimensaional array that has 1,3 on first row and 2,3 on second row.
For(int i=n.length-1;i>=0;i--){
This assigns 1 to i, as n.length is the amount of rows, which is 2, so length-1 is 2-1, which is 1. The outer loop will loop twice, and i will decrement by one.
for(int y:n[i]), will start at the second row (as i starts at 1), and will print out, so this is
for(int y:n[1]) which will print out
2,3
Next iteration is for(int y:n[0], which will print out
1,3

 
Question 463
Which one of the following code examples uses valid Java syntax?
 
Option A is correct
Option B is incorrect as Sting[] means this array has no name which is incorrect.
Option C is incorrect as “statc” is missing
Option D is incorrect as the main() method does not take an array of String String() args

 
Question 464
Given:
 
What is the result?
A.
400 200
B.
200 200
C.
400 400
D.
Compilation fails.
Answer is A
We are passing var1, which has a value of 200, to the doCalc()method. Iniside the doCalc method this number is multiplied by 2 and returned. So the print statement
System.out.print(doCalc(var1)); 
Will print out 400. 
var1’s value is not changed in main, it is still just 200, so the line 
system.out.print(“ “+var1)
will print 200
 
Question 465
Given the content of three files:Which statement is true?
 
A.
Only the A.Java file compiles successfully.
B.
Only the B.java file compiles successfully.
C.
Only the C.java file compiles successfully.
D.
The A.Java and B.java files compile successfully.
E.
The B.java and C.java files compile successfully.
F.
The A.Java and C.java files compile successfully.
Answer is A 
The B.java file has a class B, which has a private method that returns an int. However inside the method it has a local variable called “x” and it declares it private, you can’t use access modifiers (private, public, protected) inside a method body.
The C.java file has the package p1; as the second line of code in our file. The package statement HAS TO be the first statement in a file.

 
Question 466
Given the code fragment:
 
Which option represents the state of the num array after successful completion of the outer loop?
 
A.
Option A
B.
Option B
C.
Option C
D.
Option D
Answer is A
This is a two dimensional array, of one array three one dimensaion array. You can also say 1 row, three columns. 
So the numbering for the array goes
[0][0],[0][1],[0][2]
Anything other that the above will be ArrayIndexOutOfBounds. 
We have a nested for loop, which simply puts 10 into each index postion in the array, so at the end of the loope we have
num[0][0]=10;
num[0][1]=10;
num[0][2]=10
 
Question 467
Given the code fragment:
 
Which three lines fail to compile?
A.
Line 7
B.
Line 8
C.
Line 9
D.
Line 10
E.
Line 11
F.
Line 12
A line 7 fails to compile as you fVar is a float and you can’t assign a float value to a int variable, which is iVar
D line 10 fails to compile as you can’t assign a double to a float variable as a double is bigger than a float.
F line 12 fails as you can’t assign a double to a int variable
 
Question 468
Given the definitions of the MyString class and the Test class:
 
What is the result?
 
A.
Option A
B.
Option B
C.
Option C
D.
Option D
Answer is C
We are printing out a StringBuilder object, and the StringBuilder class has a toString() method that will print out the the text contained within the StringBuilder object. So this will print out
“Hello Java SE 8”
We next print out “hello” followed by a new MyString object. This object is created by calling the constructor in the MyString class that takes a string and assigns it to the instance variable msg. There is NO toString() method in the MyString class. Which means that the MyString class will then take it’s toString() method from the object class. The toString() method in the object class just prints out the address
So the second line prints
Hello p1.MyString@<<hashcode>> 
Question 469

Given:
 
What is the result?
A.
10:20
B.
0:20
C.
Compilation fails at line n1
D.
Compilation fails at line n2
Answer is D
At line n2 we have a call to a second constructor inside the Car constructor, which you can’t do. You can only call ONE constructor from inside another constructor.

 
Question 470
Which three are advantages of the Java exception mechanism?
A.
Improves the program structure because the error handling code is separated from the normal program 
function
B.
Provides a set of standard exceptions that covers all the possible errors
C.
Improves the program structure because the programmer can choose where to handle exceptions
D.
Improves the program structure because exceptions must be handled in the method in which they occurred
E.
Allows the creation of new exceptions that are tailored to the particular program being created
Answer is A,C,E
A is true as you have specific structures to deal with exceptions, you can have a try/catch Block or your method can Throw the exception
B is False, there is no system in all of creation that will cover all errors for any system. There are always new errors that can happen as well (i.e java interacting with some new technology or interacting with something it has not before or a new function). 
C is true we can handle the exceptions where they happen (with a try catch block) or we can throw them to some other method that can deal with the exceptions
D is false, exceptions do not have to be handled in the method they occurred as they can be thrown from the  method
E is true. Any exception class can be extended, so this allows you to create new exception classes that can be tailored exactly to fit your application. 
Question 471
Given the code fragment:
 
Which modification enables the code fragment to print TrueDone?
A.
Replace line 5 With String opt = “true”; 
Replace line 7 with case “true”:
B.
Replace line 5 with boolean opt = l; 
Replace line 7 with case 1=
C.
At line 9, remove the break statement.
D.
Remove the default section.
Answer is A
A switch statement cannot use a boolean, so you have to change the data type the switch statement uses to byte,short,int,char or a String.
A is correct
If you change the data type to the string “true” and then you replace the case true with case “true” this will print out “true” and after the case statement will print “done”
B is incorrect
A switch statement can’t use a boolean and a boolean is only true or false, anything else cannot be assigned to a boolean
C is incorrect
This will not compile as the issue is we are using a boolean for a switch which will not compile, just removing the break statement will not change this.
D is incorrect
Will not compile for the same reason stated in option C


 
Question 472
Given the following class:
 
And given the following main method, located in another class:
 
Which three lines, when inserted independently at line n1, cause the program to print a 0 balance?
A.
this.amount = 0;
B.
amount = 0;
C.
acct (0) ;
D.
acct.amount = 0;
E.
acct. getAmount () = 0;
F.
acct.changeAmount(0);
G.
acct.changeAmount(-acct.amount);
H.
acct.changeAmount(-acct.getAmount());

The line Math.random() produces a random number between 0 and 1, and we then multiple it by 1000 and casts the number to be of type int (which will just chop off the decimal points). So if Math.random() produces the number 0.78999 and we then multiply this by 1000, we get 788.99, we then cast this to int and get 788
A is incorrect
You can’t use the “this” keyword inside a static method
B is incorrect
You can’t access non static variables directly inside a stataic method
C is incorrect
Incorrect syntax
D is correct
This is assigning 0 to the amount attribute, of the acct CheckinAccount object. So the acct.getAmount() method will return the amount 0
E is incorrect
You can’t assign a value to a method reference
F is incorrect
This will add zero onto the existing amount, so if our existing amount was 500, this will just add 0 onto 500, which is still 500.
G is correct
You can send minus numbers to a method that is expecting numbers. So again using our existing amount of 500, we send -500 to the changeAmount() method and x becomes -500.
So the line amount+=x, is amount = amount+x. X is a minus number and amount is a plus number. The rule is when you have a minus and a plus number, the end result is subtraction. So the above reads 
amount=amount-x
which is
amount=500-500
so amount is 0
H is correct
This is getting the existing amount and sending this as a minus number to the changAccount() method and the saem process as option G then occurs.

 
Question 473
Which statement best describes encapsulation?
A.
Encapsulation ensures that classes can be designed so that only certain fields and methods of an object 
are accessible from other objects.
B.
Encapsulation ensures that classes can be designed so that their methods are inheritable.
C.
Encapsulation ensures that classes can be designed with some fields and methods declared as abstract.
D.
Encapsulation ensures that classes can be designed so that if a method has an argument MyType x, any 
subclass of MyType can be passed to that method.
Encapsulation is making your attributes of the class private and can only be accessed by getter and setter methods.
A is Correct
B is incorrect
Encapsulation does the exact opposite as if your atribtues are private they cannot be inherited
C is incorrect
Encapsulation has nothing to do with abstraction
D is incorrect
This is called covariance, Covariance is where we can pass a sub class to a method that is expecting a superclass object.

 
Question 474
Given the code fragment: 

// insert code here 

arr[0] = new int[3]; 
arr[0][0] = 1; 
arr[0][1] = 2; 
arr[0][2] = 3; 

arr[1] = new int[4]; 
arr[1][0] = 10; 
arr[1][1] = 20; 
arr[1][2] = 30; 
arr[1][3] = 40; 

there are three answer here, which probably means a typo in this question, it should probably say compile and execute
Which two statements, when inserted independently at line // insert code here, enable the code to compile and execute? 

A. int [] [] arr = null; 

B. int [] [] arr = new int [2]; 

C. int [] [] arr = new int [2] [ ]; 

D. int [] [] arr = new int [] [4]; 

E. int [] [] arr = new int [2] [0]; 

F. int [] [] arr = new int [0] [4]; 



A is incorrect
We can assign null to a one dimensional or mult dimensional array, this will compile, however it will generate a NullPointerException
B is incorrect
We can’t assign a one dimensional array reference to a two dimensional array object
C is correct
This is a two dimensional array reference to a two dimensional array object. The 2D array object has 2 rows, but we have not determined how many columns there will be on each row, which you can do
D is incorrect
You can’t assign length to a columns value in a two dimensional array and no value for rows.
E is correct
As the lines
arr[0] = new int[3]; arr[1] = new int[4]; 
assign new column amounts for each row, you are assigning a new one dimensional array for each row.
F is incorrect
This will also compile, but give us arrayIndexOutOfBoundsException, as the index positons referenced in the rest of the code will not exist.

Question 475
Given the following segment of code :
ArrayList<Vehicle>myList=new ArrayLIst<>();
myList.add(new MotorCycle());
Which two statements, if either were true, would make the code compile?

A. Vehicle is an interface that is implemented by the Motorcycle class.
B. Vehicle and Motorcycle both implement the Transportation interface
C. Vehicle is a superclass of Motorcycle.
D. Motorcycle is a superclass of Vehicle.
E. Vehicle and Motorcycle both extend the Transportation superclass.
F. Motorcycle is an interface that implements the Vehicle class.
Answer is A,C
A is correct
You can have a ArrayList type of objects that implement an interface, so if Vehicle is an interface you can have an arrayList like
ArrayList<Vehicle>myList
This will be an arrayList of objects that implement the Vehicle interface, if Motorcycle class implements this interface then a motorcycle object can be added to this arraylist.
B is incorrect
No mention of transportation in the code snippet, and if Transpiration was an interface the arraylist would have to be of type Transportation. 
C is Correct
If Vehicle is a class, then if you have an arraylist that can hold Vehicles that means you can add Vehicles and sub classes of Vehicle. If MotorCycle is a sub class of Vehicle then it can be added to this arraylist and means that Vehicle is a super class of Motorcycle
D is incorrect
You cannot add a super class object to arraylist of sub class objects
E is incorrect
Again no mention of transportation
F is incorrect
New MotorCycle() cannot compile as if Motorcycle is a interface we can’t create an instance of an interface.

 
Question 476
Given
public static void main(String[] args) {
		int[][]arr=new int[2][4];
		arr[0]=new int[] {1,3,5,7};
		arr[1]=new int[] {1,3};
		for(int[]a:arr) {
			for(int i:a) {
				System.out.print(i+" ");
			}
			System.out.println();
		}

	}
What is the result
A.	Compilation Fails
B.	1 3
1 3
C.	1 3
Followed by ArrayIndexOutOfBoundsException
D.	1 3
1 3 0 0 
E.	1 3 5 7 
13
Answer is E
int[][]arr=new int[2][4] creates a two dimensional array of 2 row and 4 columns or 2 one dimensional arrays with four numbers in each array. So when this array is created and you printed out the array it would look like this
0 0 0 0 
0 0 0 0 
As Arrays of numbers have default values of 0.
arr[0]=new int[] {1,3,5,7};
creates a new one dimensional array and assigns it to the first row of our two dimensional array. So the first array in our two dimensional array contains those above numbers
arr[1]=new int[] {1,3};
creates a new one dimensional array of length 2 and assigns it to our second row of two dimensional array. So our second array in our two dimensional array now only contains 2 numbers and NOT FOUR. We now have what is called a Asymmetric Multidimensional array, where each row has different amount of columns, which is allowed
the code
for(int[]a:arr) {
			for(int i:a) {
				System.out.print(i+" ");
			}
			System.out.println();
		}
Is a nested for loop that will print out all of the elements of the two dimensional array

 
Question 477
Given
public class Employee {
	private String name;
	private int age;
	private int salary;
	
	public Employee(String name,int age) {
		setName(name);
		setAge(age);
		setSalary(2000);
	}	
	public Employee(String name,int age,int salary) {
		setSalary(salary);
		this(name,age);
	}
	//getters and setters go here
	public void printDetails() {
		System.out.println(name+" : "+age+" : "+salary);
	}
}
Test.java
Class Test{
	public static void main(String[]args{
		Employee e1=new Employee();
		Employee e2 = new Employee(“jack, 50);
		Employee e3 = new Employee(“chloe”,40,5000);
		e1.printDetails();
		e2.printDetails();
		e3.printDetails();
	}
}
Which is the result
A.	Compilation fails in the Employee class
B.	Null : 0 : 0
Jack : 50 : 0 
Chloe : 40 : 5000
C.	Null : 0 : 0 
Jack : 50 : 2000
Chloe : 40 : 5000
D.	Compilation fails in Test class
E.	Both the Employee class and the test class fail to compile
Answer is E
In the Employee class in the constructor that takes a string, int and int, which is the following
public Employee(String name,int age,int salary) {
		setSalary(salary);
		this(name,age);//call to another constructor cannot be place here
	}
If a constructor has to call to another constructor inside it, this HAS to be the first line of code. Here it is the second line of code, so this will not compile
In the Test class, in main we have the line of code
Employee e2 = new Employee(“jack, 50);
The string parameter “jack” has an opening double quotes but no closing double quotes
 
Question 478
Given
public class Test {
	public static int stVar=100;
	public int var=200;
	public String toString() {
		return var+":"+stVar;
	}
}
And given the code fragment
Test t1=new Test();
		t1.var=300;
		System.out.println(t1);
		Test t2=new Test();
		t2.stVar=300;
		System.out.println(t2);
What is the result
A. 	300:300
200:300
B. 	300:100
200:300
C. 	300:0
0:300
D. 	200:300
200:300
Answer is B
t1.var=300 changes the value of the instance variable var for t1 only, stVar is not changed so it retains its original value of 100, so it prints out
300:100
t2.stVar changes the value of stVar to 300. Every object has its own var variable, but if given no value it will have a default value of 200. We do not give any value for var to t2 so it retains the default value of 200, so t2 prints out
200:300

 
Question 479
Given 
public class C2 {
	public void displayC2() {
		System.out.println("C2");
	}
}
interface I{
	public void displayI();
}
class C1 extends C2 implements I{
	public void displayI() {
		System.out.println("C1");
	}
}
And Given the code fragment
C2 obj1=new C1();
		I obj2=new C1();
		
		C2 s=obj2;
		I t = obj1;
		
		t.displayI();
		s.displayC2();
What is the result
A.	C2C2
B.	C1C2
C.	C1C1
D.	Compilation fails
Answer is D Compilation fails
Both classes and interface compile with no errors, it’s the code fragment that does not compile.
The line
C2 obj1=new C1();
Compiles as this is a super class reference to a sub class object. The class C2 is a super class of C1
The line
I obj2=new C1();
Compiles as this is an interface reference to an object of a class that implements the I interface. C1 class implements the I interface
The line 
C2 s=obj2;
Will not compile as obj2 is a INTERFACE reference to a C1 Object, C2 is a super class of C1, but C2 DOES NOT implement the I interface, so you can’t assign this object to a C2 reference. You could cast it like the following
C2 s=(C1)obj2;
And then you would have a super class C2 reference to sub class C1 object
The line 
I t = obj1;
Will not compile as the obj1 does NOT implement the I interface, Obj1 is super class C2 reference to a sub class C1 object and the reference is what determines if an object implements the interface or not, this is a C2 reference and C2 DOES NOT IMPLEMENT interface I.
The last two line of code cannot compile, as the previous two have not compiled.
 
Question 480
Given the code Fragment
int wd=0;
		String days[]= {"sun","mon","wed","sat"};
		for(String s:days) {
			switch(s) {
			case "sat":
			case "sun":
				wd-=1;
				break;
			case "mon":
				wd++;
			case "wed":
				wd+=2;
			}
		}
		System.out.println(wd);
What is the result
A.	3
B.	4
C.	-1
D.	Compilation fails
Answer is A 3
We have a int variable wd with an initial value of 0.
We have an array of Strings called days, that contain the Strings
“sun”, “mon”,”wed”,”sat”.
We then have a enhanced for loop that will go through each one of those days. Inside the for loop there is a switch statement, the switch statement will be run for each iteration of the loop.
First itereation, day is “sun”, wd is value of 0
Case “sun” triggers, decrements wd by 1, and breaks out of the switch statement (but NOT THE LOOP), so wd at end first iteration is -1 (0-1).
Second interation day is “mon”. wd is value of -1
Case “mon” triggers, increments wd by 1, wd becomes 0. There is no break after case “mon”, so it continues on to case “wed”, adds 2 to wd, wd becomes 2. Case statement finishes and wd at end of second iteration is 2
Third iteration day is “wed”. wd is value of 2
Case “wed” triggers increments wd by 2. Case statement finishes and wd at end of third iteration is 4 (2+2)
Four iteration day is “sat”, wd is value of 4
Case “sat” triggers, no break after this case so goes directly to case “sun”, which decrements wd by 1 (4-1). Switch case breaks, loop comes to end
Final value of wd is 3 (4-1)
 
Question 481
public interface Downloadable {
	public void download();
}
interface Readable extends Downloadable{//n1
	public void readBook();
}
abstract class Book implements Readable{//n2
	public void readBook() {
		System.out.println("Read book");
	}
}
class EBook extends Book{//n3
	public void readBook() {
		System.out.println("Read E-book");
	}
}
And Given the code fragment
Book book1=new EBook();
book1.readBook();
what is the result
A.	Compilation fails at line n2
B.	Read Book
C.	Read E-Book
D.	Compilation fails at line n1
E.	Compilation fails at line n3
Answer is E
An interface extends an interface, also as an interface is an abstract class it does not have to implement any abstract methods it inherits from another interface. So line n1 does compile as Readable does not have to implement the abstract method download that it inherited from the Downloadable interface. Any concrete class that implements Readable would have to implement both download() from Downloadable interface and readBook() from Readable interface
Similarly on line n2 Book is an abstract class so it does not have to implement any abstract methods it inherits or any abstract method contained in an interface it implements. So Book class does not have to provide a body for the download method. Any concrete sub class Book would have to provide a body for the download() method.
Line N3 produces a compilation error, as this is a concrete class and it inherits from Book, up to this point no body has been provided for the abstract download() method from the Downloadable interface. The first concrete class encountered then HAS to provide a body for the download() method. As this is the first concrete class encountered it has to provide implementation for the abstract download() method, it doesn’t so this is a compilation error
 
Question 482
Given the code fragment
Abstract class Toy{
	Int price
	//line n1
}
Which three code fragments are valid at line n1?(choose three)

A.	public static void insertToy(){
/*code goes here*/ }
B.	public abstract Toy getToy(){
return new toy();}
C.	public void printToy();
D.	public int calculatePrice(){
return price;}
E.	public abstract int compueDiscount();

Answer A,D,E
A is correct, you can have static,  non static and abstract methods in an abstract class
B is incorrect, a abstract method does NOT have any body
C is incorrect, if you have a abstract method in a abstract class you have to use the keyword abstract, like “public abstract void printToy()”. You do not have to use the abstract keyword for a abstract method in an interface
D is correct, you can have concrete methods in a abstract method, which is what this is
E is correct, this is the correct way to create a abstract method in a abstract class (a abstract method can only exist in a abstract class, if you have a abstract method you have to make your class abstract, a interface is a abstract class)
 
Question 483
Given
public class Test {
	int x,y;
	public Test(int x,int y) {
		initialize(x,y);
	}
	public void initialize(int x,int y) {
		this.x=x*x;
		this.y=y*y;
	}
	public static void main(String[]args) {
		int x=3,y=5;
		Test objc=new Test(x,y);
		System.out.println(x+" "+y);
	}
}
What is the result
A.	Compilation fails
B.	3 5
C.	0 0
D.	9 25
Answer is B
In main we create two int variables called x and y  and are given a value of 3 and 5 respectively. These variables are used to create a new test object and then these two values are squared and the values are then  assigned to the x and y variables of the Test object objc. This x and y are different variables to the LOCAL INT VARIABLES x and y contained within main() method.
The code then prints out x and y in main, however these are the LOCAL VARIABLES x and y and NOT the x and y variables of the objc Test object. So this merely prints out the values of the local x and y which is 3 5
Next question is question 85
 
Question 484
Given the code fragment
int array[]= {10,20,30,40,50};
int x=array.length;
/*line n1*/
Which two code fragments can be independently inserted at line n1 to enable the code to print the elements of the array in reverse order (choose two)
A
while(x>0) {
x--;
	System.out.println(array[x]);
}
B
do {
	x--;
	System.out.println(array[x]);
}while(x>=0);
C
while(x>=0) {
	System.out.println(array[x]);
	x--;
}
D
do {
	System.out.println(array[x]);
}while(x>=0);
Answer is A,B
this is an array of 5 numbers, so array.length will be the number 5, so x will be set to 5. If we went
array[x] this would give us ArrayIndexOutOfBoundsException as this would be array[5] and this array only goes as far as array[4] (array numbering starts at 0). So that rules out C and D as both of those print out array[x] as the first statement inside the loop, which would mean that the very first iteration of the loop would attempt to print out array[5], which will generate an ArrayIndexOutOfBoundsException.
That means only A and B will be correct, this is a slight trick question as B will print out the numbers in reverse order, but at the very end it will have an arrayOutOfBoundsException, but not before it  prints out the numbers. The question is not asking you does the code fully compile, its’ just asking you does it print out, and B does print them out. Reason it causes an exception is that the final value of x will be -1, so if it attempts to print out array[-1]
 
Question 485
Given the code fragment
String[]arr= {"Hi","How","Are","You"};
List<String>arrList=new ArrayList<>(Arrays.asList(arr));
if(arrList.removeIf((String s)->(return s.length()<=2;))){
			System.out.println(s+" removed");
		}
What is the result
A.	Compilation fails
B.	Hi Removed
C.	An UnsupportedOperationException is thrown at runtime
D.	The program compiles but it prints nothing
Answer is A
The first point to note about this code is that there seems to be code that we have not covered, specifically the removeIf() method, which is a method that takes a predicate is not on the exam. So here we are looking to see what is wrong with this as this will not compile. If you are going to use the “return” keyword in a predicate YOU HAVE to have curly brackets surrounding the body of your predicate like the following:
(String s)->{return s.length()<=2;};
So the line
(String s)->(return s.length()<=2;)
Will not compile as there is no curly brackets surrounding the body of the predicate
The second problem with this is when you declare a variable inside a predicate, in this case “String s”, it is NOT available outside of the predicate, it is Local to the predicate. Here in our if statement we try to access the s variable that was declared inside the predicate, which we cannot do.
The line
System.out.println(s+" removed");
Is trying to access the s variable created inside the predicate outside of the predicate
 
Question 486
Given
class Student {
	String name;
	public Student(String name) {
		this.name=name;
	}
}
public class Test{
	public static void main(String[]args){
		Student[]students=new Student[3];
		students[1]=new Student("Richard");
		students[2]=new Student("Donald");
		for(Student s:students) {
			System.out.println(s.name);
		}
	}
}
What is the Result
A.	Null
Richard
Donald
B.	Richard
Donald
C.	Compilation fails
D.	An ArrayIndexOutOfBoundsException is thrown at runtime
E.	A NullPointerException is thrown at runtime.
Answer is E
In an array of objects of any type, if not given any explicit values will have a default value of null. So in our array we initially have an Student array of length 3, which means our array looks like
null,null,null
when you have an array of objects and you don’t assign any values to any position of the array, then each index position in the array will be occupied by a null object.
We then assign a student to second index position in array
students[1]=new Student("Richard");
and to third index position in array
students[2]=new Student("Donald");
so our array no looks like
null, Student “Richard”, Student “Donald”;
we then have a enhanced for loop that attempts to print the name variable of each student. It’s not a error to print out a null object, but you will get a NullPointerException if you attempt to call a method on a null object or access a variable of a null object
in the loop we attempt to access the name variable for each student, but one of the objects is a NULL object, and you can’t access the name variable of the Student class with a null object. 
Students[0]=null;
So 
System.out.println(students[0].name)
Will produce a nullPointerException
 
Question 487
Given
 
What is the result
A.	Hello Log 1:0
B.	Hello Log 2:0
C.	Welcome Log 2:1
D.	Welcome Log 1:0
Answer is C
X given initial value of 1 and Y given initial value of 0
If(x++ > ++y) 
Is read so X is incremented by 1, AFTER it is used here, and Y is incremented by 1 BEFORE it is used here. So this reads
If(1>1)
So the if body does not execute and the else body executes instead and prints 
“Welcome “
After the else X now has a value of 2, as it was incremented after the if and Y still has a value of 1. So the statement 
System.out.print(“log “+x+”:”+y);
Prints out 
Log 2:1
So what it prints out in total is 
Welcome Log 2:1
 
Question 488
Given the code snippet from a compiled Java source file
 
Which command-line arguments should you pass to the program to obtain the following output?
Arg is 2
A. java MyFile 1 3 2 2
B. java MyFile 2 2 2
C. java MyFile 1 2 2 3 4
D. java MyFile 0 1 2 3
Answer is A
When you run a application from the command line prompt you have to run two commands, first one is the compiler, which is called javac followed by the name of the file, so to compile the above file you would go
Javac MyFile.java
And then to run this you run the java program. You do this by passing in the name of the class you want to run and which also contains a main method. You can pass in string arguments to the main method, each string you wish to pass into the array will be separated by a space
So if we go 
Java MyFile 1 3 2 2
This will run the main method in the MyFile class and pass in the argument 
1
3
2
2
As strings into the String array args of main, so after we do this our array of string args looks like this
args[0]=1
args[1]=3
args[2]=2
args[3]=2
in main if we print out args[0] we will get “1”, if we print out args[3] we will get “2”
args[3] is assigned to the String arg3, so arg3 is the value 2, so 
system.out.println(“Arg is “+arg3
will print out arg is 2
 
Question 489
Given the code fragment
 
What is the result
A. 1 2 3 4
followed by an ArrayIndexOutOfBoundsException
B. 1 2 3
C. 1 2 3 4
D. Compilation fails.
Answer is B
We have an array arr, of length 3. We have a do while loop and a counter I, at the start counter is set to 0. The loop will continue to loop while I is less than arr.length-1, arr.length is 4, so arr.length-1 is 4-1, so this loop will execute three times.
Inside the loop it will print out the current select array number, and then increment by one
So the loop execution looks like
i=0;
	arr[0]=1`
	i++, i is 1
	arr[1]=2
	i++, i is 2
	arr[2]=3
	i++, i is 3
loop exits at this point as i is now no longer smaller than 3

 
Question 490
 
And given the commands
Javac Test.java
Java Test Hello
What is the result
A.	Success
B.	Failure
C.	Compilation fails
D.	An Exception is thrown at runtime
Answer is B
We pass in the “Hello” to String[]args, so that the args array now looks like
Args[0]=”Hello”
The line
If(args[0].equals(“Hello”)?false:true) 
Args[0]is the String hello, so args[0].equals(“Hello”) is TRUE
So this reads
If(true?false:true)
What this means is that if args[0] is “hello” that is true and if this is true the ternary operator will make the whole if condition false, so this reads
If(false)
Which means that the if body is NOT excuted and instead the else body is executed, and will print out 
Failure
 
Question 491
Which one of the following code examples uses valid java syntax
 
A.	Option a
B.	Option B
C.	Option C
D.	Option D
Answer is A
A is correct way to create a class and is a correct form of main() method
B is incorrect as we do not give the array of strings passed into main any name
C is incorrect as the main method has to static
D is incorrect as it should be “String[]args” not “String()args”, the wrong type of bracket is used.
 
Question 492
Given the Code fragments:
 
What is the result?
A.	Compilation fails only at line n2.
B.	RTool::export
Tool::export
C.	Tool::export
Tool:export
D.	Compilation fails only at line n1.
E.	Compilation fails at both line n1 and line n2.
Answer is D
Every abstract method in a interface is public, that means any class that implements an interface has to override the abstract methods contained in the interface. A overriding method CANNOT make a method less available, if overriding a public method, the overriding method has to be also public. Here we have an interface Exportable which contains the abstract method Export(), this method is
 abstract public void Export()
so any class that implements the Exportable interface has to override the export method, and it also has to be public. Class Tool implements Exportable, however the line
protected void export()
will not compile as we are making an overridden method LESS available, which is not allowed, this method would have to be
public void export()
to be overridden successfully.
Line n2 does not cause a compilation error as this is correctly overriding the export() method from the Exportable interface
 
Question 493
Given
 
Given the code fragment:
 
Which two sets of Actions, independently enable to code fragment to print fit?
A.	At line n1 insert: import clothing.Shirt;
At line n2 insert: String color = getColor();
B.	At line n1 insert: import clothing.*;
At line n2 insert: String color = Shirt.getColor();
C.	C. At line n1 insert: import static clothing.Shirt.getcolor;
At line n2 insert: String color = getColor();
D.	At line n1 no changes required.
At line n2 insert: String color = Shirt.getColor();
E.	At line n1 insert: import clothing;
At line n2 insert: String color = Shirt.getColor();
Answer is B,C
A is incorrect as import clothing.shirt will import only the non statics, although we could still access the statics by the name of the class.name of static member (in this case it would be Shirt.getColor). line n2 then tries to access getColor() by just using the name of the method, you can’t do this unless you had a static import for the class it is in or package. i.e import static clothing.Shirt.*;
B is correct as we are importing all the non statics of the Clothing package, with the statement 
Import clothing.*;
This still allows us to access statics by using the name of the class.name of the static member. 
The line 
String color=Shirt.getColor() is access the static method by using the name of class.name of static member, which is allowed when we import all non static members of a package
C is correct as line n1
Import static clothing.Shirt.getcolor()
Imports the static method getColor() which means we can simply access this method by just using the name of the method
The line 
String color=getColor()
Is allowed as we have done a static import for the getColor() method so we can access it by just using the method name.
D is incorrect
If you want to use classes from a different package we have import from that package or we can use the full qualified name such as 
clothing.Shirt.getColor()
E is incorrect
We can’t just import from a package like
Import clothing;
You can import all by going 
Import clothing.*;
Or we can import a particular class
Import clothing.Shirt;
 
Question 494
Given the code fragment
 
What is the result
A.	2012-02-10
B.	2012-02-11
C.	Compilation fails
D.	A DateTimeException is thrown at runtime.
Answer is D
The line 
LocalDate date=LocalDate.of(2012,01,32);
Will throw a DateTimeException as January only has 31 days. Illegal dates or times will throw a DateTimeException, which is a runtime exception.
 
Question 495
Given
 
What is the result
A. 10 Hello Hello 11
B. 10 Hello Hello 121
C. 100 Hello 121
D. 100 Hello Hello 121
E. 10 Hello 11
Answer is A
We have an Test object called item, we set the a1 variable of the item Test object to be 11. We create a new StringBuilder object, sb, which contains the text “Hello”. We create an Integer wrapper object i which has a value of 10. We sent the wrapper object to the doProduct() now whereas you can change the variables of an object, you can’t change what the object refers to in a method, so any changes in the doProduct() method are NOT reflected outside of the doProduct() method, so I is still 10 after the method call doProduct
doString(sb) sends the stringbuilder object that contains the string “hello” to the doString() method. Inside the method s.append(“ “+s) changes the StringBuilder object to become “Hello Hello”. You can change a stringbuilder object atributes and you are not changing what the StringBuilder refers too, so this change will be reflected outside of the doString() method. So after the method call sb has a value of “Hello Hello”;
doProduct(item.al) is sending the primitive variable to this method, so any changes to this variable will NOT be reflected outside of the doProduct() method. So item.a1 still has a value of 11 after this method call
so we finally get
10 Hello Hello 11
 



































