<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Tue Apr 20 13:01:24 IST 2021 -->
<title>Examples</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-04-20">
<meta name="description" content="declaration: package: com.android, class: Examples">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Examples.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.android</a></div>
<h1 title="Class Examples" class="title">Class Examples</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.android.Examples</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="type-name-label">Examples</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></pre>
<div class="block">this class contains all the code that deals with this topic</div>
<dl class="notes">
<dt>Author:</dt>
<dd>NoelF</dd>
<dt>See Also:</dt>
<dd><a href="#ex1()"><code>ex1()</code></a>, 
<a href="#ex2()"><code>ex2()</code></a>, 
<a href="#ex3()"><code>ex3()</code></a>, 
<a href="#ex4()"><code>ex4()</code></a>, 
<a href="#ex5()"><code>ex5()</code></a>, 
<a href="#ex6()"><code>ex6()</code></a>, 
<a href="#ex7()"><code>ex7()</code></a>, 
<a href="#ex8()"><code>ex8()</code></a>, 
<a href="#ex9()"><code>ex9()</code></a></dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>(package private) static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#count">count</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">Examples</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="table-tab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>(package private) static <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" title="class or interface in java.util" class="external-link">Optional</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" title="class or interface in java.lang" class="external-link">Integer</a>&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#calculator(java.lang.String)">calculator</a></span>&#8203;(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;str)</code></th>
<td class="col-last">
<div class="block">this takes in a string and returns an <code>Optional&lt;Integer&gt;</code> which is a the amount of characters in 
 the string sent to this method</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex1()">ex1</a></span>()</code></th>
<td class="col-last">
<div class="block">This class shoes lazy instantiation of a Stream variable.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex2()">ex2</a></span>()</code></th>
<td class="col-last">
<div class="block">this code deals with Optional Functional programming, which is simply using the Optional data types with with functional
 programming.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex3()">ex3</a></span>()</code></th>
<td class="col-last">
<div class="block">the code in this method and <a href="#ex4()"><code>ex4()</code></a> and <a href="#ex5()"><code>ex5()</code></a> all relate to the Terminal operation
 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect(java.util.stream.Collector)" title="class or interface in java.util.stream" class="external-link"><code>Stream.collect(java.util.stream.Collector)</code></a> and the various methods of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" title="class or interface in java.util.stream" class="external-link"><code>Collectors</code></a> that
 a Collect can take.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex4()">ex4</a></span>()</code></th>
<td class="col-last">
<div class="block">this code deals with Collectors.counting() and Collectors.joining()
 counting() is a simple method that returns a Long wrapper object, if we want to use this object as a primitive number we can use the 
 longValue(), intValue() methods of the wrapper class to return a primitive equivalent ie <code>
 Stream.generate(()-&gt;(int)(Math.random()*100)).//generates stream of random ints between 1 and 100
 limit(50).//limits to 50 numbers
 filter(n-&gt;n%2==0).//filters to only even numbers, so don't know how many numbers in stream at this point
 collect(Collectors.counting())).//counts the amount of Strings and returns the number as a Long wrapper
 longValue() //returns a primitive long version of the Wrapper Long     </code>
 The next method covered in this code is Collectors.join() which only works for Streams of Strings, and it used for contcatentating 
 a Stream string into one String.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex5()">ex5</a></span>()</code></th>
<td class="col-last">
<div class="block">This covers the methods Collectors.maxBy(Comparator) and Collectors.MinBy(Comparator) both of which return an optional of the type
 of the Stream;
 minBy returns a Optional with the minimum value determined by the comparator passed as an argument 
 maxBy returns a Optional with the maximum value determined by the comparator passed as an argument i.e
 <code>
 Stream.generate(()-&gt;(int)(Math.random()*100)).//produces a stream of random numbers
 limit(10).//limits to 10 numbers
 peek(System.out::println).//prints out all 10 numbers
 collect(Collectors.maxBy((n1,n2)-&gt;n1.compareTo(n2))).//returns a Optional&lt;Integer&gt;
 get()//gets the number contained in the Optional which will be the number with the maximum value  </code>
 minBy() operates in the same way as maxBy(), and uses the same comparator to find the minimum value</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex6()">ex6</a></span>()</code></th>
<td class="col-last">
<div class="block">we can create objects that hold information about streams, previously in section 4.5 we used SummaryStatics object which held information
 about a primitive stream, i.e IntSummaryStatistics for IntStream, DoubleSummaryStatistics for DoubleStream.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex7()">ex7</a></span>()</code></th>
<td class="col-last">
<div class="block">to save a stream to a Map we cannot use Collectors.toCollection() as a Map does not implement Collection and this method can only be used
 with objects that implements the Collection interface (Lists, Sets, Queues).</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex8()">ex8</a></span>()</code></th>
<td class="col-last">
<div class="block">this code deals with three overloaded Collectors.groupingBy() and Collectors.partitioningB().</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>(package private) static void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ex9()">ex9</a></span>()</code></th>
<td class="col-last">
<div class="block">Collectors.groupingBy() as we have seen in the previous code allows us to group our streams in whatever criteria we want, here we cover the method
Collectors.mapping() which allows us to format the values produced by Collectors.groupingBy() in whatever way we want.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>(package private) static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#generateRandom()">generateRandom</a></span>()</code></th>
<td class="col-last">
<div class="block">method used in <a href="#ex6()"><code>ex6()</code></a> and generates a randon number between 1 and 100 inclusive</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="count">
<h3>count</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">count</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>Examples</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">Examples</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="ex1()">
<h3>ex1</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex1</span>()</div>
<div class="block">This class shoes lazy instantiation of a Stream variable. This is where some initial creation and intermediate operation is carried out on a Stream, but
 not a Terminal operation, so nothing is produced until some Terminal operation is carried out on the Stream. 
 First we have a <a href="Dog.html" title="class in com.android"><code>Dog</code></a> class and it has a Stream variable <code>private Stream&lt;Integer&gt;myStream;</code>. There is an initialisation block
 <code>myStream=Stream.iterate(1, i-&gt;i*2).limit(10).peek(System.out::println); </code>
 but there is NO terminal operation, so nothing is produced at this point. It is only when a dog calls the <a href="Dog.html#bark()"><code>Dog.bark()</code></a> method that
 the stream is instantiated as only at this point is a Terminal forEach()operation called on the Stream <code>
 myStream.filter(x-&gt;x%2==0).forEach((n)-&gt;System.out.println("number is "+n));		</code>
 The same happens for the <a href="Human.html" title="class in com.android"><code>Human</code></a> class as it has a Stream variable <code>Stream&lt;Shoes&gt;myShoes</code>. There is an initialisation block <code>
 myShoes=Stream.generate(()-&gt;new Shoes((int)(Math.random()*10+1),Colour.BLACK)).
						filter((s)-&gt;s.size&gt;6).
						filter(s-&gt;s.size&lt;9);   </code>
                but there is NO terminal operation, so nothing is produced at this point. It is only when a human calls the <a href="Human.html#makeShoes()"><code>Human.makeShoes()</code></a> method
                the stream is instantiated as only at this point is a Terminal collect() operation called on the Stream <code>
		shoeSet=myShoes.limit(shoeAmt).collect(Collectors.toSet());</code></div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="Human.html" title="class in com.android"><code>Human</code></a>, 
<a href="Shoes.html" title="class in com.android"><code>Shoes</code></a>, 
<a href="Colour.html" title="enum in com.android"><code>Colour</code></a>, 
<a href="Dog.html" title="class in com.android"><code>Dog</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ex2()">
<h3>ex2</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex2</span>()</div>
<div class="block">this code deals with Optional Functional programming, which is simply using the Optional data types with with functional
 programming. An Optional can have a any data type, i.e in our code we can have <code>
 Optional&lt;Shoes&gt;optShoes;
 Optional&lt;Human&gt;optHuman;</code>
 or we can have built in java datatype such as OptionalInt, OptionalDouble, etc
 So for instance you have a have a Optional of type shoes, which will be the shoes with the largest shoe size <code>
 Stream.generate(()-&gt;new Shoes((int)(Math.random()*10+1),Colour.BLACK)).//produces random sized shoes
		distinct().//make sure all unique, use equals method of the Shoes class (this was addd after video produced)
		limit(7).//limit to 7 pairs of shoes
		peek(System.out::println).//will print them out to see shoes created
		max((s1,s2)-&gt;s1.size-s2.size);//will return an Optional&lt;Shoe&gt; type </code>
 Or we can have we can have one of the built in Optional types returned, here it's a OptionalInt returned <code>
 IntStream .generate(()-&gt;(int)(Math.random()*100)).limit(7).max();</code>
 So we can have object streams or streams of primitive type, that have terminal operations that return a Optional as one type
 of functional programming. We also can perform functional programming operations on the actual Optional object itself,some of these method return
 a optional, which then means we can call other methods of the Optional class in a chained fashion similar to functional programming with Streams.
 the main methods for Optionals we will cover here are 
 filter() 
 <code>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code> 
 which takes a predicate of the type of of the Optional, i.e checking if an optional String, optStr, has a length greater than 4 <code>
  optStr.filter(s-&gt;s.length()&gt;4)</code>
 map() 
 <code>public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</code>
 which takes a Function that takes a type of the optional and returns either the same type or a different type of Optional, i.e taking in optional Integer
 , optInt, and converting it to a optional String <code>
 optInt.map(n-&gt;"this is the number"+n)</code>
 and flatMap <code>
 public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) </code>
 which takes a function and operates in much the same fashion as Map, and can be used as an alternative to Map
 the code using flatMap uses the method <a href="#calculator(java.lang.String)"><code>calculator(String)</code></a> to illustrate flatMap</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#calculator(java.lang.String)"><code>calculator(String)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="calculator(java.lang.String)">
<h3>calculator</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" title="class or interface in java.util" class="external-link">Optional</a>&lt;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" title="class or interface in java.lang" class="external-link">Integer</a>&gt;</span>&nbsp;<span class="member-name">calculator</span>&#8203;(<span class="parameters"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;str)</span></div>
<div class="block">this takes in a string and returns an <code>Optional&lt;Integer&gt;</code> which is a the amount of characters in 
 the string sent to this method</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>str</code> - String sent to the method</dd>
<dt>Returns:</dt>
<dd>amount of letters in the String sent to method</dd>
<dt>See Also:</dt>
<dd><a href="#ex2()"><code>ex2()</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ex3()">
<h3>ex3</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex3</span>()</div>
<div class="block">the code in this method and <a href="#ex4()"><code>ex4()</code></a> and <a href="#ex5()"><code>ex5()</code></a> all relate to the Terminal operation
 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect(java.util.stream.Collector)" title="class or interface in java.util.stream" class="external-link"><code>Stream.collect(java.util.stream.Collector)</code></a> and the various methods of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" title="class or interface in java.util.stream" class="external-link"><code>Collectors</code></a> that
 a Collect can take. we first cover Collectors.toCollection() which can return any class that implements the Collection interface.
 we come accross our first instance of ToIntFunction and ToDoubleFunction, which can be confused with IntFunction and DoubleFunction. 
 The difference is ToIntFunction always RETURNS A PRIMITIVE INT and can take any type e.g 
 <code>ToIntFunction&lt;String&gt;toIntStr=s-&gt;s.length();    </code>
 a IntFunction always TAKES A INT as a parameter and can return any type
  <code>IntFunction&lt;String&gt;intFunc=n-&gt;"this returns our String with a number "+n;</code>
 ToIntFunction and ToDoubleFunction are used with Collectors.averagingDouble() and Collectors.averagingInt(), both of which return a double.
 an example would be the following <code>
 Stream.iterate(5, n-&gt;n*5).
 limit(5).//creates list of 5,25,125,625,3125
 peek(System.out::println).//prints out list to check numbers
 collect(Collectors.averagingInt(n-&gt;n)); </code>//takes a ToIntFunction, which returns a primitive int, but the averagingInt method itself returns this
as a double</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect(java.util.stream.Collector)" title="class or interface in java.util.stream" class="external-link"><code>Stream.collect(java.util.stream.Collector)</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ex4()">
<h3>ex4</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex4</span>()</div>
<div class="block">this code deals with Collectors.counting() and Collectors.joining()
 counting() is a simple method that returns a Long wrapper object, if we want to use this object as a primitive number we can use the 
 longValue(), intValue() methods of the wrapper class to return a primitive equivalent ie <code>
 Stream.generate(()-&gt;(int)(Math.random()*100)).//generates stream of random ints between 1 and 100
 limit(50).//limits to 50 numbers
 filter(n-&gt;n%2==0).//filters to only even numbers, so don't know how many numbers in stream at this point
 collect(Collectors.counting())).//counts the amount of Strings and returns the number as a Long wrapper
 longValue() //returns a primitive long version of the Wrapper Long     </code>
 The next method covered in this code is Collectors.join() which only works for Streams of Strings, and it used for contcatentating 
 a Stream string into one String.
 first overloaded method takes no argumenst and concatenates the String into one string <code>
 Stream.of("hello","there","people").collect(Collectors.joining())  </code>
 produces the String "hellotherepeople"
 Second overloaded method takes one String argument, a serperator or more commonly known as a delimiter which will be between every original 
 string in the new concatenate String i.e <code>
 Stream.of("apple","orange","banana").collect(Collectors.joining("-"))      </code>
 produces the String "apple-orange-banana"
 Third overloaded method takes a delimiter string, a prefix string and a suffix string i.e <code>
 Stream.of("beef","lamb","potato","chocolate").collect(Collectors.joining(", ","I eat "," a lot"))		</code>
 produces "I eat beef, lamb, potato, chocolate a lot"</div>
</section>
</li>
<li>
<section class="detail" id="ex5()">
<h3>ex5</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex5</span>()</div>
<div class="block">This covers the methods Collectors.maxBy(Comparator) and Collectors.MinBy(Comparator) both of which return an optional of the type
 of the Stream;
 minBy returns a Optional with the minimum value determined by the comparator passed as an argument 
 maxBy returns a Optional with the maximum value determined by the comparator passed as an argument i.e
 <code>
 Stream.generate(()-&gt;(int)(Math.random()*100)).//produces a stream of random numbers
 limit(10).//limits to 10 numbers
 peek(System.out::println).//prints out all 10 numbers
 collect(Collectors.maxBy((n1,n2)-&gt;n1.compareTo(n2))).//returns a Optional&lt;Integer&gt;
 get()//gets the number contained in the Optional which will be the number with the maximum value  </code>
 minBy() operates in the same way as maxBy(), and uses the same comparator to find the minimum value</div>
</section>
</li>
<li>
<section class="detail" id="generateRandom()">
<h3>generateRandom</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">generateRandom</span>()</div>
<div class="block">method used in <a href="#ex6()"><code>ex6()</code></a> and generates a randon number between 1 and 100 inclusive</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a int between the numbers 1 and 100 inclusive</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ex6()">
<h3>ex6</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex6</span>()</div>
<div class="block">we can create objects that hold information about streams, previously in section 4.5 we used SummaryStatics object which held information
 about a primitive stream, i.e IntSummaryStatistics for IntStream, DoubleSummaryStatistics for DoubleStream. 
 We can also use these classes to get information about Streams of objects, and using the methods Collectors.sumarizingInt() and
 Collectiors.summarizingDouble() firstly in conjuction with these summaryStatistics, getting information about ages of Dog from a stream of
 dogs <code>assume dogStream is a stream of 10 dogs with different weights
 DoubleSummaryStatistics dogStats=dogStream.collect(Collectors.summarizingDouble(d-&gt;d.weight));
 dogStats.getMax()//returns max weight, dogStats.getMin()//returns min weight dogStats.getCount()//returns count of weights
 dogStats.getSum()//returns sum of weights dogStats.getAverage()//returns average weight		</code>
 this code also covers summingDouble(), summingInt() which takes a to ToIntFunction and a ToDoubleFunction respectively and returns a primitive
 int and a primitive double respectively. i.e <code>
 dogStream.collect(Collectors.summingDouble(d-&gt;d.weight));//gets sum of all weights of the Dogs			</code>
 we also cover Collectors.toCollection() which is a terminal operation that allows us to save all of the objects of a stream to any 
 object that implements the Collection interface, which are lists, sets and queues (but not maps there is a seperate method for this)</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="Dog.html" title="class in com.android"><code>Dog</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ex7()">
<h3>ex7</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex7</span>()</div>
<div class="block">to save a stream to a Map we cannot use Collectors.toCollection() as a Map does not implement Collection and this method can only be used
 with objects that implements the Collection interface (Lists, Sets, Queues). So instead we use Collectors.toMap(), of which there
 are three overloaded methods
 First overloaded method
 collect(Collectors.toMap(keyMapper function, valueMapper function)
 this takes a function that takes in an object of type of the Stream and returns a unique key for this entry in the Map
 the second argument is also a fuction that takes and object of type of the stream and returns a value for this entry in a Map
 i.e a Stream of Shoes with it's hashcode as a key and the pair of shoes as the value, the Stream will be consist of all unique shoes and
 be called shoeStream<code>
 Map&lt;Integer,Shoes&gt;shoeMap=shoeStream.collect(Collectors.toMap(s-&gt;s.hashCode(), s-&gt;s));		</code>
 SECOND OVERLOADED METHOD
 overloaded toMap() method takes a function,function and BinaryOperator
 first argument creates the key
 second argumetn creates the value
 third arguement is what happens when you have two keys the same, we do an example again using the same stream of unique shoes and if two
 keys are the same we simply add up the two keys to create a new key<code>
 Map&lt;Integer,Shoes&gt;shoeMap=shoeStream.collect(Collectors.toMap(s-&gt;s.hashCode(), s-&gt;s,(n1,n2)-&gt;n1+n2)); 	 	</code>
 THIRD OVERLOADED METHOD
 overloaded toMap() method that takes a function, function, binaryOperator and a supplier
 first argument creates the key
 second argument creates the value
 third argument is what happens when you have two keys the same,
 fourth argument is the type of Map the stream of objects will be save too. we do an example again using stream of shoes.ie <code>
 TreeMap&lt;Integer,Shoes&gt;shoeMap=shoeStream.collect(Collectors.toMap(s-&gt;s.hashCode(), //function takes in a shoe returns a hashcode uses as key
 																		s-&gt;s,//function takes in shoes and returns the same shoes
 																		(n1,n2)-&gt;n1+n2),//if same keys just add up both keys to produce new key 	
 																		TreeMap::new);//supplier creates our TreeMap	</code></div>
</section>
</li>
<li>
<section class="detail" id="ex8()">
<h3>ex8</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex8</span>()</div>
<div class="block">this code deals with three overloaded Collectors.groupingBy() and Collectors.partitioningB(). GroupingBy allows us to produce lists from a Stream
 of objects and group those lists in whatever criteria we desire, this will then be save as a map, the key will be whatever grouping criteria we use
 and the value will be a list of objects that match the criteria
  for example we have a list of 8 strings of varying length, <code>
 "dog","cat","mouse","cow","sheep","pig","elephant","antelope")		</code>
 we then with to produce a stream from this list and then group the strings by the amount of letters in each string. The key will be the length of the
 String, the value will be a list of Strings that have that amount of characters in them. So the above list would produce a map like of three entries like
 the following <code>
 3=[dog, cat, cow, pig], // we have key value of 3, and the value is a list of three Strings in our stream that have three characters
 5=[mouse, sheep], //we have key value of 5, and the value is a list of 2 strings in our stream that have 5 characters
 8=[elephant, antelope]//we have key value of 8, and the value of is a list of 2 strings in our Stream that have 8 characters	</code>
 We have three overloaded Collectors.groupingBy() method
 OVERLOADED METHOD 1
 using our stream of Strings example from above and calling the Stream "animals", takes one argument a function, in this 
 case it takes in a String, which is each one of the Strings and returns an int, which is the amount of characters in each String. the method itself
 returns a  <code>Map&lt;Integer,List&lt;String&gt;&gt; object </code> and the method signature looks like<code>
 Collectors.groupingBy(Function&lt;String, Integer&gt; classifier)	</code>
 and the actual calling of the method looks like the following <code>
 Map&lt;Integer,List&lt;String&gt;&gt;tMapList=animals.stream().collect(Collectors.groupingBy(s-&gt;s.length()))		</code>
 OVERLOADED METHOD 2
 Again using our stream of Strings. The previous method can only produce a key and the value will always be a List of Objects, in the previous example
 this was a list of Strings. This overloaded Collectors.groupingBy() still produces a map, but allows our value to be a different collection object, i.e a
 set, a queue. This method takes two arguments the first is a function, the same as in the first overloaded method, the second is object that will be the
 returned which will be the value Collector object. So the a simplified message signature for the Stream of Strings would be (the actual message signature
 is rather involved to say the least).
 <code>Collectors.groupingBy(Function&lt;String,Integer&gt;,Collector))	</code>
 and the actual calling of the method looks like the following <code>
 Map&lt;Integer,Set&lt;String&gt;&gt;tMapSet=animals.stream().
										collect(Collectors.groupingBy(s-&gt;s.length(),Collectors.toSet()));</code>
                This produces a map with the key being the the amount of characters in a String, and the value being a set with of all those strings with that amount
                of characters in a string. So we can see the main difference here is that the value can be any type of Collection object, here we have Set of Strings.
 OVERLOADED METHOD 3
 The two previous overloaded methods will create a Map, and the first one will produce a from a Stream of Strings <code>
 Map&lt;Integer,List&lt;String&gt;&gt;</code>
 the second overloaded method can produced any type of collection object that will be the value, so from the stream of strings you could produced <code>
 Map&lt;Integer,Set&lt;String&gt;&gt;</code> or <code>Map&lt;Integer,ArrayDeque&lt;String&gt;&gt;	</code> or any other object that implements Collection (List,Set,Queue). 
 So both of these method return a MAP, and can return nothing else. This overloaded method allows us to produce different types of Maps, this overloaded
 method takes three parameters. The first argument is a function, same as the previous two overloaded methods, the second argument is supplier which 
 will supply the type of Map you want returned by the whole method, the third argument is a Collector that produces a Collection object that will
 hold the values of the map.  So again we have a simplified method signature for the Stream of Strings would be (as again the actual message signature
 is long and extremely involved and to be honest you don't really need to know it) <code>
 Collectors.groupingBy(Functions&lt;String,Integer&gt;
 ,Supplier&lt;? extends Map&gt;, //this will be type of Map produced by the whole method
 Collector//this will return a Collection object that will hold the values in our final Map	</code>
 the actual calling of the method could look like the following: <code>
 TreeMap&lt;Integer,TreeSet&lt;String&gt;&gt;tTreeMapTree=animals.stream().
				collect(Collectors.groupingBy(
						String::length, //same as s-&gt;s.length(), the key will be the length of String, the value will be a collection of Strings
						TreeMap::new, //same as ()-&gt;new TreeMap&lt;Integer,TreeSet&lt;String&gt;&gt;(), the type of Map returned by the whole method
						Collectors.toCollection(TreeSet::new)));//same as ()-&gt;new TreeSet&lt;String&gt;(), the value will be a TreeSet of Strings
 </code>this produces a TreeMap, with an Integer as a key, which will be the amount of characters in a String, and a value which will be TreeSet of 
 Strings which will have the same amount of characters as the key Integer value
 PARTITIONING
 partitions are created by the Collector.partitioningBy() method and are simply special form of Grouping of which there are only two possible groups,
 the boolean true or false. The first method takes a predicate, which will divide your streams up into a Map of two lists and one have a key of true and 
 one a key of false. This code will produce a map with all Strings with a length greater than or equal to 4 with a  <code>
 Map&lt;Boolean,List&lt;String&gt;&gt;partMap=animals.stream().
				collect(Collectors.partitioningBy(s-&gt;s.length()&gt;=4));
 </code> the second overloaded partitioningBy() method takes a predicate and Collector downStream object, which is again usually the type of collection we
 want each of our values to be stored in. As the previous method only allowed our values to be stored in lists, this method allows us to store our 
 values in any type of Collection, here we store our values in a Set with this method call <code>
 Map&lt;Boolean,Set&lt;String&gt;&gt;partMapSet=animals.stream().
				collect(
						Collectors.partitioningBy(s-&gt;s.length()&gt;=4, Collectors.toSet())
						);</code>
        the second argument here is what determines that the values in our map will be Set of Strings. However Collectors can produce more than just Collection
        objects and have many method that can produce a wide variety of data types, for instance <code>
	Map&lt;Integer,Long&gt;longIntMap=animals.stream().collect(
				//String::length is the key, and what we are grouping by
				//Collectors.counting() is the amount of strings in each of these groups
				Collectors.groupingBy(String::length,Collectors.counting()));	</code>
        will produce a Map with the amount of characters in a String and a value which be the amount of Strings that have that amount of characters in a String.
        So from our list of Strings <code>"dog","cat","mouse","cow","sheep","pig","elephant","antelope"</code>
        the Map produced is <code>
 3=4, 5=2, 8=2
	</code>* which is
 4 strings with 3 characters
 2 String with 5 characters
 2 strings with 8 characters</div>
</section>
</li>
<li>
<section class="detail" id="ex9()">
<h3>ex9</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">ex9</span>()</div>
<div class="block">Collectors.groupingBy() as we have seen in the previous code allows us to group our streams in whatever criteria we want, here we cover the method
Collectors.mapping() which allows us to format the values produced by Collectors.groupingBy() in whatever way we want. This method is used as the 
second argument in Collectors.groupingBy(function(v,k>, Collectors) and is best explained by an example, we have a stream of Strings <code>
"dog","cat","mouse","cow","sheep","pig", "elephant","dolphin" </code>
which again we call "animals". We want to produce a Map that will consist of the Amount of characters in a String as the key, and the values will be the
all the animals with that amount of characters in the string, this will produce <code>
 3=[dog, cat, cow, pig], 5=[mouse, sheep], 7=[dolphin], 8=[elephant</code>
 3 characters in dog,cat,cow,pig
 5 characters in mouse and sheep
 7 characters in dolphin
 8 characters in elephant
 so the code that does this is as follows: <code>
 Map&lt;Integer,List&lt;String&gt;&gt;strMap=animals.stream().
				collect(Collectors.groupingBy(
						String::length,//this is what we are grouping our strings by, which will be the key
						//this is for producing the value
						Collectors.mapping(
								
								//  this takes in a string and returns a string							 
								s-&gt;s//this is a function, takes in a string returns a string
								//saves them to a collection of strings
								, Collectors.toList()
								)	//end of Collectors.mapping
						)//end of groupingBy
					);//end of Stream	</code>
 Collectors.mapping takes two argument, first argument is a mapper, which is a
 function, it takes in the strings and produces a String which will be the Strings of the Stream
 second argument is a downstream collector which is a reduction, which
 is what all the character will be stored in. so all the characters will be 
 stored in a List of characters. this is the type of VALUE in the hashMap</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Examples.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
